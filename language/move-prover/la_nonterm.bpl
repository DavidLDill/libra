// Boogie program verifier version 2.7.9.0, Copyright (c) 2003-2014, Microsoft.
// Command Line Options: libra_account_nonterm.bpl

function $DebugTrackLocal(file_id: int, byte_index: int, var_idx: int, $Value: $Value) : bool;

axiom (forall file_id: int, byte_index: int, var_idx: int, $Value: $Value :: {:qid "quantifier0"} { $DebugTrackLocal(file_id, byte_index, var_idx, $Value): bool } $DebugTrackLocal(file_id, byte_index, var_idx, $Value): bool == true);

function $DebugTrackAbort(file_id: int, byte_index: int, code: int) : bool;

axiom (forall file_id: int, byte_index: int, code: int :: {:qid "quantifier1"} { $DebugTrackAbort(file_id, byte_index, code): bool } $DebugTrackAbort(file_id, byte_index, code): bool == true);

function $DebugTrackExp(module_id: int, node_id: int, $Value: $Value) : $Value;

axiom (forall module_id: int, node_id: int, $Value: $Value :: {:qid "quantifier2"} { $DebugTrackExp(module_id, node_id, $Value): $Value } $DebugTrackExp(module_id, node_id, $Value): $Value == $Value);

type {:datatype} $Path;

function {:constructor} $Path(p: [int]int, size: int) : $Path;

const $EmptyPath: $Path;

axiom size#$Path($EmptyPath) == 0;

function {:inline} $path_index_at(p: $Path, i: int) : int
{
  p#$Path(p)[i]
}

type $TypeName;

type $FieldName = int;

type $LocalName;

type {:datatype} $TypeValue;

function {:constructor} $BooleanType() : $TypeValue;

function {:constructor} $IntegerType() : $TypeValue;

function {:constructor} $AddressType() : $TypeValue;

function {:constructor} $StrType() : $TypeValue;

function {:constructor} $VectorType(t: $TypeValue) : $TypeValue;

function {:constructor} $StructType(name: $TypeName, ts: $TypeValueArray) : $TypeValue;

function {:constructor} $TypeType() : $TypeValue;

function {:constructor} $ErrorType() : $TypeValue;

function {:inline} $DefaultTypeValue() : $TypeValue
{
  $ErrorType()
}

function {:builtin "MapConst"} $MapConstTypeValue(tv: $TypeValue) : [int]$TypeValue;

type {:datatype} $TypeValueArray;

function {:constructor} $TypeValueArray(v: [int]$TypeValue, l: int) : $TypeValueArray;

const $EmptyTypeValueArray: $TypeValueArray;

axiom l#$TypeValueArray($EmptyTypeValueArray) == 0;

axiom v#$TypeValueArray($EmptyTypeValueArray) == $MapConstTypeValue($DefaultTypeValue());

type {:datatype} $Value;

const $MAX_U8: int;

axiom $MAX_U8 == 255;

const $MAX_U64: int;

axiom $MAX_U64 == 18446744073709551615;

const $MAX_U128: int;

axiom $MAX_U128 == 340282366920938463463374607431768211455;

function {:constructor} $Boolean(b: bool) : $Value;

function {:constructor} $Integer(i: int) : $Value;

function {:constructor} $Address(a: int) : $Value;

function {:constructor} $Vector(v: $ValueArray) : $Value;

function {:constructor} $Range(lb: $Value, ub: $Value) : $Value;

function {:constructor} $Type(t: $TypeValue) : $Value;

function {:constructor} $Error() : $Value;

function {:inline} $DefaultValue() : $Value
{
  $Error()
}

function {:builtin "MapConst"} $MapConstValue(v: $Value) : [int]$Value;

function {:inline} $IsValidU8(v: $Value) : bool
{
  is#$Integer(v) && i#$Integer(v) >= 0 && i#$Integer(v) <= $MAX_U8
}

function {:inline} $IsValidU8Vector(vec: $Value) : bool
{
  $Vector_is_well_formed(vec) && (forall i: int :: {:qid "quantifier3"} { $select_vector(vec, i) } 0 <= i && i < $vlen(vec) ==> $IsValidU8($select_vector(vec, i)))
}

function {:inline} $IsValidU64(v: $Value) : bool
{
  is#$Integer(v) && i#$Integer(v) >= 0 && i#$Integer(v) <= $MAX_U64
}

function {:inline} $IsValidU128(v: $Value) : bool
{
  is#$Integer(v) && i#$Integer(v) >= 0 && i#$Integer(v) <= $MAX_U128
}

function {:inline} $IsValidNum(v: $Value) : bool
{
  is#$Integer(v)
}

type {:datatype} $ValueArray;

function {:constructor} $ValueArray(v: [int]$Value, l: int) : $ValueArray;

function $EmptyValueArray() : $ValueArray;

axiom l#$ValueArray($EmptyValueArray()) == 0;

axiom v#$ValueArray($EmptyValueArray()) == $MapConstValue($Error());

function {:inline} $ReadValueArray(a: $ValueArray, i: int) : $Value
{
  v#$ValueArray(a)[i]
}

function {:inline} $LenValueArray(a: $ValueArray) : int
{
  l#$ValueArray(a)
}

function {:inline} $RemoveValueArray(a: $ValueArray) : $ValueArray
{
  (var l := l#$ValueArray(a) - 1; $ValueArray((lambda i: int :: {:qid "quantifier4"} (if i >= 0 && i < l then v#$ValueArray(a)[i] else $DefaultValue())), l))
}

function {:inline} $SingleValueArray(v: $Value) : $ValueArray
{
  $ValueArray($MapConstValue($DefaultValue())[0 := v], 1)
}

function {:inline} $RemoveIndexValueArray(a: $ValueArray, i: int) : $ValueArray
{
  (var l := l#$ValueArray(a) - 1; $ValueArray((lambda j: int :: {:qid "quantifier5"} (if j >= 0 && j < l then (if j < i then v#$ValueArray(a)[j] else v#$ValueArray(a)[j + 1]) else $DefaultValue())), l))
}

function {:inline} $ConcatValueArray(a1: $ValueArray, a2: $ValueArray) : $ValueArray
{
  (var l1, m1, l2, m2 := l#$ValueArray(a1), v#$ValueArray(a1), l#$ValueArray(a2), v#$ValueArray(a2); $ValueArray((lambda i: int :: {:qid "quantifier6"} (if i >= 0 && i < l1 + l2 then (if i < l1 then m1[i] else m2[i - l1]) else $DefaultValue())), l1 + l2))
}

function {:inline} $ReverseValueArray(a: $ValueArray) : $ValueArray
{
  (var l := l#$ValueArray(a); $ValueArray((lambda i: int :: {:qid "quantifier7"} (if 0 <= i && i < l then v#$ValueArray(a)[l - i - 1] else $DefaultValue())), l))
}

function {:inline} $SliceValueArray(a: $ValueArray, i: int, j: int) : $ValueArray
{
  $ValueArray((lambda k: int :: {:qid "quantifier8"} (if 0 <= k && k < j - i then v#$ValueArray(a)[i + k] else $DefaultValue())), (if j - i < 0 then 0 else j - i))
}

function {:inline} $ExtendValueArray(a: $ValueArray, elem: $Value) : $ValueArray
{
  (var len := l#$ValueArray(a); $ValueArray(v#$ValueArray(a)[len := elem], len + 1))
}

function {:inline} $UpdateValueArray(a: $ValueArray, i: int, elem: $Value) : $ValueArray
{
  $ValueArray(v#$ValueArray(a)[i := elem], l#$ValueArray(a))
}

function {:inline} $SwapValueArray(a: $ValueArray, i: int, j: int) : $ValueArray
{
  $ValueArray(v#$ValueArray(a)[i := v#$ValueArray(a)[j]][j := v#$ValueArray(a)[i]], l#$ValueArray(a))
}

function {:inline} $IsEmpty(a: $ValueArray) : bool
{
  l#$ValueArray(a) == 0
}

function {:inline} $IsNormalizedValueArray(a: $ValueArray, len: int) : bool
{
  (forall i: int :: {:qid "quantifier9"} i < 0 || i >= len ==> v#$ValueArray(a)[i] == $DefaultValue())
}

const $StratificationDepth: int;

axiom $StratificationDepth == 4;

function $IsEqual_stratified(v1: $Value, v2: $Value) : bool;

axiom (forall v1: $Value, v2: $Value :: {:qid "quantifier10"} { $IsEqual_stratified(v1, v2): bool } $IsEqual_stratified(v1, v2): bool == (v1 == v2 || (is#$Vector(v1) && is#$Vector(v2) && $vlen(v1) == $vlen(v2) && (forall i: int :: {:qid "quantifier11"} 0 <= i && i < $vlen(v1) ==> $IsEqual_level1($select_vector(v1, i), $select_vector(v2, i))))));

function $IsEqual_level1(v1: $Value, v2: $Value) : bool;

axiom (forall v1: $Value, v2: $Value :: {:qid "quantifier12"} { $IsEqual_level1(v1, v2): bool } $IsEqual_level1(v1, v2): bool == (v1 == v2 || (is#$Vector(v1) && is#$Vector(v2) && $vlen(v1) == $vlen(v2) && (forall i: int :: {:qid "quantifier13"} 0 <= i && i < $vlen(v1) ==> $IsEqual_level2($select_vector(v1, i), $select_vector(v2, i))))));

function $IsEqual_level2(v1: $Value, v2: $Value) : bool;

axiom (forall v1: $Value, v2: $Value :: {:qid "quantifier14"} { $IsEqual_level2(v1, v2): bool } $IsEqual_level2(v1, v2): bool == (v1 == v2 || (is#$Vector(v1) && is#$Vector(v2) && $vlen(v1) == $vlen(v2) && (forall i: int :: {:qid "quantifier15"} 0 <= i && i < $vlen(v1) ==> $IsEqual_level3($select_vector(v1, i), $select_vector(v2, i))))));

function {:inline} $IsEqual_level3(v1: $Value, v2: $Value) : bool
{
  v1 == v2
}

function {:inline} $IsEqual(v1: $Value, v2: $Value) : bool
{
  $IsEqual_stratified(v1, v2)
}

function $ReadValue_stratified(p: $Path, v: $Value) : $Value;

axiom (forall p: $Path, v: $Value :: {:qid "quantifier16"} { $ReadValue_stratified(p, v): $Value } $ReadValue_stratified(p, v): $Value == (if 0 == size#$Path(p) then v else $ReadValue_level1(p, $select_vector(v, $path_index_at(p, 0)))));

function $ReadValue_level1(p: $Path, v: $Value) : $Value;

axiom (forall p: $Path, v: $Value :: {:qid "quantifier17"} { $ReadValue_level1(p, v): $Value } $ReadValue_level1(p, v): $Value == (if 1 == size#$Path(p) then v else $ReadValue_level2(p, $select_vector(v, $path_index_at(p, 1)))));

function $ReadValue_level2(p: $Path, v: $Value) : $Value;

axiom (forall p: $Path, v: $Value :: {:qid "quantifier18"} { $ReadValue_level2(p, v): $Value } $ReadValue_level2(p, v): $Value == (if 2 == size#$Path(p) then v else $ReadValue_level3(p, $select_vector(v, $path_index_at(p, 2)))));

function {:inline} $ReadValue_level3(p: $Path, v: $Value) : $Value
{
  v
}

function {:inline} $ReadValue(p: $Path, v: $Value) : $Value
{
  $ReadValue_stratified(p, v)
}

function $UpdateValue_stratified(p: $Path, offset: int, v: $Value, new_v: $Value) : $Value;

axiom (forall p: $Path, offset: int, v: $Value, new_v: $Value :: {:qid "quantifier19"} { $UpdateValue_stratified(p, offset, v, new_v): $Value } $UpdateValue_stratified(p, offset, v, new_v): $Value == (var poffset := offset + 0; (if poffset == size#$Path(p) then new_v else $update_vector(v, $path_index_at(p, poffset), $UpdateValue_level1(p, offset, $select_vector(v, $path_index_at(p, poffset)), new_v)))));

function $UpdateValue_level1(p: $Path, offset: int, v: $Value, new_v: $Value) : $Value;

axiom (forall p: $Path, offset: int, v: $Value, new_v: $Value :: {:qid "quantifier20"} { $UpdateValue_level1(p, offset, v, new_v): $Value } $UpdateValue_level1(p, offset, v, new_v): $Value == (var poffset := offset + 1; (if poffset == size#$Path(p) then new_v else $update_vector(v, $path_index_at(p, poffset), $UpdateValue_level2(p, offset, $select_vector(v, $path_index_at(p, poffset)), new_v)))));

function $UpdateValue_level2(p: $Path, offset: int, v: $Value, new_v: $Value) : $Value;

axiom (forall p: $Path, offset: int, v: $Value, new_v: $Value :: {:qid "quantifier21"} { $UpdateValue_level2(p, offset, v, new_v): $Value } $UpdateValue_level2(p, offset, v, new_v): $Value == (var poffset := offset + 2; (if poffset == size#$Path(p) then new_v else $update_vector(v, $path_index_at(p, poffset), $UpdateValue_level3(p, offset, $select_vector(v, $path_index_at(p, poffset)), new_v)))));

function {:inline} $UpdateValue_level3(p: $Path, offset: int, v: $Value, new_v: $Value) : $Value
{
  new_v
}

function {:inline} $UpdateValue(p: $Path, offset: int, v: $Value, new_v: $Value) : $Value
{
  $UpdateValue_stratified(p, offset, v, new_v)
}

function $IsPathPrefix_stratified(p1: $Path, p2: $Path) : bool;

axiom (forall p1: $Path, p2: $Path :: {:qid "quantifier22"} { $IsPathPrefix_stratified(p1, p2): bool } $IsPathPrefix_stratified(p1, p2): bool == (if 0 == size#$Path(p1) then true else (if p#$Path(p1)[0] == p#$Path(p2)[0] then $IsPathPrefix_level1(p1, p2) else false)));

function $IsPathPrefix_level1(p1: $Path, p2: $Path) : bool;

axiom (forall p1: $Path, p2: $Path :: {:qid "quantifier23"} { $IsPathPrefix_level1(p1, p2): bool } $IsPathPrefix_level1(p1, p2): bool == (if 1 == size#$Path(p1) then true else (if p#$Path(p1)[1] == p#$Path(p2)[1] then $IsPathPrefix_level2(p1, p2) else false)));

function $IsPathPrefix_level2(p1: $Path, p2: $Path) : bool;

axiom (forall p1: $Path, p2: $Path :: {:qid "quantifier24"} { $IsPathPrefix_level2(p1, p2): bool } $IsPathPrefix_level2(p1, p2): bool == (if 2 == size#$Path(p1) then true else (if p#$Path(p1)[2] == p#$Path(p2)[2] then $IsPathPrefix_level3(p1, p2) else false)));

function {:inline} $IsPathPrefix_level3(p1: $Path, p2: $Path) : bool
{
  true
}

function {:inline} $IsPathPrefix(p1: $Path, p2: $Path) : bool
{
  $IsPathPrefix_stratified(p1, p2)
}

function $ConcatPath_stratified(p1: $Path, p2: $Path) : $Path;

axiom (forall p1: $Path, p2: $Path :: {:qid "quantifier25"} { $ConcatPath_stratified(p1, p2): $Path } $ConcatPath_stratified(p1, p2): $Path == (if 0 == size#$Path(p2) then p1 else $ConcatPath_level1($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[0]], size#$Path(p1) + 1), p2)));

function $ConcatPath_level1(p1: $Path, p2: $Path) : $Path;

axiom (forall p1: $Path, p2: $Path :: {:qid "quantifier26"} { $ConcatPath_level1(p1, p2): $Path } $ConcatPath_level1(p1, p2): $Path == (if 1 == size#$Path(p2) then p1 else $ConcatPath_level2($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[1]], size#$Path(p1) + 1), p2)));

function $ConcatPath_level2(p1: $Path, p2: $Path) : $Path;

axiom (forall p1: $Path, p2: $Path :: {:qid "quantifier27"} { $ConcatPath_level2(p1, p2): $Path } $ConcatPath_level2(p1, p2): $Path == (if 2 == size#$Path(p2) then p1 else $ConcatPath_level3($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[2]], size#$Path(p1) + 1), p2)));

function {:inline} $ConcatPath_level3(p1: $Path, p2: $Path) : $Path
{
  p1
}

function {:inline} $ConcatPath(p1: $Path, p2: $Path) : $Path
{
  $ConcatPath_stratified(p1, p2)
}

function {:inline} $vlen(v: $Value) : int
{
  $LenValueArray(v#$Vector(v))
}

function {:inline} $is_normalized_vector(v: $Value) : bool
{
  $IsNormalizedValueArray(v#$Vector(v), $vlen(v))
}

function {:inline} $vlen_value(v: $Value) : $Value
{
  $Integer($vlen(v))
}

function {:inline} $mk_vector() : $Value
{
  $Vector($EmptyValueArray())
}

function {:inline} $push_back_vector(v: $Value, elem: $Value) : $Value
{
  $Vector($ExtendValueArray(v#$Vector(v), elem))
}

function {:inline} $pop_back_vector(v: $Value) : $Value
{
  $Vector($RemoveValueArray(v#$Vector(v)))
}

function {:inline} $single_vector(v: $Value) : $Value
{
  $Vector($SingleValueArray(v))
}

function {:inline} $append_vector(v1: $Value, v2: $Value) : $Value
{
  $Vector($ConcatValueArray(v#$Vector(v1), v#$Vector(v2)))
}

function {:inline} $reverse_vector(v: $Value) : $Value
{
  $Vector($ReverseValueArray(v#$Vector(v)))
}

function {:inline} $update_vector(v: $Value, i: int, elem: $Value) : $Value
{
  $Vector($UpdateValueArray(v#$Vector(v), i, elem))
}

function {:inline} $update_vector_by_value(v: $Value, i: $Value, elem: $Value) : $Value
{
  $Vector($UpdateValueArray(v#$Vector(v), i#$Integer(i), elem))
}

function {:inline} $select_vector(v: $Value, i: int) : $Value
{
  $ReadValueArray(v#$Vector(v), i)
}

function {:inline} $select_vector_by_value(v: $Value, i: $Value) : $Value
{
  $select_vector(v, i#$Integer(i))
}

function {:inline} $swap_vector(v: $Value, i: int, j: int) : $Value
{
  $Vector($SwapValueArray(v#$Vector(v), i, j))
}

function {:inline} $slice_vector(v: $Value, r: $Value) : $Value
{
  $Vector($SliceValueArray(v#$Vector(v), i#$Integer(lb#$Range(r)), i#$Integer(ub#$Range(r))))
}

function {:inline} $InVectorRange(v: $Value, i: int) : bool
{
  i >= 0 && i < $vlen(v)
}

function {:inline} $remove_vector(v: $Value, i: int) : $Value
{
  $Vector($RemoveIndexValueArray(v#$Vector(v), i))
}

function {:inline} $contains_vector(v: $Value, e: $Value) : bool
{
  (exists i: int :: {:qid "quantifier28"} 0 <= i && i < $vlen(v) && $IsEqual($select_vector(v, i), e))
}

function {:inline} $InRange(r: $Value, i: int) : bool
{
  i#$Integer(lb#$Range(r)) <= i && i < i#$Integer(ub#$Range(r))
}

type {:datatype} $Location;

function {:constructor} $Global(ts: $TypeValueArray, a: int) : $Location;

function {:constructor} $Local(i: int) : $Location;

function {:constructor} $Param(i: int) : $Location;

type {:datatype} $Mutation;

function {:constructor} $Mutation(l: $Location, p: $Path, v: $Value) : $Mutation;

const $DefaultMutation: $Mutation;

type {:datatype} $Memory;

function {:constructor} $Memory(domain: [$TypeValueArray,int]bool, contents: [$TypeValueArray,int]$Value) : $Memory;

function {:inline} $Memory__is_well_formed(m: $Memory) : bool
{
  true
}

function {:builtin "MapConst"} $ConstMemoryDomain(v: bool) : [$TypeValueArray,int]bool;

function {:builtin "MapConst"} $ConstMemoryContent(v: $Value) : [$TypeValueArray,int]$Value;

const $EmptyMemory: $Memory;

axiom domain#$Memory($EmptyMemory) == $ConstMemoryDomain(false);

axiom contents#$Memory($EmptyMemory) == $ConstMemoryContent($DefaultValue());

var $abort_flag: bool;

var $abort_code: int;

const $EXEC_FAILURE_CODE: int;

axiom $EXEC_FAILURE_CODE == -1;

procedure {:inline 1} $ExecFailureAbort();



implementation {:inline 1} $ExecFailureAbort()
{
    $abort_flag := true;
    $abort_code := $EXEC_FAILURE_CODE;
}



procedure {:inline 1} $InitVerification();



implementation {:inline 1} $InitVerification()
{
    $abort_flag := false;
    havoc $abort_code;
}



function {:inline} $ResourceExistsRaw(m: $Memory, args: $TypeValueArray, addr: int) : bool
{
  domain#$Memory(m)[args, addr]
}

function {:inline} $ResourceExists(m: $Memory, args: $TypeValueArray, addr: $Value) : $Value
{
  $Boolean($ResourceExistsRaw(m, args, a#$Address(addr)))
}

function {:inline} $ResourceValue(m: $Memory, args: $TypeValueArray, addr: $Value) : $Value
{
  contents#$Memory(m)[args, a#$Address(addr)]
}

function {:inline} $SelectField(val: $Value, field: $FieldName) : $Value
{
  $select_vector(val, field)
}

function {:inline} $Dereference(ref: $Mutation) : $Value
{
  v#$Mutation(ref)
}

procedure {:inline 1} $MoveToRaw(m: $Memory, ta: $TypeValueArray, a: int, v: $Value) returns (m': $Memory);



implementation {:inline 1} $MoveToRaw(m: $Memory, ta: $TypeValueArray, a: int, v: $Value) returns (m': $Memory)
{
    if ($ResourceExistsRaw(m, ta, a))
    {
        call $ExecFailureAbort();
        return;
    }

    m' := $Memory(domain#$Memory(m)[ta, a := true], contents#$Memory(m)[ta, a := v]);
}



procedure {:inline 1} $MoveTo(m: $Memory, ta: $TypeValueArray, v: $Value, signer: $Value) returns (m': $Memory);



implementation {:inline 1} $MoveTo(m: $Memory, ta: $TypeValueArray, v: $Value, signer: $Value) returns (m': $Memory)
{
  var addr: $Value;

    call addr := $Signer_borrow_address(signer);
    call m' := $MoveToRaw(m, ta, a#$Address(addr), v);
}



procedure {:inline 1} $MoveFrom(m: $Memory, address: $Value, ta: $TypeValueArray) returns (m': $Memory, dst: $Value);
  free requires is#$Address(address);



implementation {:inline 1} $MoveFrom(m: $Memory, address: $Value, ta: $TypeValueArray) returns (m': $Memory, dst: $Value)
{
  var a: int;

    a := a#$Address(address);
    if (!$ResourceExistsRaw(m, ta, a))
    {
        call $ExecFailureAbort();
        return;
    }

    dst := contents#$Memory(m)[ta, a];
    m' := $Memory(domain#$Memory(m)[ta, a := false], contents#$Memory(m)[ta, a := $DefaultValue()]);
}



procedure {:inline 1} $BorrowGlobal(m: $Memory, address: $Value, ta: $TypeValueArray) returns (dst: $Mutation);
  free requires is#$Address(address);



implementation {:inline 1} $BorrowGlobal(m: $Memory, address: $Value, ta: $TypeValueArray) returns (dst: $Mutation)
{
  var a: int;

    a := a#$Address(address);
    if (!$ResourceExistsRaw(m, ta, a))
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Mutation($Global(ta, a), $EmptyPath, contents#$Memory(m)[ta, a]);
}



procedure {:inline 1} $BorrowLoc(l: int, v: $Value) returns (dst: $Mutation);



implementation {:inline 1} $BorrowLoc(l: int, v: $Value) returns (dst: $Mutation)
{
    dst := $Mutation($Local(l), $EmptyPath, v);
}



procedure {:inline 1} $BorrowField(src: $Mutation, f: $FieldName) returns (dst: $Mutation);



implementation {:inline 1} $BorrowField(src: $Mutation, f: $FieldName) returns (dst: $Mutation)
{
  var p: $Path;
  var size: int;

    p := p#$Mutation(src);
    size := size#$Path(p);
    p := $Path(p#$Path(p)[size := f], size + 1);
    dst := $Mutation(l#$Mutation(src), p, $select_vector(v#$Mutation(src), f));
}



procedure {:inline 1} $GetGlobal(m: $Memory, address: $Value, ta: $TypeValueArray) returns (dst: $Value);
  free requires is#$Address(address);



implementation {:inline 1} $GetGlobal(m: $Memory, address: $Value, ta: $TypeValueArray) returns (dst: $Value)
{
  var a: int;

    a := a#$Address(address);
    if (!$ResourceExistsRaw(m, ta, a))
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $ResourceValue(m, ta, address);
}



procedure {:inline 1} $GetFieldFromReference(src: $Mutation, f: $FieldName) returns (dst: $Value);



implementation {:inline 1} $GetFieldFromReference(src: $Mutation, f: $FieldName) returns (dst: $Value)
{
  var r: $Mutation;

    call r := $BorrowField(src, f);
    call dst := $ReadRef(r);
}



procedure {:inline 1} $GetFieldFromValue(src: $Value, f: $FieldName) returns (dst: $Value);



implementation {:inline 1} $GetFieldFromValue(src: $Value, f: $FieldName) returns (dst: $Value)
{
    dst := $select_vector(src, f);
}



procedure {:inline 1} $WriteRef(to: $Mutation, new_v: $Value) returns (to': $Mutation);



implementation {:inline 1} $WriteRef(to: $Mutation, new_v: $Value) returns (to': $Mutation)
{
    to' := $Mutation(l#$Mutation(to), p#$Mutation(to), new_v);
}



procedure {:inline 1} $ReadRef(from: $Mutation) returns (v: $Value);



implementation {:inline 1} $ReadRef(from: $Mutation) returns (v: $Value)
{
    v := v#$Mutation(from);
}



procedure {:inline 1} $CopyOrMoveRef(local: $Mutation) returns (dst: $Mutation);



implementation {:inline 1} $CopyOrMoveRef(local: $Mutation) returns (dst: $Mutation)
{
    dst := local;
}



procedure {:inline 1} $CopyOrMoveValue(local: $Value) returns (dst: $Value);



implementation {:inline 1} $CopyOrMoveValue(local: $Value) returns (dst: $Value)
{
    dst := local;
}



procedure {:inline 1} $WritebackToGlobal(m: $Memory, src: $Mutation) returns (m': $Memory);



implementation {:inline 1} $WritebackToGlobal(m: $Memory, src: $Mutation) returns (m': $Memory)
{
  var l: $Location;
  var ta: $TypeValueArray;
  var a: int;
  var v: $Value;

    l := l#$Mutation(src);
    if (is#$Global(l))
    {
        ta := ts#$Global(l);
        a := a#$Global(l);
        v := $UpdateValue(p#$Mutation(src), 0, contents#$Memory(m)[ta, a], v#$Mutation(src));
        m' := $Memory(domain#$Memory(m), contents#$Memory(m)[ta, a := v]);
    }
    else
    {
        m' := m;
    }
}



procedure {:inline 1} $WritebackToValue(src: $Mutation, idx: int, vdst: $Value) returns (vdst': $Value);



implementation {:inline 1} $WritebackToValue(src: $Mutation, idx: int, vdst: $Value) returns (vdst': $Value)
{
    if (l#$Mutation(src) == $Local(idx))
    {
        vdst' := $UpdateValue(p#$Mutation(src), 0, vdst, v#$Mutation(src));
    }
    else
    {
        vdst' := vdst;
    }
}



procedure {:inline 1} $WritebackToReference(src: $Mutation, dst: $Mutation) returns (dst': $Mutation);



implementation {:inline 1} $WritebackToReference(src: $Mutation, dst: $Mutation) returns (dst': $Mutation)
{
  var srcPath: $Path;
  var dstPath: $Path;

    srcPath := p#$Mutation(src);
    dstPath := p#$Mutation(dst);
    if (l#$Mutation(dst) == l#$Mutation(src) && size#$Path(dstPath) <= size#$Path(srcPath) && $IsPathPrefix(dstPath, srcPath))
    {
        dst' := $Mutation(l#$Mutation(dst), dstPath, $UpdateValue(srcPath, size#$Path(dstPath), v#$Mutation(dst), v#$Mutation(src)));
    }
    else
    {
        dst' := dst;
    }
}



procedure {:inline 1} $Splice1(idx1: int, src1: $Mutation, dst: $Mutation) returns (dst': $Mutation);



implementation {:inline 1} $Splice1(idx1: int, src1: $Mutation, dst: $Mutation) returns (dst': $Mutation)
{
    dst' := $Mutation(l#$Mutation(src1), $ConcatPath(p#$Mutation(src1), p#$Mutation(dst)), v#$Mutation(dst));
}



procedure {:inline 1} $CastU8(src: $Value) returns (dst: $Value);
  free requires is#$Integer(src);



implementation {:inline 1} $CastU8(src: $Value) returns (dst: $Value)
{
    if (i#$Integer(src) > $MAX_U8)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := src;
}



procedure {:inline 1} $CastU64(src: $Value) returns (dst: $Value);
  free requires is#$Integer(src);



implementation {:inline 1} $CastU64(src: $Value) returns (dst: $Value)
{
    if (i#$Integer(src) > $MAX_U64)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := src;
}



procedure {:inline 1} $CastU128(src: $Value) returns (dst: $Value);
  free requires is#$Integer(src);



implementation {:inline 1} $CastU128(src: $Value) returns (dst: $Value)
{
    if (i#$Integer(src) > $MAX_U128)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := src;
}



procedure {:inline 1} $AddU8(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires $IsValidU8(src1) && $IsValidU8(src2);



implementation {:inline 1} $AddU8(src1: $Value, src2: $Value) returns (dst: $Value)
{
    if (i#$Integer(src1) + i#$Integer(src2) > $MAX_U8)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}



procedure {:inline 1} $AddU64(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires $IsValidU64(src1) && $IsValidU64(src2);



implementation {:inline 1} $AddU64(src1: $Value, src2: $Value) returns (dst: $Value)
{
    if (i#$Integer(src1) + i#$Integer(src2) > $MAX_U64)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}



procedure {:inline 1} $AddU64_unchecked(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires $IsValidU64(src1) && $IsValidU64(src2);



implementation {:inline 1} $AddU64_unchecked(src1: $Value, src2: $Value) returns (dst: $Value)
{
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}



procedure {:inline 1} $AddU128(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires $IsValidU128(src1) && $IsValidU128(src2);



implementation {:inline 1} $AddU128(src1: $Value, src2: $Value) returns (dst: $Value)
{
    if (i#$Integer(src1) + i#$Integer(src2) > $MAX_U128)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}



procedure {:inline 1} $AddU128_unchecked(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires $IsValidU128(src1) && $IsValidU128(src2);



implementation {:inline 1} $AddU128_unchecked(src1: $Value, src2: $Value) returns (dst: $Value)
{
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}



procedure {:inline 1} $Sub(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Integer(src1) && is#$Integer(src2);



implementation {:inline 1} $Sub(src1: $Value, src2: $Value) returns (dst: $Value)
{
    if (i#$Integer(src1) < i#$Integer(src2))
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Integer(i#$Integer(src1) - i#$Integer(src2));
}



function $power_of_2(power: $Value) : int;

axiom (forall power: $Value :: {:qid "quantifier29"} { $power_of_2(power): int } $power_of_2(power): int == (var p := i#$Integer(power); (if p == 32 then 4294967296 else (if p == 64 then 18446744073709551616 else -1))));

procedure {:inline 1} $Shl(src1: $Value, src2: $Value) returns (dst: $Value);
  requires is#$Integer(src1) && is#$Integer(src2);



implementation {:inline 1} $Shl(src1: $Value, src2: $Value) returns (dst: $Value)
{
  var po2: int;

    po2 := $power_of_2(src2);
    assert po2 >= 1;
    dst := $Integer(i#$Integer(src2) * po2);
}



procedure {:inline 1} $Shr(src1: $Value, src2: $Value) returns (dst: $Value);
  requires is#$Integer(src1) && is#$Integer(src2);



implementation {:inline 1} $Shr(src1: $Value, src2: $Value) returns (dst: $Value)
{
  var po2: int;

    po2 := $power_of_2(src2);
    assert po2 >= 1;
    dst := $Integer(i#$Integer(src2) div po2);
}



procedure {:inline 1} $MulU8(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires $IsValidU8(src1) && $IsValidU8(src2);



implementation {:inline 1} $MulU8(src1: $Value, src2: $Value) returns (dst: $Value)
{
    if (i#$Integer(src1) * i#$Integer(src2) > $MAX_U8)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Integer(i#$Integer(src1) * i#$Integer(src2));
}



procedure {:inline 1} $MulU64(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires $IsValidU64(src1) && $IsValidU64(src2);



implementation {:inline 1} $MulU64(src1: $Value, src2: $Value) returns (dst: $Value)
{
    if (i#$Integer(src1) * i#$Integer(src2) > $MAX_U64)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Integer(i#$Integer(src1) * i#$Integer(src2));
}



procedure {:inline 1} $MulU128(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires $IsValidU128(src1) && $IsValidU128(src2);



implementation {:inline 1} $MulU128(src1: $Value, src2: $Value) returns (dst: $Value)
{
    if (i#$Integer(src1) * i#$Integer(src2) > $MAX_U128)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Integer(i#$Integer(src1) * i#$Integer(src2));
}



procedure {:inline 1} $Div(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Integer(src1) && is#$Integer(src2);



implementation {:inline 1} $Div(src1: $Value, src2: $Value) returns (dst: $Value)
{
    if (i#$Integer(src2) == 0)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Integer(i#$Integer(src1) div i#$Integer(src2));
}



procedure {:inline 1} $Mod(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Integer(src1) && is#$Integer(src2);



implementation {:inline 1} $Mod(src1: $Value, src2: $Value) returns (dst: $Value)
{
    if (i#$Integer(src2) == 0)
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Integer(i#$Integer(src1) mod i#$Integer(src2));
}



procedure {:inline 1} $ArithBinaryUnimplemented(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Integer(src1) && is#$Integer(src2);
  ensures is#$Integer(dst);



procedure {:inline 1} $Lt(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Integer(src1) && is#$Integer(src2);



implementation {:inline 1} $Lt(src1: $Value, src2: $Value) returns (dst: $Value)
{
    dst := $Boolean(i#$Integer(src1) < i#$Integer(src2));
}



procedure {:inline 1} $Gt(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Integer(src1) && is#$Integer(src2);



implementation {:inline 1} $Gt(src1: $Value, src2: $Value) returns (dst: $Value)
{
    dst := $Boolean(i#$Integer(src1) > i#$Integer(src2));
}



procedure {:inline 1} $Le(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Integer(src1) && is#$Integer(src2);



implementation {:inline 1} $Le(src1: $Value, src2: $Value) returns (dst: $Value)
{
    dst := $Boolean(i#$Integer(src1) <= i#$Integer(src2));
}



procedure {:inline 1} $Ge(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Integer(src1) && is#$Integer(src2);



implementation {:inline 1} $Ge(src1: $Value, src2: $Value) returns (dst: $Value)
{
    dst := $Boolean(i#$Integer(src1) >= i#$Integer(src2));
}



procedure {:inline 1} $And(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Boolean(src1) && is#$Boolean(src2);



implementation {:inline 1} $And(src1: $Value, src2: $Value) returns (dst: $Value)
{
    dst := $Boolean(b#$Boolean(src1) && b#$Boolean(src2));
}



procedure {:inline 1} $Or(src1: $Value, src2: $Value) returns (dst: $Value);
  free requires is#$Boolean(src1) && is#$Boolean(src2);



implementation {:inline 1} $Or(src1: $Value, src2: $Value) returns (dst: $Value)
{
    dst := $Boolean(b#$Boolean(src1) || b#$Boolean(src2));
}



procedure {:inline 1} $Not(src: $Value) returns (dst: $Value);
  free requires is#$Boolean(src);



implementation {:inline 1} $Not(src: $Value) returns (dst: $Value)
{
    dst := $Boolean(!b#$Boolean(src));
}



function {:inline} $Vector_type_value(tv: $TypeValue) : $TypeValue
{
  $VectorType(tv)
}

function {:inline} $Vector_is_well_formed(v: $Value) : bool
{
  is#$Vector(v) && (var va := v#$Vector(v); (var l := l#$ValueArray(va); 0 <= l && l <= $MAX_U64 && (forall x: int :: {:qid "quantifier30"} { v#$ValueArray(va)[x] } x < 0 || x >= l ==> v#$ValueArray(va)[x] == $DefaultValue())))
}

procedure {:inline 1} $Vector_empty(ta: $TypeValue) returns (v: $Value);



implementation {:inline 1} $Vector_empty(ta: $TypeValue) returns (v: $Value)
{
    v := $mk_vector();
}



procedure {:inline 1} $Vector_is_empty(ta: $TypeValue, v: $Value) returns (b: $Value);



implementation {:inline 1} $Vector_is_empty(ta: $TypeValue, v: $Value) returns (b: $Value)
{
    assume is#$Vector(v);
    b := $Boolean($vlen(v) == 0);
}



procedure {:inline 1} $Vector_push_back(ta: $TypeValue, v: $Value, val: $Value) returns (v': $Value);



implementation {:inline 1} $Vector_push_back(ta: $TypeValue, v: $Value, val: $Value) returns (v': $Value)
{
    assume is#$Vector(v);
    v' := $push_back_vector(v, val);
}



procedure {:inline 1} $Vector_pop_back(ta: $TypeValue, v: $Value) returns (e: $Value, v': $Value);



implementation {:inline 1} $Vector_pop_back(ta: $TypeValue, v: $Value) returns (e: $Value, v': $Value)
{
  var len: int;

    assume is#$Vector(v);
    len := $vlen(v);
    if (len == 0)
    {
        call $ExecFailureAbort();
        return;
    }

    e := $select_vector(v, len - 1);
    v' := $pop_back_vector(v);
}



procedure {:inline 1} $Vector_append(ta: $TypeValue, v: $Value, other: $Value) returns (v': $Value);



implementation {:inline 1} $Vector_append(ta: $TypeValue, v: $Value, other: $Value) returns (v': $Value)
{
    assume is#$Vector(v);
    assume is#$Vector(other);
    v' := $append_vector(v, other);
}



procedure {:inline 1} $Vector_reverse(ta: $TypeValue, v: $Value) returns (v': $Value);



implementation {:inline 1} $Vector_reverse(ta: $TypeValue, v: $Value) returns (v': $Value)
{
    assume is#$Vector(v);
    v' := $reverse_vector(v);
}



procedure {:inline 1} $Vector_length(ta: $TypeValue, v: $Value) returns (l: $Value);



implementation {:inline 1} $Vector_length(ta: $TypeValue, v: $Value) returns (l: $Value)
{
    assume is#$Vector(v);
    l := $Integer($vlen(v));
}



procedure {:inline 1} $Vector_borrow(ta: $TypeValue, src: $Value, i: $Value) returns (dst: $Value);



implementation {:inline 1} $Vector_borrow(ta: $TypeValue, src: $Value, i: $Value) returns (dst: $Value)
{
  var i_ind: int;

    assume is#$Vector(src);
    assume is#$Integer(i);
    i_ind := i#$Integer(i);
    if (i_ind < 0 || i_ind >= $vlen(src))
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $select_vector(src, i_ind);
}



procedure {:inline 1} $Vector_borrow_mut(ta: $TypeValue, v: $Value, index: $Value) returns (dst: $Mutation, v': $Value);
  free requires is#$Integer(index);



implementation {:inline 1} $Vector_borrow_mut(ta: $TypeValue, v: $Value, index: $Value) returns (dst: $Mutation, v': $Value)
{
  var i_ind: int;

    i_ind := i#$Integer(index);
    assume is#$Vector(v);
    if (i_ind < 0 || i_ind >= $vlen(v))
    {
        call $ExecFailureAbort();
        return;
    }

    dst := $Mutation($Local(0), $Path(p#$Path($EmptyPath)[0 := i_ind], 1), $select_vector(v, i_ind));
    v' := v;
}



procedure {:inline 1} $Vector_destroy_empty(ta: $TypeValue, v: $Value);



implementation {:inline 1} $Vector_destroy_empty(ta: $TypeValue, v: $Value)
{
    if ($vlen(v) != 0)
    {
        call $ExecFailureAbort();
    }
}



procedure {:inline 1} $Vector_swap(ta: $TypeValue, v: $Value, i: $Value, j: $Value) returns (v': $Value);
  free requires is#$Integer(i) && is#$Integer(j);



implementation {:inline 1} $Vector_swap(ta: $TypeValue, v: $Value, i: $Value, j: $Value) returns (v': $Value)
{
  var i_ind: int;
  var j_ind: int;

    assume is#$Vector(v);
    i_ind := i#$Integer(i);
    j_ind := i#$Integer(j);
    if (i_ind >= $vlen(v) || j_ind >= $vlen(v) || i_ind < 0 || j_ind < 0)
    {
        call $ExecFailureAbort();
        return;
    }

    v' := $swap_vector(v, i_ind, j_ind);
}



procedure {:inline 1} $Vector_remove(ta: $TypeValue, v: $Value, i: $Value) returns (e: $Value, v': $Value);
  free requires is#$Integer(i);



implementation {:inline 1} $Vector_remove(ta: $TypeValue, v: $Value, i: $Value) returns (e: $Value, v': $Value)
{
  var i_ind: int;

    assume is#$Vector(v);
    i_ind := i#$Integer(i);
    if (i_ind < 0 || i_ind >= $vlen(v))
    {
        call $ExecFailureAbort();
        return;
    }

    e := $select_vector(v, i_ind);
    v' := $remove_vector(v, i_ind);
}



procedure {:inline 1} $Vector_swap_remove(ta: $TypeValue, v: $Value, i: $Value) returns (e: $Value, v': $Value);
  free requires is#$Integer(i);



implementation {:inline 1} $Vector_swap_remove(ta: $TypeValue, v: $Value, i: $Value) returns (e: $Value, v': $Value)
{
  var i_ind: int;
  var len: int;

    assume is#$Vector(v);
    i_ind := i#$Integer(i);
    len := $vlen(v);
    if (i_ind < 0 || i_ind >= len)
    {
        call $ExecFailureAbort();
        return;
    }

    e := $select_vector(v, i_ind);
    v' := $pop_back_vector($swap_vector(v, i_ind, len - 1));
}



procedure {:inline 1} $Vector_contains(ta: $TypeValue, v: $Value, e: $Value) returns (res: $Value);



implementation {:inline 1} $Vector_contains(ta: $TypeValue, v: $Value, e: $Value) returns (res: $Value)
{
    assume is#$Vector(v);
    res := $Boolean($contains_vector(v, e));
}



procedure {:inline 1} $Vector_index_of(ta: $TypeValue, v: $Value, e: $Value) returns (res1: $Value, res2: $Value);
  requires is#$Vector(v);
  ensures is#$Boolean(res1);
  ensures is#$Integer(res2);
  ensures 0 <= i#$Integer(res2) && i#$Integer(res2) < $vlen(v);
  ensures res1 == $Boolean($contains_vector(v, e));
  ensures b#$Boolean(res1) ==> $IsEqual($select_vector(v, i#$Integer(res2)), e);
  ensures b#$Boolean(res1) ==> (forall i: int :: {:qid "quantifier31"} 0 <= i && i < i#$Integer(res2) ==> !$IsEqual($select_vector(v, i), e));
  ensures !b#$Boolean(res1) ==> i#$Integer(res2) == 0;



function {:inline} $Hash_sha2(val: $Value) : $Value
{
  $Hash_sha2_core(val)
}

function $Hash_sha2_core(val: $Value) : $Value;

axiom (forall v1: $Value, v2: $Value :: {:qid "quantifier32"} $Vector_is_well_formed(v1) && $Vector_is_well_formed(v2) && $IsEqual(v1, v2) ==> $IsEqual($Hash_sha2_core(v1), $Hash_sha2_core(v2)));

axiom (forall v1: $Value, v2: $Value :: {:qid "quantifier33"} $Vector_is_well_formed(v1) && $Vector_is_well_formed(v2) && $IsEqual($Hash_sha2_core(v1), $Hash_sha2_core(v2)) ==> $IsEqual(v1, v2));

procedure $Hash_sha2_256(val: $Value) returns (res: $Value);
  free requires $IsValidU8Vector(val);
  ensures res == $Hash_sha2_core(val);
  ensures $IsValidU8Vector(res);
  ensures $vlen(res) == 32;



function {:inline} $Hash_sha3(val: $Value) : $Value
{
  $Hash_sha3_core(val)
}

function $Hash_sha3_core(val: $Value) : $Value;

axiom (forall v1: $Value, v2: $Value :: {:qid "quantifier34"} $Vector_is_well_formed(v1) && $Vector_is_well_formed(v2) && $IsEqual(v1, v2) ==> $IsEqual($Hash_sha3_core(v1), $Hash_sha3_core(v2)));

axiom (forall v1: $Value, v2: $Value :: {:qid "quantifier35"} $Vector_is_well_formed(v1) && $Vector_is_well_formed(v2) && $IsEqual($Hash_sha3_core(v1), $Hash_sha3_core(v2)) ==> $IsEqual(v1, v2));

procedure $Hash_sha3_256(val: $Value) returns (res: $Value);
  ensures res == $Hash_sha3_core(val);
  ensures $IsValidU8Vector(res);
  ensures $vlen(res) == 32;



procedure {:inline 1} $LibraAccount_create_signer(addr: $Value) returns (signer: $Value);



implementation {:inline 1} $LibraAccount_create_signer(addr: $Value) returns (signer: $Value)
{
    signer := addr;
}



procedure {:inline 1} $LibraAccount_destroy_signer(signer: $Value);



implementation {:inline 1} $LibraAccount_destroy_signer(signer: $Value)
{
    return;
}



procedure {:inline 1} $Signer_borrow_address(signer: $Value) returns (res: $Value);
  free requires is#$Address(signer);



implementation {:inline 1} $Signer_borrow_address(signer: $Value) returns (res: $Value)
{
    res := signer;
}



function $Signature_spec_ed25519_validate_pubkey(public_key: $Value) : $Value;

function $Signature_spec_ed25519_verify(signature: $Value, public_key: $Value, message: $Value) : $Value;

axiom (forall public_key: $Value :: {:qid "quantifier36"} is#$Boolean($Signature_spec_ed25519_validate_pubkey(public_key)));

axiom (forall signature: $Value, public_key: $Value, message: $Value :: {:qid "quantifier37"} is#$Boolean($Signature_spec_ed25519_verify(signature, public_key, message)));

procedure {:inline 1} $Signature_ed25519_validate_pubkey(public_key: $Value) returns (res: $Value);



implementation {:inline 1} $Signature_ed25519_validate_pubkey(public_key: $Value) returns (res: $Value)
{
    res := $Signature_spec_ed25519_validate_pubkey(public_key);
}



procedure {:inline 1} $Signature_ed25519_verify(signature: $Value, public_key: $Value, message: $Value) returns (res: $Value);



implementation {:inline 1} $Signature_ed25519_verify(signature: $Value, public_key: $Value, message: $Value) returns (res: $Value)
{
    res := $Signature_spec_ed25519_verify(signature, public_key, message);
}



function {:inline} $LCS_serialize(ta: $TypeValue, v: $Value) : $Value
{
  $LCS_serialize_core(v)
}

function $LCS_serialize_core(v: $Value) : $Value;

function $LCS_serialize_core_inv(v: $Value) : $Value;

axiom (forall v1: $Value, v2: $Value :: {:qid "quantifier38"} $IsEqual(v1, v2) ==> $LCS_serialize_core(v1) == $LCS_serialize_core(v2));

axiom (forall v: $Value :: {:qid "quantifier39"} $LCS_serialize_core_inv($LCS_serialize_core(v)) == v);

axiom (forall v: $Value :: {:qid "quantifier40"} (var r := $LCS_serialize_core(v); $IsValidU8Vector(r) && $vlen(r) > 0 && $vlen(r) <= 4));

const $serialized_address_len: int;

axiom (forall v: $Value :: {:qid "quantifier41"} (var r := $LCS_serialize_core(v); is#$Address(v) ==> $vlen(r) == $serialized_address_len));

procedure $LCS_to_bytes(ta: $TypeValue, v: $Value) returns (res: $Value);
  ensures res == $LCS_serialize(ta, v);
  ensures $IsValidU8Vector(res);



function {:inline} $Signer_spec_address_of(signer: $Value) : $Value
{
  signer
}

procedure {:inline 1} $Event_new_event_handle(t: $TypeValue, signer: $Value) returns (res: $Value);



implementation {:inline 1} $Event_new_event_handle(t: $TypeValue, signer: $Value) returns (res: $Value)
{
}



procedure {:inline 1} $Event_publish_generator(account: $Value);



implementation {:inline 1} $Event_publish_generator(account: $Value)
{
}



procedure {:inline 1} $Event_emit_event(t: $TypeValue, handler: $Value, msg: $Value) returns (res: $Value);



implementation {:inline 1} $Event_emit_event(t: $TypeValue, handler: $Value, msg: $Value) returns (res: $Value)
{
    res := handler;
}



procedure {:inline 1} $Signer_address_of_$def(s: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Signer_address_of_$def(s: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(24, 407, 0, s);
    }

    call $tmp := $CopyOrMoveValue(s);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    call $t2 := $Signer_borrow_address($t1);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(24, 460, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Signer_address_of_$direct_inter(s: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Signer_spec_address_of(s))));
  ensures is#$Address($ret0);



procedure {:inline 1} $Signer_address_of_$direct_intra(s: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Signer_spec_address_of(s))));
  ensures is#$Address($ret0);



procedure {:inline 1} $Signer_address_of(s: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Signer_spec_address_of(s))));
  ensures is#$Address($ret0);



function {:inline} $CoreAddresses_$CURRENCY_INFO_ADDRESS() : $Value
{
  $Address(173345816)
}

function {:inline} $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS() : $Value
{
  $Address(173345816)
}

function {:inline} $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS() : $Value
{
  $Address(173345816)
}

function {:inline} $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS() : $Value
{
  $Address(186537453)
}

function {:inline} $CoreAddresses_SPEC_VM_RESERVED_ADDRESS() : $Value
{
  $Address(0)
}

procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_$def() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    $tmp := $Address(173345816);
    $t0 := $tmp;
    $ret0 := $t0;
    if (true)
    {
        assume $DebugTrackLocal(7, 884, 1, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_$direct_inter() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_CURRENCY_INFO_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_CURRENCY_INFO_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_CURRENCY_INFO_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_$def() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    $tmp := $Address(173345816);
    $t0 := $tmp;
    $ret0 := $t0;
    if (true)
    {
        assume $DebugTrackLocal(7, 324, 1, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_inter() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$def() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    $tmp := $Address(186537453);
    $t0 := $tmp;
    $ret0 := $t0;
    if (true)
    {
        assume $DebugTrackLocal(7, 1352, 1, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$direct_inter() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_$def() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    $tmp := $Address(0);
    $t0 := $tmp;
    $ret0 := $t0;
    if (true)
    {
        assume $DebugTrackLocal(7, 1888, 1, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_$direct_inter() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_VM_RESERVED_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_VM_RESERVED_ADDRESS_$def();
}



procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS() returns ($ret0: $Value);



implementation {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_VM_RESERVED_ADDRESS_$def();
}



function {:inline} $LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory: $Memory) : $Value
{
  $Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_TimeHasStarted_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))
}

function {:inline} $LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory: $Memory) : $Value
{
  $Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))
}

function {:inline} $LibraTimestamp_spec_is_not_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory) : $Value
{
  $Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_root_ctm_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory)))) || b#$Boolean($Boolean($IsEqual($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory), $Integer(0)))))
}

function {:inline} $LibraTimestamp_spec_root_ctm_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory) : $Value
{
  $ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory) : $Value
{
  $SelectField($ResourceValue($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()), $LibraTimestamp_CurrentTimeMicroseconds_microseconds)
}

const unique $LibraTimestamp_CurrentTimeMicroseconds: $TypeName;

const $LibraTimestamp_CurrentTimeMicroseconds_microseconds: $FieldName;

axiom $LibraTimestamp_CurrentTimeMicroseconds_microseconds == 0;

function $LibraTimestamp_CurrentTimeMicroseconds_type_value() : $TypeValue;

axiom $LibraTimestamp_CurrentTimeMicroseconds_type_value(): $TypeValue == $StructType($LibraTimestamp_CurrentTimeMicroseconds, $EmptyTypeValueArray);

var $LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory;

var $LibraTimestamp_CurrentTimeMicroseconds_$memory_$old: $Memory;

function {:inline} $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $LibraTimestamp_CurrentTimeMicroseconds_microseconds))
}

function {:inline} $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $LibraTimestamp_CurrentTimeMicroseconds_microseconds))
}

procedure {:inline 1} $LibraTimestamp_CurrentTimeMicroseconds_pack($file_id: int, $byte_index: int, $var_idx: int, microseconds: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraTimestamp_CurrentTimeMicroseconds_pack($file_id: int, $byte_index: int, $var_idx: int, microseconds: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(microseconds);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := microseconds], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraTimestamp_CurrentTimeMicroseconds_unpack($struct: $Value) returns (microseconds: $Value);



implementation {:inline 1} $LibraTimestamp_CurrentTimeMicroseconds_unpack($struct: $Value) returns (microseconds: $Value)
{
    assume is#$Vector($struct);
    microseconds := $SelectField($struct, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    assume $IsValidU64(microseconds);
}



const unique $LibraTimestamp_TimeHasStarted: $TypeName;

const $LibraTimestamp_TimeHasStarted_dummy_field: $FieldName;

axiom $LibraTimestamp_TimeHasStarted_dummy_field == 0;

function $LibraTimestamp_TimeHasStarted_type_value() : $TypeValue;

axiom $LibraTimestamp_TimeHasStarted_type_value(): $TypeValue == $StructType($LibraTimestamp_TimeHasStarted, $EmptyTypeValueArray);

var $LibraTimestamp_TimeHasStarted_$memory: $Memory;

var $LibraTimestamp_TimeHasStarted_$memory_$old: $Memory;

function {:inline} $LibraTimestamp_TimeHasStarted_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $LibraTimestamp_TimeHasStarted_dummy_field))
}

function {:inline} $LibraTimestamp_TimeHasStarted_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $LibraTimestamp_TimeHasStarted_dummy_field))
}

procedure {:inline 1} $LibraTimestamp_TimeHasStarted_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraTimestamp_TimeHasStarted_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraTimestamp_TimeHasStarted_unpack($struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $LibraTimestamp_TimeHasStarted_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LibraTimestamp_TimeHasStarted_dummy_field);
    assume is#$Boolean(dummy_field);
}



procedure {:inline 1} $LibraTimestamp_initialize_$def(lr_account: $Value);



implementation {:inline 1} $LibraTimestamp_initialize_$def(lr_account: $Value)
{
  var timer: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(18, 1223, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    call $t5 := $Signer_address_of($t4);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t6 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t5, $t6));
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 1351, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t14);
    $t9 := $tmp;
    $tmp := $Integer(0);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(18, 1351, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t14);
    $t11 := $tmp;
    $tmp := $Integer(0);
    $t12 := $tmp;
    call $tmp := $LibraTimestamp_CurrentTimeMicroseconds_pack(0, 0, 0, $t12);
    $t13 := $tmp;
    call $LibraTimestamp_CurrentTimeMicroseconds_$memory := $MoveTo($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $t13, $t11);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(18, 1603, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraTimestamp_initialize_$direct_inter(lr_account: $Value);
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($LibraTimestamp_spec_root_ctm_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) || b#$Boolean(old($LibraTimestamp_spec_root_ctm_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory)));
  ensures !$abort_flag ==> b#$Boolean($LibraTimestamp_spec_root_ctm_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory), $Integer(0))));



implementation {:inline 1} $LibraTimestamp_initialize_$direct_inter(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraTimestamp_initialize_$def(lr_account);
}



procedure {:inline 1} $LibraTimestamp_initialize_$direct_intra(lr_account: $Value);



implementation {:inline 1} $LibraTimestamp_initialize_$direct_intra(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraTimestamp_initialize_$def(lr_account);
}



procedure {:inline 1} $LibraTimestamp_initialize(lr_account: $Value);



implementation {:inline 1} $LibraTimestamp_initialize(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraTimestamp_initialize_$def(lr_account);
}



procedure {:inline 1} $LibraTimestamp_is_genesis_$def() returns ($ret0: $Value);



implementation {:inline 1} $LibraTimestamp_is_genesis_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($LibraTimestamp_TimeHasStarted_$memory, $EmptyTypeValueArray, $t0);
    $t1 := $tmp;
    call $tmp := $Not($t1);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(18, 3932, 3, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraTimestamp_is_genesis_$direct_inter() returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))));



implementation {:inline 1} $LibraTimestamp_is_genesis_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_genesis_$def();
}



procedure {:inline 1} $LibraTimestamp_is_genesis_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $LibraTimestamp_is_genesis_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_genesis_$def();
}



procedure {:inline 1} $LibraTimestamp_is_genesis() returns ($ret0: $Value);



implementation {:inline 1} $LibraTimestamp_is_genesis() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_genesis_$def();
}



procedure {:inline 1} $LibraTimestamp_is_not_initialized_$def() returns ($ret0: $Value);



implementation {:inline 1} $LibraTimestamp_is_not_initialized_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t1 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $t1);
    $t2 := $tmp;
    call $tmp := $Not($t2);
    $t3 := $tmp;
    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $Boolean(true);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t0 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 4167, 0, $tmp);
    }

    goto L3;

  L2:
    call $t5 := $LibraTimestamp_now_microseconds();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(0);
    $t6 := $tmp;
    $tmp := $Boolean($IsEqual($t5, $t6));
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t0 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 4167, 0, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t0;
    if (true)
    {
        assume $DebugTrackLocal(18, 4167, 9, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraTimestamp_is_not_initialized_$direct_inter() returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $LibraTimestamp_spec_is_not_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory))));



implementation {:inline 1} $LibraTimestamp_is_not_initialized_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_not_initialized_$def();
}



procedure {:inline 1} $LibraTimestamp_is_not_initialized_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $LibraTimestamp_is_not_initialized_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_not_initialized_$def();
}



procedure {:inline 1} $LibraTimestamp_is_not_initialized() returns ($ret0: $Value);



implementation {:inline 1} $LibraTimestamp_is_not_initialized() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_not_initialized_$def();
}



procedure {:inline 1} $LibraTimestamp_now_microseconds_$def() returns ($ret0: $Value);



implementation {:inline 1} $LibraTimestamp_now_microseconds_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($LibraTimestamp_CurrentTimeMicroseconds_$memory, $t0, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(18, 3716, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(18, 3716, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraTimestamp_now_microseconds_$direct_inter() returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))));



implementation {:inline 1} $LibraTimestamp_now_microseconds_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_now_microseconds_$def();
}



procedure {:inline 1} $LibraTimestamp_now_microseconds_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $LibraTimestamp_now_microseconds_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_now_microseconds_$def();
}



procedure {:inline 1} $LibraTimestamp_now_microseconds() returns ($ret0: $Value);



implementation {:inline 1} $LibraTimestamp_now_microseconds() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_now_microseconds_$def();
}



procedure {:inline 1} $LibraTimestamp_reset_time_has_started_for_test_$def();



implementation {:inline 1} $LibraTimestamp_reset_time_has_started_for_test_$def()
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraTimestamp_TimeHasStarted_$memory, $tmp := $MoveFrom($LibraTimestamp_TimeHasStarted_$memory, $t0, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(18, 2544, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    assert b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    call $t2 := $LibraTimestamp_TimeHasStarted_unpack($t1);
    $t2 := $t2;
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraTimestamp_reset_time_has_started_for_test_$direct_inter();



implementation {:inline 1} $LibraTimestamp_reset_time_has_started_for_test_$direct_inter()
{
    call $LibraTimestamp_reset_time_has_started_for_test_$def();
}



procedure {:inline 1} $LibraTimestamp_reset_time_has_started_for_test_$direct_intra();



implementation {:inline 1} $LibraTimestamp_reset_time_has_started_for_test_$direct_intra()
{
    call $LibraTimestamp_reset_time_has_started_for_test_$def();
}



procedure {:inline 1} $LibraTimestamp_reset_time_has_started_for_test();



implementation {:inline 1} $LibraTimestamp_reset_time_has_started_for_test()
{
    call $LibraTimestamp_reset_time_has_started_for_test_$def();
}



procedure {:inline 1} $LibraTimestamp_set_time_has_started_$def(lr_account: $Value);



implementation {:inline 1} $LibraTimestamp_set_time_has_started_$def(lr_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(18, 1742, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t26 := $tmp;
    call $tmp := $CopyOrMoveValue($t26);
    $t6 := $tmp;
    call $t7 := $Signer_address_of($t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t8 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t7, $t8));
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 1838, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t26);
    $t11 := $tmp;
    $tmp := $Integer(0);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(18, 1838, i#$Integer($t12));
    }

    $abort_code := i#$Integer($t12);
    goto Abort;

  L0:
    call $t13 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $t13);
    $t14 := $tmp;
    $tmp := $t14;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $t15 := $LibraTimestamp_now_microseconds();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(0);
    $t16 := $tmp;
    $tmp := $Boolean($IsEqual($t15, $t16));
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 2026, 5, $tmp);
    }

    goto L5;

  L4:
    $tmp := $Boolean(false);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 2026, 5, $tmp);
    }

    goto L5;

  L5:
    call $tmp := $CopyOrMoveValue($t5);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 2006, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    call $tmp := $CopyOrMoveValue($t26);
    $t21 := $tmp;
    $tmp := $Integer(1);
    $t22 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(18, 2006, i#$Integer($t22));
    }

    $abort_code := i#$Integer($t22);
    goto Abort;

  L6:
    call $tmp := $CopyOrMoveValue($t26);
    $t23 := $tmp;
    $tmp := $Boolean(false);
    $t24 := $tmp;
    call $tmp := $LibraTimestamp_TimeHasStarted_pack(0, 0, 0, $t24);
    $t25 := $tmp;
    call $LibraTimestamp_TimeHasStarted_$memory := $MoveTo($LibraTimestamp_TimeHasStarted_$memory, $EmptyTypeValueArray, $t25, $t23);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(18, 2176, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraTimestamp_set_time_has_started_$direct_inter(lr_account: $Value);
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_root_ctm_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory), $Integer(0))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_root_ctm_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) || b#$Boolean(old($Boolean(!$IsEqual($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory), $Integer(0)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))));



implementation {:inline 1} $LibraTimestamp_set_time_has_started_$direct_inter(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraTimestamp_set_time_has_started_$def(lr_account);
}



procedure {:inline 1} $LibraTimestamp_set_time_has_started_$direct_intra(lr_account: $Value);



implementation {:inline 1} $LibraTimestamp_set_time_has_started_$direct_intra(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraTimestamp_set_time_has_started_$def(lr_account);
}



procedure {:inline 1} $LibraTimestamp_set_time_has_started(lr_account: $Value);



implementation {:inline 1} $LibraTimestamp_set_time_has_started(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraTimestamp_set_time_has_started_$def(lr_account);
}



procedure {:inline 1} $LibraTimestamp_update_global_time_$def(account: $Value, proposer: $Value, timestamp: $Value);



implementation {:inline 1} $LibraTimestamp_update_global_time_$def(account: $Value, proposer: $Value, timestamp: $Value)
{
  var global_timer: $Mutation;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Mutation;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Mutation;
  var $t28: $Value;
  var $t29: $Mutation;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Mutation;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Mutation;
  var $t39: $Mutation;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(18, 2734, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(18, 2734, 1, proposer);
    }

    if (true)
    {
        assume $DebugTrackLocal(18, 2734, 2, timestamp);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t40 := $tmp;
    call $tmp := $CopyOrMoveValue(proposer);
    $t41 := $tmp;
    call $tmp := $CopyOrMoveValue(timestamp);
    $t42 := $tmp;
    call $tmp := $CopyOrMoveValue($t40);
    $t10 := $tmp;
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t12 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 2943, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(18, 2943, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L0:
    call $t16 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t17 := $BorrowGlobal($LibraTimestamp_CurrentTimeMicroseconds_$memory, $t16, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(18, 3057, $abort_code);
        goto Abort;
    }

    call global_timer := $CopyOrMoveRef($t17);
    if (true)
    {
        assume $DebugTrackLocal(18, 3042, 3, $Dereference(global_timer));
    }

    call $t19 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t41, $t19));
    $t20 := $tmp;
    $tmp := $t20;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $t22 := $CopyOrMoveRef(global_timer);
    call $tmp := $GetFieldFromReference($t22, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    $t23 := $tmp;
    call global_timer := $WritebackToReference($t22, global_timer);
    call $tmp := $CopyOrMoveValue($t23);
    $t24 := $tmp;
    $tmp := $Boolean($IsEqual($t42, $t24));
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue($t25);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 3295, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L5;
    }
    else
    {
        goto L6;
    }

  L6:
    call $t27 := $CopyOrMoveRef(global_timer);
    call $LibraTimestamp_CurrentTimeMicroseconds_$memory := $WritebackToGlobal($LibraTimestamp_CurrentTimeMicroseconds_$memory, $t27);
    $tmp := $Integer(3);
    $t28 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(18, 3295, i#$Integer($t28));
    }

    $abort_code := i#$Integer($t28);
    goto Abort;

  L5:
    goto L7;

  L4:
    call $t29 := $CopyOrMoveRef(global_timer);
    call $tmp := $GetFieldFromReference($t29, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    $t30 := $tmp;
    call global_timer := $WritebackToReference($t29, global_timer);
    call $tmp := $CopyOrMoveValue($t30);
    $t31 := $tmp;
    call $tmp := $Lt($t31, $t42);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue($t33);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(18, 3439, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L7;
    }
    else
    {
        goto L8;
    }

  L8:
    call $t35 := $CopyOrMoveRef(global_timer);
    call $LibraTimestamp_CurrentTimeMicroseconds_$memory := $WritebackToGlobal($LibraTimestamp_CurrentTimeMicroseconds_$memory, $t35);
    $tmp := $Integer(3);
    $t36 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(18, 3439, i#$Integer($t36));
    }

    $abort_code := i#$Integer($t36);
    goto Abort;

  L7:
    call $t38 := $CopyOrMoveRef(global_timer);
    call $t39 := $BorrowField($t38, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    call $LibraTimestamp_CurrentTimeMicroseconds_$memory := $WritebackToGlobal($LibraTimestamp_CurrentTimeMicroseconds_$memory, $t38);
    call $t39 := $WriteRef($t39, $t42);
    if (true)
    {
        assume $DebugTrackLocal(18, 3525, 3, $Dereference(global_timer));
    }

    call $LibraTimestamp_CurrentTimeMicroseconds_$memory := $WritebackToGlobal($LibraTimestamp_CurrentTimeMicroseconds_$memory, $t39);
    call $t38 := $WritebackToReference($t39, $t38);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraTimestamp_update_global_time_$direct_inter(account: $Value, proposer: $Value, timestamp: $Value);
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_SPEC_VM_RESERVED_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_root_ctm_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual(proposer, $CoreAddresses_SPEC_VM_RESERVED_ADDRESS()))) && b#$Boolean($Boolean(!$IsEqual(timestamp, $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual(proposer, $CoreAddresses_SPEC_VM_RESERVED_ADDRESS()))) && b#$Boolean($Boolean(!b#$Boolean($Boolean(i#$Integer(timestamp) > i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_SPEC_VM_RESERVED_ADDRESS())))) || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_root_ctm_initialized($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual(proposer, $CoreAddresses_SPEC_VM_RESERVED_ADDRESS()))) && b#$Boolean($Boolean(!$IsEqual(timestamp, $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual(proposer, $CoreAddresses_SPEC_VM_RESERVED_ADDRESS()))) && b#$Boolean($Boolean(!b#$Boolean($Boolean(i#$Integer(timestamp) > i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory), timestamp)));



implementation {:inline 1} $LibraTimestamp_update_global_time_$direct_inter(account: $Value, proposer: $Value, timestamp: $Value)
{
    assume is#$Address(account);
    assume is#$Address(proposer);
    assume $IsValidU64(timestamp);
    call $LibraTimestamp_update_global_time_$def(account, proposer, timestamp);
}



procedure {:inline 1} $LibraTimestamp_update_global_time_$direct_intra(account: $Value, proposer: $Value, timestamp: $Value);



implementation {:inline 1} $LibraTimestamp_update_global_time_$direct_intra(account: $Value, proposer: $Value, timestamp: $Value)
{
    assume is#$Address(account);
    assume is#$Address(proposer);
    assume $IsValidU64(timestamp);
    call $LibraTimestamp_update_global_time_$def(account, proposer, timestamp);
}



procedure {:inline 1} $LibraTimestamp_update_global_time(account: $Value, proposer: $Value, timestamp: $Value);



implementation {:inline 1} $LibraTimestamp_update_global_time(account: $Value, proposer: $Value, timestamp: $Value)
{
    assume is#$Address(account);
    assume is#$Address(proposer);
    assume $IsValidU64(timestamp);
    call $LibraTimestamp_update_global_time_$def(account, proposer, timestamp);
}



function {:inline} $Roles_spec_get_role_id($Roles_RoleId_$memory: $Memory, account: $Value) : $Value
{
  (var addr := $Signer_spec_address_of(account); $SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id))
}

function {:inline} $Roles_spec_has_role_id_addr($Roles_RoleId_$memory: $Memory, addr: $Value, role_id: $Value) : $Value
{
  $Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), role_id))))
}

function {:inline} $Roles_SPEC_LIBRA_ROOT_ROLE_ID() : $Value
{
  $Integer(0)
}

function {:inline} $Roles_SPEC_TREASURY_COMPLIANCE_ROLE_ID() : $Value
{
  $Integer(1)
}

function {:inline} $Roles_SPEC_DESIGNATED_DEALER_ROLE_ID() : $Value
{
  $Integer(2)
}

function {:inline} $Roles_SPEC_VALIDATOR_ROLE_ID() : $Value
{
  $Integer(3)
}

function {:inline} $Roles_SPEC_VALIDATOR_OPERATOR_ROLE_ID() : $Value
{
  $Integer(4)
}

function {:inline} $Roles_SPEC_PARENT_VASP_ROLE_ID() : $Value
{
  $Integer(5)
}

function {:inline} $Roles_SPEC_CHILD_VASP_ROLE_ID() : $Value
{
  $Integer(6)
}

function {:inline} $Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Roles_SPEC_LIBRA_ROOT_ROLE_ID())
}

function {:inline} $Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Roles_SPEC_TREASURY_COMPLIANCE_ROLE_ID())
}

function {:inline} $Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Roles_SPEC_DESIGNATED_DEALER_ROLE_ID())
}

function {:inline} $Roles_spec_has_validator_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Roles_SPEC_VALIDATOR_ROLE_ID())
}

function {:inline} $Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Roles_SPEC_VALIDATOR_OPERATOR_ROLE_ID())
}

function {:inline} $Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Roles_SPEC_PARENT_VASP_ROLE_ID())
}

function {:inline} $Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Roles_SPEC_CHILD_VASP_ROLE_ID())
}

function {:inline} $Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)
}

function {:inline} $Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)
}

function {:inline} $Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) || b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)))) || b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)))
}

function {:inline} $Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory: $Memory, addr: $Value) : $Value
{
  $Boolean(b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)) && b#$Boolean($Boolean(!b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)))))
}

const unique $Roles_RoleId: $TypeName;

const $Roles_RoleId_role_id: $FieldName;

axiom $Roles_RoleId_role_id == 0;

function $Roles_RoleId_type_value() : $TypeValue;

axiom $Roles_RoleId_type_value(): $TypeValue == $StructType($Roles_RoleId, $EmptyTypeValueArray);

var $Roles_RoleId_$memory: $Memory;

var $Roles_RoleId_$memory_$old: $Memory;

function {:inline} $Roles_RoleId_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $Roles_RoleId_role_id))
}

function {:inline} $Roles_RoleId_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $Roles_RoleId_role_id))
}

procedure {:inline 1} $Roles_RoleId_pack($file_id: int, $byte_index: int, $var_idx: int, role_id: $Value) returns ($struct: $Value);



implementation {:inline 1} $Roles_RoleId_pack($file_id: int, $byte_index: int, $var_idx: int, role_id: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(role_id);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := role_id], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Roles_RoleId_unpack($struct: $Value) returns (role_id: $Value);



implementation {:inline 1} $Roles_RoleId_unpack($struct: $Value) returns (role_id: $Value)
{
    assume is#$Vector($struct);
    role_id := $SelectField($struct, $Roles_RoleId_role_id);
    assume $IsValidU64(role_id);
}



procedure {:inline 1} $Roles_can_hold_balance_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_can_hold_balance_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 11525, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t3 := $tmp;
    call $t4 := $Roles_has_parent_VASP_role($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $Boolean(true);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 11798, 1, $tmp);
    }

    goto L3;

  L2:
    call $tmp := $CopyOrMoveValue($t14);
    $t6 := $tmp;
    call $t7 := $Roles_has_child_VASP_role($t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 11798, 1, $tmp);
    }

    goto L3;

  L3:
    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    goto L6;

  L4:
    call $tmp := $CopyOrMoveValue($t14);
    $t9 := $tmp;
    $tmp := $Boolean(true);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 11798, 2, $tmp);
    }

    goto L7;

  L6:
    call $tmp := $CopyOrMoveValue($t14);
    $t11 := $tmp;
    call $t12 := $Roles_has_designated_dealer_role($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 11798, 2, $tmp);
    }

    goto L7;

  L7:
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(22, 11798, 15, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_can_hold_balance_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_can_hold_balance_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_can_hold_balance_$def(account);
}



procedure {:inline 1} $Roles_can_hold_balance_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier42"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier43"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier44"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier45"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier46"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier47"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier48"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier49"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier50"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier51"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier52"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier53"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier54"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier55"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_can_hold_balance_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_can_hold_balance_$def(account);
}



procedure {:inline 1} $Roles_can_hold_balance(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_can_hold_balance(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_can_hold_balance_$def(account);
}



procedure {:inline 1} $Roles_grant_libra_root_role_$def(lr_account: $Value);



implementation {:inline 1} $Roles_grant_libra_root_role_$def(lr_account: $Value)
{
  var owner_address: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 2167, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t21 := $tmp;
    call $t6 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 2246, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t21);
    $t8 := $tmp;
    $tmp := $Integer(0);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 2246, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t21);
    $t10 := $tmp;
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    owner_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 2310, 1, $tmp);
    }

    call $t13 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual(owner_address, $t13));
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 2366, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t21);
    $t16 := $tmp;
    $tmp := $Integer(1);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 2366, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t21);
    $t18 := $tmp;
    $tmp := $Integer(0);
    $t19 := $tmp;
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t19);
    $t20 := $tmp;
    call $Roles_RoleId_$memory := $MoveTo($Roles_RoleId_$memory, $EmptyTypeValueArray, $t20, $t18);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(22, 2511, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier56"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Roles_grant_libra_root_role_$direct_inter(lr_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(lr_account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) || b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(lr_account))));
  ensures !$abort_flag ==> b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(lr_account)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(lr_account)), $Roles_RoleId_role_id), $Roles_SPEC_LIBRA_ROOT_ROLE_ID())));



implementation {:inline 1} $Roles_grant_libra_root_role_$direct_inter(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $Roles_grant_libra_root_role_$def(lr_account);
}



procedure {:inline 1} $Roles_grant_libra_root_role_$direct_intra(lr_account: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier57"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier58"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier59"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier60"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier61"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier62"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier63"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier64"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier65"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier66"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier67"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier68"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier69"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier70"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_grant_libra_root_role_$direct_intra(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $Roles_grant_libra_root_role_$def(lr_account);
}



procedure {:inline 1} $Roles_grant_libra_root_role(lr_account: $Value);



implementation {:inline 1} $Roles_grant_libra_root_role(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $Roles_grant_libra_root_role_$def(lr_account);
}



procedure {:inline 1} $Roles_grant_treasury_compliance_role_$def(treasury_compliance_account: $Value, lr_account: $Value);



implementation {:inline 1} $Roles_grant_treasury_compliance_role_$def(treasury_compliance_account: $Value, lr_account: $Value)
{
  var owner_address: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 3162, 0, treasury_compliance_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(22, 3162, 1, lr_account);
    }

    call $tmp := $CopyOrMoveValue(treasury_compliance_account);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue(lr_account);
    $t31 := $tmp;
    call $t9 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 3312, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t30);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t12 := $tmp;
    $tmp := $Integer(0);
    $t13 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 3312, i#$Integer($t13));
    }

    $abort_code := i#$Integer($t13);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t31);
    $t14 := $tmp;
    call $t15 := $Roles_has_libra_root_role($t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t15);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 3372, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t30);
    $t17 := $tmp;
    $tmp := $Integer(3);
    $t18 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 3372, i#$Integer($t18));
    }

    $abort_code := i#$Integer($t18);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t30);
    $t19 := $tmp;
    call $t20 := $Signer_address_of($t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t20);
    owner_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 3447, 2, $tmp);
    }

    call $t22 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual(owner_address, $t22));
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 3520, 7, $tmp);
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $tmp := $CopyOrMoveValue($t30);
    $t25 := $tmp;
    $tmp := $Integer(2);
    $t26 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 3520, i#$Integer($t26));
    }

    $abort_code := i#$Integer($t26);
    goto Abort;

  L4:
    call $tmp := $CopyOrMoveValue($t30);
    $t27 := $tmp;
    $tmp := $Integer(1);
    $t28 := $tmp;
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t28);
    $t29 := $tmp;
    call $Roles_RoleId_$memory := $MoveTo($Roles_RoleId_$memory, $EmptyTypeValueArray, $t29, $t27);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(22, 3684, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier71"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Roles_grant_treasury_compliance_role_$direct_inter(treasury_compliance_account: $Value, lr_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(treasury_compliance_account), $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(treasury_compliance_account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) || b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(treasury_compliance_account), $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS())))) || b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(treasury_compliance_account))));
  ensures !$abort_flag ==> b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(treasury_compliance_account)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(treasury_compliance_account)), $Roles_RoleId_role_id), $Roles_SPEC_TREASURY_COMPLIANCE_ROLE_ID())));



implementation {:inline 1} $Roles_grant_treasury_compliance_role_$direct_inter(treasury_compliance_account: $Value, lr_account: $Value)
{
    assume is#$Address(treasury_compliance_account);
    assume is#$Address(lr_account);
    call $Roles_grant_treasury_compliance_role_$def(treasury_compliance_account, lr_account);
}



procedure {:inline 1} $Roles_grant_treasury_compliance_role_$direct_intra(treasury_compliance_account: $Value, lr_account: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier72"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier73"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier74"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier75"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier76"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier77"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier78"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier79"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier80"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier81"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier82"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier83"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier84"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier85"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_grant_treasury_compliance_role_$direct_intra(treasury_compliance_account: $Value, lr_account: $Value)
{
    assume is#$Address(treasury_compliance_account);
    assume is#$Address(lr_account);
    call $Roles_grant_treasury_compliance_role_$def(treasury_compliance_account, lr_account);
}



procedure {:inline 1} $Roles_grant_treasury_compliance_role(treasury_compliance_account: $Value, lr_account: $Value);



implementation {:inline 1} $Roles_grant_treasury_compliance_role(treasury_compliance_account: $Value, lr_account: $Value)
{
    assume is#$Address(treasury_compliance_account);
    assume is#$Address(lr_account);
    call $Roles_grant_treasury_compliance_role_$def(treasury_compliance_account, lr_account);
}



procedure {:inline 1} $Roles_has_child_VASP_role_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_child_VASP_role_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 11020, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    $tmp := $Integer(6);
    $t2 := $tmp;
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(22, 11101, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_child_VASP_role_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_child_VASP_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_child_VASP_role_$def(account);
}



procedure {:inline 1} $Roles_has_child_VASP_role_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier86"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier87"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier88"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier89"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier90"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier91"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier92"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier93"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier94"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier95"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier96"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier97"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier98"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier99"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_child_VASP_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_child_VASP_role_$def(account);
}



procedure {:inline 1} $Roles_has_child_VASP_role(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_child_VASP_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_child_VASP_role_$def(account);
}



procedure {:inline 1} $Roles_has_designated_dealer_role_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_designated_dealer_role_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 10470, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    $tmp := $Integer(2);
    $t2 := $tmp;
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(22, 10558, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_designated_dealer_role_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_designated_dealer_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_designated_dealer_role_$def(account);
}



procedure {:inline 1} $Roles_has_designated_dealer_role_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier100"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier101"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier102"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier103"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier104"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier105"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier106"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier107"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier108"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier109"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier110"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier111"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier112"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier113"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_designated_dealer_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_designated_dealer_role_$def(account);
}



procedure {:inline 1} $Roles_has_designated_dealer_role(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_designated_dealer_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_designated_dealer_role_$def(account);
}



procedure {:inline 1} $Roles_has_libra_root_role_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_libra_root_role_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 10192, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    $tmp := $Integer(0);
    $t2 := $tmp;
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(22, 10273, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_libra_root_role_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_libra_root_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_libra_root_role_$def(account);
}



procedure {:inline 1} $Roles_has_libra_root_role_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier114"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier115"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier116"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier117"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier118"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier119"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier120"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier121"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier122"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier123"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier124"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier125"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier126"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier127"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_libra_root_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_libra_root_role_$def(account);
}



procedure {:inline 1} $Roles_has_libra_root_role(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_libra_root_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_libra_root_role_$def(account);
}



procedure {:inline 1} $Roles_has_parent_VASP_role_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_parent_VASP_role_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 10888, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    $tmp := $Integer(5);
    $t2 := $tmp;
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(22, 10970, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_parent_VASP_role_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_parent_VASP_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_parent_VASP_role_$def(account);
}



procedure {:inline 1} $Roles_has_parent_VASP_role_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier128"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier129"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier130"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier131"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier132"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier133"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier134"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier135"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier136"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier137"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier138"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier139"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier140"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier141"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_parent_VASP_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_parent_VASP_role_$def(account);
}



procedure {:inline 1} $Roles_has_parent_VASP_role(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_parent_VASP_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_parent_VASP_role_$def(account);
}



procedure {:inline 1} $Roles_has_register_new_currency_privilege_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_register_new_currency_privilege_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 11150, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;
    call $t2 := $Roles_has_libra_root_role($t1);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(22, 11248, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_register_new_currency_privilege_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_register_new_currency_privilege_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_register_new_currency_privilege_$def(account);
}



procedure {:inline 1} $Roles_has_register_new_currency_privilege_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier142"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier143"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier144"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier145"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier146"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier147"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier148"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier149"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier150"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier151"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier152"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier153"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier154"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier155"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_register_new_currency_privilege_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_register_new_currency_privilege_$def(account);
}



procedure {:inline 1} $Roles_has_register_new_currency_privilege(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_register_new_currency_privilege(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_register_new_currency_privilege_$def(account);
}



procedure {:inline 1} $Roles_has_role_$def(account: $Value, role_id: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_role_$def(account: $Value, role_id: $Value) returns ($ret0: $Value)
{
  var addr: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 9969, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(22, 9969, 1, role_id);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(role_id);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t4 := $tmp;
    call $t5 := $Signer_address_of($t4);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 10056, 2, $tmp);
    }

    $tmp := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr);
    $t7 := $tmp;
    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $GetGlobal($Roles_RoleId_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(22, 10134, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $tmp := $GetFieldFromValue($t9, $Roles_RoleId_role_id);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;
    $tmp := $Boolean($IsEqual($t11, $t17));
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 10099, 3, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Boolean(false);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 10099, 3, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(22, 10099, 18, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_role_$direct_inter(account: $Value, role_id: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_role_$direct_inter(account: $Value, role_id: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(role_id);
    call $ret0 := $Roles_has_role_$def(account, role_id);
}



procedure {:inline 1} $Roles_has_role_$direct_intra(account: $Value, role_id: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier156"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier157"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier158"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier159"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier160"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier161"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier162"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier163"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier164"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier165"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier166"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier167"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier168"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier169"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_role_$direct_intra(account: $Value, role_id: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(role_id);
    call $ret0 := $Roles_has_role_$def(account, role_id);
}



procedure {:inline 1} $Roles_has_role(account: $Value, role_id: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_role(account: $Value, role_id: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(role_id);
    call $ret0 := $Roles_has_role_$def(account, role_id);
}



procedure {:inline 1} $Roles_has_treasury_compliance_role_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_treasury_compliance_role_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 10322, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    $tmp := $Integer(1);
    $t2 := $tmp;
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(22, 10412, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_treasury_compliance_role_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_treasury_compliance_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_treasury_compliance_role_$def(account);
}



procedure {:inline 1} $Roles_has_treasury_compliance_role_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier170"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier171"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier172"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier173"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier174"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier175"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier176"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier177"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier178"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier179"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier180"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier181"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier182"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier183"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_treasury_compliance_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_treasury_compliance_role_$def(account);
}



procedure {:inline 1} $Roles_has_treasury_compliance_role(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_treasury_compliance_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_treasury_compliance_role_$def(account);
}



procedure {:inline 1} $Roles_has_update_dual_attestation_limit_privilege_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_update_dual_attestation_limit_privilege_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 11288, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;
    call $t2 := $Roles_has_treasury_compliance_role($t1);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(22, 11394, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_update_dual_attestation_limit_privilege_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_update_dual_attestation_limit_privilege_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_update_dual_attestation_limit_privilege_$def(account);
}



procedure {:inline 1} $Roles_has_update_dual_attestation_limit_privilege_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier184"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier185"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier186"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier187"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier188"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier189"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier190"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier191"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier192"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier193"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier194"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier195"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier196"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier197"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_update_dual_attestation_limit_privilege_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_update_dual_attestation_limit_privilege_$def(account);
}



procedure {:inline 1} $Roles_has_update_dual_attestation_limit_privilege(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_update_dual_attestation_limit_privilege(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_update_dual_attestation_limit_privilege_$def(account);
}



procedure {:inline 1} $Roles_has_validator_operator_role_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_validator_operator_role_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 10742, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    $tmp := $Integer(4);
    $t2 := $tmp;
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(22, 10831, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_validator_operator_role_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_validator_operator_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_validator_operator_role_$def(account);
}



procedure {:inline 1} $Roles_has_validator_operator_role_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier198"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier199"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier200"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier201"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier202"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier203"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier204"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier205"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier206"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier207"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier208"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier209"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier210"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier211"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_validator_operator_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_validator_operator_role_$def(account);
}



procedure {:inline 1} $Roles_has_validator_operator_role(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_validator_operator_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_validator_operator_role_$def(account);
}



procedure {:inline 1} $Roles_has_validator_role_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_validator_role_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 10614, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    $tmp := $Integer(3);
    $t2 := $tmp;
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(22, 10694, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_has_validator_role_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_validator_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_validator_role_$def(account);
}



procedure {:inline 1} $Roles_has_validator_role_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier212"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier213"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier214"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier215"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier216"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier217"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier218"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier219"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier220"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier221"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier222"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier223"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier224"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier225"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_has_validator_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_validator_role_$def(account);
}



procedure {:inline 1} $Roles_has_validator_role(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_has_validator_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_has_validator_role_$def(account);
}



procedure {:inline 1} $Roles_needs_account_limits_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_needs_account_limits_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 12014, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t2 := $tmp;
    call $t3 := $Roles_can_hold_balance($t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $CopyOrMoveValue($t10);
    $t4 := $tmp;
    call $t5 := $Roles_has_designated_dealer_role($t4);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t5);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 12187, 1, $tmp);
    }

    goto L3;

  L2:
    call $tmp := $CopyOrMoveValue($t10);
    $t7 := $tmp;
    $tmp := $Boolean(false);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 12187, 1, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(22, 12187, 11, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Roles_needs_account_limits_$direct_inter(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_needs_account_limits_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_needs_account_limits_$def(account);
}



procedure {:inline 1} $Roles_needs_account_limits_$direct_intra(account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier226"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier227"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier228"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier229"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier230"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier231"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier232"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier233"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier234"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier235"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier236"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier237"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier238"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier239"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_needs_account_limits_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_needs_account_limits_$def(account);
}



procedure {:inline 1} $Roles_needs_account_limits(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Roles_needs_account_limits(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Roles_needs_account_limits_$def(account);
}



procedure {:inline 1} $Roles_new_child_vasp_role_$def(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_child_vasp_role_$def(creating_account: $Value, new_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 8519, 0, creating_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(22, 8519, 1, new_account);
    }

    call $tmp := $CopyOrMoveValue(creating_account);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t6 := $tmp;
    call $t7 := $Roles_has_parent_VASP_role($t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 8648, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t22);
    $t9 := $tmp;
    $tmp := $Integer(3);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 8648, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t22);
    $t11 := $tmp;
    call $t12 := $Signer_address_of($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $t12);
    $t13 := $tmp;
    call $tmp := $Not($t13);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 8799, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t22);
    $t16 := $tmp;
    $tmp := $Integer(4);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 8799, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t22);
    $t18 := $tmp;
    $tmp := $Integer(6);
    $t19 := $tmp;
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t19);
    $t20 := $tmp;
    call $Roles_RoleId_$memory := $MoveTo($Roles_RoleId_$memory, $EmptyTypeValueArray, $t20, $t18);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(22, 8889, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier240"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Roles_new_child_vasp_role_$direct_inter(creating_account: $Value, new_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) || b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account))));
  ensures !$abort_flag ==> b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)), $Roles_RoleId_role_id), $Roles_SPEC_CHILD_VASP_ROLE_ID())));



implementation {:inline 1} $Roles_new_child_vasp_role_$direct_inter(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_child_vasp_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_child_vasp_role_$direct_intra(creating_account: $Value, new_account: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier241"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier242"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier243"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier244"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier245"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier246"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier247"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier248"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier249"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier250"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier251"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier252"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier253"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier254"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_new_child_vasp_role_$direct_intra(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_child_vasp_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_child_vasp_role(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_child_vasp_role(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_child_vasp_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_designated_dealer_role_$def(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_designated_dealer_role_$def(creating_account: $Value, new_account: $Value)
{
  var calling_role: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 4696, 0, creating_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(22, 4696, 1, new_account);
    }

    call $tmp := $CopyOrMoveValue(creating_account);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;
    call $t8 := $Signer_address_of($t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Roles_RoleId_$memory, $t8, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(22, 4851, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    calling_role := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 4836, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t30);
    $t10 := $tmp;
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $t11);
    $t12 := $tmp;
    call $tmp := $Not($t12);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 4993, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t30);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(calling_role);
    $t16 := $tmp;
    $tmp := $Integer(4);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 4993, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue(calling_role);
    $t18 := $tmp;
    call $tmp := $GetFieldFromValue($t18, $Roles_RoleId_role_id);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue($t19);
    $t20 := $tmp;
    $tmp := $Integer(1);
    $t21 := $tmp;
    $tmp := $Boolean($IsEqual($t20, $t21));
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 5083, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t30);
    $t24 := $tmp;
    $tmp := $Integer(3);
    $t25 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 5083, i#$Integer($t25));
    }

    $abort_code := i#$Integer($t25);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t30);
    $t26 := $tmp;
    $tmp := $Integer(2);
    $t27 := $tmp;
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t27);
    $t28 := $tmp;
    call $Roles_RoleId_$memory := $MoveTo($Roles_RoleId_$memory, $EmptyTypeValueArray, $t28, $t26);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(22, 5174, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier255"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Roles_new_designated_dealer_role_$direct_inter(creating_account: $Value, new_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) || b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account))));
  ensures !$abort_flag ==> b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)), $Roles_RoleId_role_id), $Roles_SPEC_DESIGNATED_DEALER_ROLE_ID())));



implementation {:inline 1} $Roles_new_designated_dealer_role_$direct_inter(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_designated_dealer_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_designated_dealer_role_$direct_intra(creating_account: $Value, new_account: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier256"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier257"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier258"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier259"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier260"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier261"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier262"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier263"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier264"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier265"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier266"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier267"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier268"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier269"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_new_designated_dealer_role_$direct_intra(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_designated_dealer_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_designated_dealer_role(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_designated_dealer_role(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_designated_dealer_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_parent_vasp_role_$def(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_parent_vasp_role_$def(creating_account: $Value, new_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 7604, 0, creating_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(22, 7604, 1, new_account);
    }

    call $tmp := $CopyOrMoveValue(creating_account);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t6 := $tmp;
    call $t7 := $Roles_has_libra_root_role($t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 7734, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t22);
    $t9 := $tmp;
    $tmp := $Integer(3);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 7734, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t22);
    $t11 := $tmp;
    call $t12 := $Signer_address_of($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $t12);
    $t13 := $tmp;
    call $tmp := $Not($t13);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 7884, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t22);
    $t16 := $tmp;
    $tmp := $Integer(4);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 7884, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t22);
    $t18 := $tmp;
    $tmp := $Integer(5);
    $t19 := $tmp;
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t19);
    $t20 := $tmp;
    call $Roles_RoleId_$memory := $MoveTo($Roles_RoleId_$memory, $EmptyTypeValueArray, $t20, $t18);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(22, 7974, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier270"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Roles_new_parent_vasp_role_$direct_inter(creating_account: $Value, new_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) || b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account))));
  ensures !$abort_flag ==> b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)), $Roles_RoleId_role_id), $Roles_SPEC_PARENT_VASP_ROLE_ID())));



implementation {:inline 1} $Roles_new_parent_vasp_role_$direct_inter(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_parent_vasp_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_parent_vasp_role_$direct_intra(creating_account: $Value, new_account: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier271"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier272"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier273"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier274"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier275"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier276"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier277"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier278"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier279"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier280"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier281"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier282"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier283"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier284"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_new_parent_vasp_role_$direct_intra(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_parent_vasp_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_parent_vasp_role(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_parent_vasp_role(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_parent_vasp_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_validator_operator_role_$def(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_validator_operator_role_$def(creating_account: $Value, new_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 6654, 0, creating_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(22, 6654, 1, new_account);
    }

    call $tmp := $CopyOrMoveValue(creating_account);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t6 := $tmp;
    call $t7 := $Roles_has_libra_root_role($t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 6791, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t22);
    $t9 := $tmp;
    $tmp := $Integer(3);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 6791, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t22);
    $t11 := $tmp;
    call $t12 := $Signer_address_of($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $t12);
    $t13 := $tmp;
    call $tmp := $Not($t13);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 6941, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t22);
    $t16 := $tmp;
    $tmp := $Integer(4);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 6941, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t22);
    $t18 := $tmp;
    $tmp := $Integer(4);
    $t19 := $tmp;
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t19);
    $t20 := $tmp;
    call $Roles_RoleId_$memory := $MoveTo($Roles_RoleId_$memory, $EmptyTypeValueArray, $t20, $t18);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(22, 7031, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier285"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Roles_new_validator_operator_role_$direct_inter(creating_account: $Value, new_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) || b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account))));
  ensures !$abort_flag ==> b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)), $Roles_RoleId_role_id), $Roles_SPEC_VALIDATOR_OPERATOR_ROLE_ID())));



implementation {:inline 1} $Roles_new_validator_operator_role_$direct_inter(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_validator_operator_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_validator_operator_role_$direct_intra(creating_account: $Value, new_account: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier286"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier287"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier288"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier289"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier290"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier291"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier292"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier293"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier294"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier295"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier296"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier297"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier298"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier299"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_new_validator_operator_role_$direct_intra(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_validator_operator_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_validator_operator_role(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_validator_operator_role(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_validator_operator_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_validator_role_$def(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_validator_role_$def(creating_account: $Value, new_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(22, 5743, 0, creating_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(22, 5743, 1, new_account);
    }

    call $tmp := $CopyOrMoveValue(creating_account);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t6 := $tmp;
    call $t7 := $Roles_has_libra_root_role($t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 5870, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t22);
    $t9 := $tmp;
    $tmp := $Integer(3);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 5870, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t22);
    $t11 := $tmp;
    call $t12 := $Signer_address_of($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $t12);
    $t13 := $tmp;
    call $tmp := $Not($t13);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(22, 6020, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t22);
    $t16 := $tmp;
    $tmp := $Integer(4);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(22, 6020, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t22);
    $t18 := $tmp;
    $tmp := $Integer(3);
    $t19 := $tmp;
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t19);
    $t20 := $tmp;
    call $Roles_RoleId_$memory := $MoveTo($Roles_RoleId_$memory, $EmptyTypeValueArray, $t20, $t18);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(22, 6110, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier300"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Roles_new_validator_role_$direct_inter(creating_account: $Value, new_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(creating_account)))))) || b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account))));
  ensures !$abort_flag ==> b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(new_account)), $Roles_RoleId_role_id), $Roles_SPEC_VALIDATOR_ROLE_ID())));



implementation {:inline 1} $Roles_new_validator_role_$direct_inter(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_validator_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_validator_role_$direct_intra(creating_account: $Value, new_account: $Value);
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier301"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier302"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean($IsEqual(addr, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier303"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier304"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier305"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier306"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier307"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier308"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier309"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier310"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Boolean(!b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier311"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier312"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_needs_account_limits_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier313"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_update_dual_attestation_limit_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr)))))));
  requires b#$Boolean($Boolean((forall addr: $Value :: {:qid "quantifier314"} is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, addr)) ==> b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, addr)))))));



implementation {:inline 1} $Roles_new_validator_role_$direct_intra(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_validator_role_$def(creating_account, new_account);
}



procedure {:inline 1} $Roles_new_validator_role(creating_account: $Value, new_account: $Value);



implementation {:inline 1} $Roles_new_validator_role(creating_account: $Value, new_account: $Value)
{
    assume is#$Address(creating_account);
    assume is#$Address(new_account);
    call $Roles_new_validator_role_$def(creating_account, new_account);
}



function {:inline} $Vector_spec_singleton($tv0: $TypeValue, e: $Value) : $Value
{
  $single_vector(e)
}

function {:inline} $Vector_spec_contains($tv0: $TypeValue, v: $Value, e: $Value) : $Value
{
  $Boolean((var $range_1 := v; (exists $i_0: int :: {:qid "quantifier315"} $InVectorRange($range_1, $i_0) && (var x := $select_vector($range_1, $i_0); b#$Boolean($Boolean($IsEqual(x, e)))))))
}

function {:inline} $Vector_eq_push_back($tv0: $TypeValue, v1: $Value, v2: $Value, e: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(v1), $Integer(i#$Integer($vlen_value(v2)) + i#$Integer($Integer(1)))))) && b#$Boolean($Boolean($IsEqual($select_vector_by_value(v1, $Integer(i#$Integer($vlen_value(v1)) - i#$Integer($Integer(1)))), e))))) && b#$Boolean($Boolean($IsEqual($slice_vector(v1, $Range($Integer(0), $Integer(i#$Integer($vlen_value(v1)) - i#$Integer($Integer(1))))), $slice_vector(v2, $Range($Integer(0), $vlen_value(v2)))))))
}

function {:inline} $Vector_eq_append($tv0: $TypeValue, v: $Value, v1: $Value, v2: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(v), $Integer(i#$Integer($vlen_value(v1)) + i#$Integer($vlen_value(v2)))))) && b#$Boolean($Boolean($IsEqual($slice_vector(v, $Range($Integer(0), $vlen_value(v1))), v1))))) && b#$Boolean($Boolean($IsEqual($slice_vector(v, $Range($vlen_value(v1), $vlen_value(v))), v2))))
}

function {:inline} $Vector_eq_pop_front($tv0: $TypeValue, v1: $Value, v2: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean($IsEqual($Integer(i#$Integer($vlen_value(v1)) + i#$Integer($Integer(1))), $vlen_value(v2)))) && b#$Boolean($Boolean($IsEqual(v1, $slice_vector(v2, $Range($Integer(1), $vlen_value(v2)))))))
}

procedure {:inline 1} $Vector_singleton_$def($tv0: $TypeValue, e: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Vector_singleton_$def($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
  var v: $Value;
  var $t2: $Value;
  var $t3: $Mutation;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(30, 1454, 0, e);
    }

    call $tmp := $CopyOrMoveValue(e);
    $t6 := $tmp;
    call $t2 := $Vector_empty($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t2);
    v := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(30, 1527, 1, $tmp);
    }

    call $t3 := $BorrowLoc(1, v);
    call $tmp := $ReadRef($t3);
    $t7 := $tmp;
    call $t7 := $Vector_push_back($tv0, $t7, $t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t3 := $WriteRef($t3, $t7);
    call v := $WritebackToValue($t3, 1, v);
    $ret0 := v;
    if (true)
    {
        assume $DebugTrackLocal(30, 1578, 8, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Vector_singleton_$direct_inter($tv0: $TypeValue, e: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Vector_spec_singleton($tv0, e))));



implementation {:inline 1} $Vector_singleton_$direct_inter($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Vector_singleton_$def($tv0, e);
}



procedure {:inline 1} $Vector_singleton_$direct_intra($tv0: $TypeValue, e: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Vector_singleton_$direct_intra($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Vector_singleton_$def($tv0, e);
}



procedure {:inline 1} $Vector_singleton($tv0: $TypeValue, e: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Vector_singleton($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Vector_singleton_$def($tv0, e);
}



const unique $Event_EventHandle: $TypeName;

const $Event_EventHandle_counter: $FieldName;

axiom $Event_EventHandle_counter == 0;

const $Event_EventHandle_guid: $FieldName;

axiom $Event_EventHandle_guid == 1;

function $Event_EventHandle_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier316"} { $Event_EventHandle_type_value($tv0): $TypeValue } $Event_EventHandle_type_value($tv0): $TypeValue == $StructType($Event_EventHandle, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $Event_EventHandle_$memory: $Memory;

var $Event_EventHandle_$memory_$old: $Memory;

function {:inline} $Event_EventHandle_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $IsValidU64($SelectField($this, $Event_EventHandle_counter)) && $Vector_is_well_formed($SelectField($this, $Event_EventHandle_guid)) && (forall $$0: int :: {:qid "quantifier317"} { $select_vector($SelectField($this, $Event_EventHandle_guid), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Event_EventHandle_guid)) ==> $IsValidU8($select_vector($SelectField($this, $Event_EventHandle_guid), $$0)))
}

function {:inline} $Event_EventHandle_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $IsValidU64($SelectField($this, $Event_EventHandle_counter)) && $Vector_is_well_formed($SelectField($this, $Event_EventHandle_guid)) && (forall $$0: int :: {:qid "quantifier318"} { $select_vector($SelectField($this, $Event_EventHandle_guid), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Event_EventHandle_guid)) ==> $IsValidU8($select_vector($SelectField($this, $Event_EventHandle_guid), $$0)))
}

procedure {:inline 1} $Event_EventHandle_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, counter: $Value, guid: $Value) returns ($struct: $Value);



implementation {:inline 1} $Event_EventHandle_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, counter: $Value, guid: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(counter);
    assume $Vector_is_well_formed(guid) && (forall $$0: int :: {:qid "quantifier319"} { $select_vector(guid, $$0) } $$0 >= 0 && $$0 < $vlen(guid) ==> $IsValidU8($select_vector(guid, $$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := counter][1 := guid], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Event_EventHandle_unpack($tv0: $TypeValue, $struct: $Value) returns (counter: $Value, guid: $Value);



implementation {:inline 1} $Event_EventHandle_unpack($tv0: $TypeValue, $struct: $Value) returns (counter: $Value, guid: $Value)
{
    assume is#$Vector($struct);
    counter := $SelectField($struct, $Event_EventHandle_counter);
    assume $IsValidU64(counter);
    guid := $SelectField($struct, $Event_EventHandle_guid);
    assume $Vector_is_well_formed(guid) && (forall $$0: int :: {:qid "quantifier320"} { $select_vector(guid, $$0) } $$0 >= 0 && $$0 < $vlen(guid) ==> $IsValidU8($select_vector(guid, $$0)));
}



const unique $Event_EventHandleGenerator: $TypeName;

const $Event_EventHandleGenerator_counter: $FieldName;

axiom $Event_EventHandleGenerator_counter == 0;

const $Event_EventHandleGenerator_addr: $FieldName;

axiom $Event_EventHandleGenerator_addr == 1;

function $Event_EventHandleGenerator_type_value() : $TypeValue;

axiom $Event_EventHandleGenerator_type_value(): $TypeValue == $StructType($Event_EventHandleGenerator, $EmptyTypeValueArray);

var $Event_EventHandleGenerator_$memory: $Memory;

var $Event_EventHandleGenerator_$memory_$old: $Memory;

function {:inline} $Event_EventHandleGenerator_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $IsValidU64($SelectField($this, $Event_EventHandleGenerator_counter)) && is#$Address($SelectField($this, $Event_EventHandleGenerator_addr))
}

function {:inline} $Event_EventHandleGenerator_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $IsValidU64($SelectField($this, $Event_EventHandleGenerator_counter)) && is#$Address($SelectField($this, $Event_EventHandleGenerator_addr))
}

procedure {:inline 1} $Event_EventHandleGenerator_pack($file_id: int, $byte_index: int, $var_idx: int, counter: $Value, addr: $Value) returns ($struct: $Value);



implementation {:inline 1} $Event_EventHandleGenerator_pack($file_id: int, $byte_index: int, $var_idx: int, counter: $Value, addr: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(counter);
    assume is#$Address(addr);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := counter][1 := addr], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Event_EventHandleGenerator_unpack($struct: $Value) returns (counter: $Value, addr: $Value);



implementation {:inline 1} $Event_EventHandleGenerator_unpack($struct: $Value) returns (counter: $Value, addr: $Value)
{
    assume is#$Vector($struct);
    counter := $SelectField($struct, $Event_EventHandleGenerator_counter);
    assume $IsValidU64(counter);
    addr := $SelectField($struct, $Event_EventHandleGenerator_addr);
    assume is#$Address(addr);
}



function {:inline} $AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory: $Memory, addr: $Value) : $Value
{
  $Boolean(b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($SelectField($ResourceValue($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr), $AccountFreezing_FreezingBit_is_frozen)))
}

function {:inline} $AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory: $Memory, addr: $Value) : $Value
{
  $Boolean(b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean(!b#$Boolean($SelectField($ResourceValue($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr), $AccountFreezing_FreezingBit_is_frozen)))))
}

const unique $AccountFreezing_FreezeAccountEvent: $TypeName;

const $AccountFreezing_FreezeAccountEvent_initiator_address: $FieldName;

axiom $AccountFreezing_FreezeAccountEvent_initiator_address == 0;

const $AccountFreezing_FreezeAccountEvent_frozen_address: $FieldName;

axiom $AccountFreezing_FreezeAccountEvent_frozen_address == 1;

function $AccountFreezing_FreezeAccountEvent_type_value() : $TypeValue;

axiom $AccountFreezing_FreezeAccountEvent_type_value(): $TypeValue == $StructType($AccountFreezing_FreezeAccountEvent, $EmptyTypeValueArray);

var $AccountFreezing_FreezeAccountEvent_$memory: $Memory;

var $AccountFreezing_FreezeAccountEvent_$memory_$old: $Memory;

function {:inline} $AccountFreezing_FreezeAccountEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && is#$Address($SelectField($this, $AccountFreezing_FreezeAccountEvent_initiator_address)) && is#$Address($SelectField($this, $AccountFreezing_FreezeAccountEvent_frozen_address))
}

function {:inline} $AccountFreezing_FreezeAccountEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && is#$Address($SelectField($this, $AccountFreezing_FreezeAccountEvent_initiator_address)) && is#$Address($SelectField($this, $AccountFreezing_FreezeAccountEvent_frozen_address))
}

procedure {:inline 1} $AccountFreezing_FreezeAccountEvent_pack($file_id: int, $byte_index: int, $var_idx: int, initiator_address: $Value, frozen_address: $Value) returns ($struct: $Value);



implementation {:inline 1} $AccountFreezing_FreezeAccountEvent_pack($file_id: int, $byte_index: int, $var_idx: int, initiator_address: $Value, frozen_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(initiator_address);
    assume is#$Address(frozen_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := initiator_address][1 := frozen_address], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $AccountFreezing_FreezeAccountEvent_unpack($struct: $Value) returns (initiator_address: $Value, frozen_address: $Value);



implementation {:inline 1} $AccountFreezing_FreezeAccountEvent_unpack($struct: $Value) returns (initiator_address: $Value, frozen_address: $Value)
{
    assume is#$Vector($struct);
    initiator_address := $SelectField($struct, $AccountFreezing_FreezeAccountEvent_initiator_address);
    assume is#$Address(initiator_address);
    frozen_address := $SelectField($struct, $AccountFreezing_FreezeAccountEvent_frozen_address);
    assume is#$Address(frozen_address);
}



const unique $AccountFreezing_FreezeEventsHolder: $TypeName;

const $AccountFreezing_FreezeEventsHolder_freeze_event_handle: $FieldName;

axiom $AccountFreezing_FreezeEventsHolder_freeze_event_handle == 0;

const $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle: $FieldName;

axiom $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle == 1;

function $AccountFreezing_FreezeEventsHolder_type_value() : $TypeValue;

axiom $AccountFreezing_FreezeEventsHolder_type_value(): $TypeValue == $StructType($AccountFreezing_FreezeEventsHolder, $EmptyTypeValueArray);

var $AccountFreezing_FreezeEventsHolder_$memory: $Memory;

var $AccountFreezing_FreezeEventsHolder_$memory_$old: $Memory;

function {:inline} $AccountFreezing_FreezeEventsHolder_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $Event_EventHandle_is_well_formed_types($SelectField($this, $AccountFreezing_FreezeEventsHolder_freeze_event_handle)) && $Event_EventHandle_is_well_formed_types($SelectField($this, $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle))
}

function {:inline} $AccountFreezing_FreezeEventsHolder_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $Event_EventHandle_is_well_formed($SelectField($this, $AccountFreezing_FreezeEventsHolder_freeze_event_handle)) && $Event_EventHandle_is_well_formed($SelectField($this, $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle))
}

procedure {:inline 1} $AccountFreezing_FreezeEventsHolder_pack($file_id: int, $byte_index: int, $var_idx: int, freeze_event_handle: $Value, unfreeze_event_handle: $Value) returns ($struct: $Value);



implementation {:inline 1} $AccountFreezing_FreezeEventsHolder_pack($file_id: int, $byte_index: int, $var_idx: int, freeze_event_handle: $Value, unfreeze_event_handle: $Value) returns ($struct: $Value)
{
    assume $Event_EventHandle_is_well_formed(freeze_event_handle);
    assume $Event_EventHandle_is_well_formed(unfreeze_event_handle);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := freeze_event_handle][1 := unfreeze_event_handle], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $AccountFreezing_FreezeEventsHolder_unpack($struct: $Value) returns (freeze_event_handle: $Value, unfreeze_event_handle: $Value);



implementation {:inline 1} $AccountFreezing_FreezeEventsHolder_unpack($struct: $Value) returns (freeze_event_handle: $Value, unfreeze_event_handle: $Value)
{
    assume is#$Vector($struct);
    freeze_event_handle := $SelectField($struct, $AccountFreezing_FreezeEventsHolder_freeze_event_handle);
    assume $Event_EventHandle_is_well_formed(freeze_event_handle);
    unfreeze_event_handle := $SelectField($struct, $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle);
    assume $Event_EventHandle_is_well_formed(unfreeze_event_handle);
}



const unique $AccountFreezing_FreezingBit: $TypeName;

const $AccountFreezing_FreezingBit_is_frozen: $FieldName;

axiom $AccountFreezing_FreezingBit_is_frozen == 0;

function $AccountFreezing_FreezingBit_type_value() : $TypeValue;

axiom $AccountFreezing_FreezingBit_type_value(): $TypeValue == $StructType($AccountFreezing_FreezingBit, $EmptyTypeValueArray);

var $AccountFreezing_FreezingBit_$memory: $Memory;

var $AccountFreezing_FreezingBit_$memory_$old: $Memory;

function {:inline} $AccountFreezing_FreezingBit_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $AccountFreezing_FreezingBit_is_frozen))
}

function {:inline} $AccountFreezing_FreezingBit_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $AccountFreezing_FreezingBit_is_frozen))
}

procedure {:inline 1} $AccountFreezing_FreezingBit_pack($file_id: int, $byte_index: int, $var_idx: int, is_frozen: $Value) returns ($struct: $Value);



implementation {:inline 1} $AccountFreezing_FreezingBit_pack($file_id: int, $byte_index: int, $var_idx: int, is_frozen: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(is_frozen);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := is_frozen], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $AccountFreezing_FreezingBit_unpack($struct: $Value) returns (is_frozen: $Value);



implementation {:inline 1} $AccountFreezing_FreezingBit_unpack($struct: $Value) returns (is_frozen: $Value)
{
    assume is#$Vector($struct);
    is_frozen := $SelectField($struct, $AccountFreezing_FreezingBit_is_frozen);
    assume is#$Boolean(is_frozen);
}



const unique $AccountFreezing_UnfreezeAccountEvent: $TypeName;

const $AccountFreezing_UnfreezeAccountEvent_initiator_address: $FieldName;

axiom $AccountFreezing_UnfreezeAccountEvent_initiator_address == 0;

const $AccountFreezing_UnfreezeAccountEvent_unfrozen_address: $FieldName;

axiom $AccountFreezing_UnfreezeAccountEvent_unfrozen_address == 1;

function $AccountFreezing_UnfreezeAccountEvent_type_value() : $TypeValue;

axiom $AccountFreezing_UnfreezeAccountEvent_type_value(): $TypeValue == $StructType($AccountFreezing_UnfreezeAccountEvent, $EmptyTypeValueArray);

var $AccountFreezing_UnfreezeAccountEvent_$memory: $Memory;

var $AccountFreezing_UnfreezeAccountEvent_$memory_$old: $Memory;

function {:inline} $AccountFreezing_UnfreezeAccountEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && is#$Address($SelectField($this, $AccountFreezing_UnfreezeAccountEvent_initiator_address)) && is#$Address($SelectField($this, $AccountFreezing_UnfreezeAccountEvent_unfrozen_address))
}

function {:inline} $AccountFreezing_UnfreezeAccountEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && is#$Address($SelectField($this, $AccountFreezing_UnfreezeAccountEvent_initiator_address)) && is#$Address($SelectField($this, $AccountFreezing_UnfreezeAccountEvent_unfrozen_address))
}

procedure {:inline 1} $AccountFreezing_UnfreezeAccountEvent_pack($file_id: int, $byte_index: int, $var_idx: int, initiator_address: $Value, unfrozen_address: $Value) returns ($struct: $Value);



implementation {:inline 1} $AccountFreezing_UnfreezeAccountEvent_pack($file_id: int, $byte_index: int, $var_idx: int, initiator_address: $Value, unfrozen_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(initiator_address);
    assume is#$Address(unfrozen_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := initiator_address][1 := unfrozen_address], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $AccountFreezing_UnfreezeAccountEvent_unpack($struct: $Value) returns (initiator_address: $Value, unfrozen_address: $Value);



implementation {:inline 1} $AccountFreezing_UnfreezeAccountEvent_unpack($struct: $Value) returns (initiator_address: $Value, unfrozen_address: $Value)
{
    assume is#$Vector($struct);
    initiator_address := $SelectField($struct, $AccountFreezing_UnfreezeAccountEvent_initiator_address);
    assume is#$Address(initiator_address);
    unfrozen_address := $SelectField($struct, $AccountFreezing_UnfreezeAccountEvent_unfrozen_address);
    assume is#$Address(unfrozen_address);
}



procedure {:inline 1} $AccountFreezing_initialize_$def(lr_account: $Value);



implementation {:inline 1} $AccountFreezing_initialize_$def(lr_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(2, 1267, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t22 := $tmp;
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 1320, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t22);
    $t7 := $tmp;
    $tmp := $Integer(0);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(2, 1320, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t22);
    $t9 := $tmp;
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 1380, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t22);
    $t14 := $tmp;
    $tmp := $Integer(1);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(2, 1380, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t22);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t17 := $tmp;
    call $t18 := $Event_new_event_handle($AccountFreezing_FreezeAccountEvent_type_value(), $t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t22);
    $t19 := $tmp;
    call $t20 := $Event_new_event_handle($AccountFreezing_UnfreezeAccountEvent_type_value(), $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $AccountFreezing_FreezeEventsHolder_pack(0, 0, 0, $t18, $t20);
    $t21 := $tmp;
    call $AccountFreezing_FreezeEventsHolder_$memory := $MoveTo($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $t21, $t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(2, 1529, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $AccountFreezing_initialize_$direct_inter(lr_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(lr_account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) || b#$Boolean(old($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(lr_account))));
  ensures !$abort_flag ==> b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(lr_account)));



implementation {:inline 1} $AccountFreezing_initialize_$direct_inter(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $AccountFreezing_initialize_$def(lr_account);
}



procedure {:inline 1} $AccountFreezing_initialize_$direct_intra(lr_account: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))));



implementation {:inline 1} $AccountFreezing_initialize_$direct_intra(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $AccountFreezing_initialize_$def(lr_account);
}



procedure {:inline 1} $AccountFreezing_initialize(lr_account: $Value);



implementation {:inline 1} $AccountFreezing_initialize(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $AccountFreezing_initialize_$def(lr_account);
}



procedure {:inline 1} $AccountFreezing_account_is_frozen_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountFreezing_account_is_frozen_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(2, 4923, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t10 := $tmp;
    $tmp := $ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, $t10);
    $t3 := $tmp;
    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $GetGlobal($AccountFreezing_FreezingBit_$memory, $t10, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(2, 5037, $abort_code);
        goto Abort;
    }

    $t5 := $tmp;
    call $tmp := $GetFieldFromValue($t5, $AccountFreezing_FreezingBit_is_frozen);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 5008, 1, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Boolean(false);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 5008, 1, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(2, 5008, 11, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountFreezing_account_is_frozen_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $AccountFreezing_account_is_frozen_$direct_intra(addr: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))));
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, addr))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $AccountFreezing_account_is_frozen(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $AccountFreezing_create_$def(account: $Value);



implementation {:inline 1} $AccountFreezing_create_$def(account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(2, 2084, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    $tmp := $Boolean(false);
    $t2 := $tmp;
    call $tmp := $AccountFreezing_FreezingBit_pack(0, 0, 0, $t2);
    $t3 := $tmp;
    call $AccountFreezing_FreezingBit_$memory := $MoveTo($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, $t3, $t1);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(2, 2130, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $AccountFreezing_create_$direct_inter(account: $Value);
  ensures b#$Boolean(old($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account))));
  ensures !$abort_flag ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $Signer_spec_address_of(account)));



implementation {:inline 1} $AccountFreezing_create_$direct_inter(account: $Value)
{
    assume is#$Address(account);
    call $AccountFreezing_create_$def(account);
}



procedure {:inline 1} $AccountFreezing_create_$direct_intra(account: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))));



implementation {:inline 1} $AccountFreezing_create_$direct_intra(account: $Value)
{
    assume is#$Address(account);
    call $AccountFreezing_create_$def(account);
}



procedure {:inline 1} $AccountFreezing_create(account: $Value);



implementation {:inline 1} $AccountFreezing_create(account: $Value)
{
    assume is#$Address(account);
    call $AccountFreezing_create_$def(account);
}



procedure {:inline 1} $AccountFreezing_freeze_account_$def(account: $Value, frozen_address: $Value);



implementation {:inline 1} $AccountFreezing_freeze_account_$def(account: $Value, frozen_address: $Value)
{
  var initiator_address: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Mutation;
  var $t29: $Mutation;
  var $t30: $Value;
  var $t31: $Mutation;
  var $t32: $Mutation;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(2, 2409, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(2, 2409, 1, frozen_address);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue(frozen_address);
    $t37 := $tmp;
    call $tmp := $CopyOrMoveValue($t36);
    $t9 := $tmp;
    call $t10 := $Roles_has_treasury_compliance_role($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 2556, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t36);
    $t12 := $tmp;
    $tmp := $Integer(2);
    $t13 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(2, 2556, i#$Integer($t13));
    }

    $abort_code := i#$Integer($t13);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t36);
    $t14 := $tmp;
    call $t15 := $Signer_address_of($t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t15);
    initiator_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 2643, 2, $tmp);
    }

    call $t17 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean(!$IsEqual($t37, $t17));
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 2758, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(3);
    $t20 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(2, 2758, i#$Integer($t20));
    }

    $abort_code := i#$Integer($t20);
    goto Abort;

  L2:
    call $t22 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean(!$IsEqual($t37, $t22));
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 2856, 7, $tmp);
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    $tmp := $Integer(4);
    $t25 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(2, 2856, i#$Integer($t25));
    }

    $abort_code := i#$Integer($t25);
    goto Abort;

  L4:
    $tmp := $Boolean(true);
    $t26 := $tmp;
    call $t28 := $BorrowGlobal($AccountFreezing_FreezingBit_$memory, $t37, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(2, 2955, $abort_code);
        goto Abort;
    }

    call $t29 := $BorrowField($t28, $AccountFreezing_FreezingBit_is_frozen);
    call $AccountFreezing_FreezingBit_$memory := $WritebackToGlobal($AccountFreezing_FreezingBit_$memory, $t28);
    call $t29 := $WriteRef($t29, $t26);
    call $AccountFreezing_FreezingBit_$memory := $WritebackToGlobal($AccountFreezing_FreezingBit_$memory, $t29);
    call $t28 := $WritebackToReference($t29, $t28);
    call $t30 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t31 := $BorrowGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t30, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(2, 3084, $abort_code);
        goto Abort;
    }

    call $t32 := $BorrowField($t31, $AccountFreezing_FreezeEventsHolder_freeze_event_handle);
    call $AccountFreezing_FreezeEventsHolder_$memory := $WritebackToGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t31);
    call $tmp := $AccountFreezing_FreezeAccountEvent_pack(0, 0, 0, initiator_address, $t37);
    $t35 := $tmp;
    call $tmp := $ReadRef($t32);
    $t38 := $tmp;
    call $t38 := $Event_emit_event($AccountFreezing_FreezeAccountEvent_type_value(), $t38, $t35);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t32 := $WriteRef($t32, $t38);
    call $AccountFreezing_FreezeEventsHolder_$memory := $WritebackToGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t32);
    call $t31 := $WritebackToReference($t32, $t31);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $AccountFreezing_freeze_account_$direct_inter(account: $Value, frozen_address: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean($IsEqual(frozen_address, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean($IsEqual(frozen_address, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, frozen_address))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(account)))))) || b#$Boolean(old($Boolean($IsEqual(frozen_address, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) || b#$Boolean(old($Boolean($IsEqual(frozen_address, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS())))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, frozen_address))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))));
  ensures !$abort_flag ==> b#$Boolean($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, frozen_address));



implementation {:inline 1} $AccountFreezing_freeze_account_$direct_inter(account: $Value, frozen_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(frozen_address);
    call $AccountFreezing_freeze_account_$def(account, frozen_address);
}



procedure {:inline 1} $AccountFreezing_freeze_account_$direct_intra(account: $Value, frozen_address: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))));



implementation {:inline 1} $AccountFreezing_freeze_account_$direct_intra(account: $Value, frozen_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(frozen_address);
    call $AccountFreezing_freeze_account_$def(account, frozen_address);
}



procedure {:inline 1} $AccountFreezing_freeze_account(account: $Value, frozen_address: $Value);



implementation {:inline 1} $AccountFreezing_freeze_account(account: $Value, frozen_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(frozen_address);
    call $AccountFreezing_freeze_account_$def(account, frozen_address);
}



procedure {:inline 1} $AccountFreezing_unfreeze_account_$def(account: $Value, unfrozen_address: $Value);



implementation {:inline 1} $AccountFreezing_unfreeze_account_$def(account: $Value, unfrozen_address: $Value)
{
  var initiator_address: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(2, 3858, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(2, 3858, 1, unfrozen_address);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue(unfrozen_address);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 4009, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t22);
    $t8 := $tmp;
    $tmp := $Integer(5);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(2, 4009, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t22);
    $t10 := $tmp;
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    initiator_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(2, 4098, 2, $tmp);
    }

    $tmp := $Boolean(false);
    $t12 := $tmp;
    call $t14 := $BorrowGlobal($AccountFreezing_FreezingBit_$memory, $t23, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(2, 4155, $abort_code);
        goto Abort;
    }

    call $t15 := $BorrowField($t14, $AccountFreezing_FreezingBit_is_frozen);
    call $AccountFreezing_FreezingBit_$memory := $WritebackToGlobal($AccountFreezing_FreezingBit_$memory, $t14);
    call $t15 := $WriteRef($t15, $t12);
    call $AccountFreezing_FreezingBit_$memory := $WritebackToGlobal($AccountFreezing_FreezingBit_$memory, $t15);
    call $t14 := $WritebackToReference($t15, $t14);
    call $t16 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t17 := $BorrowGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t16, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(2, 4289, $abort_code);
        goto Abort;
    }

    call $t18 := $BorrowField($t17, $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle);
    call $AccountFreezing_FreezeEventsHolder_$memory := $WritebackToGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t17);
    call $tmp := $AccountFreezing_UnfreezeAccountEvent_pack(0, 0, 0, initiator_address, $t23);
    $t21 := $tmp;
    call $tmp := $ReadRef($t18);
    $t24 := $tmp;
    call $t24 := $Event_emit_event($AccountFreezing_UnfreezeAccountEvent_type_value(), $t24, $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t18 := $WriteRef($t18, $t24);
    call $AccountFreezing_FreezeEventsHolder_$memory := $WritebackToGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t18);
    call $t17 := $WritebackToReference($t18, $t17);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $AccountFreezing_unfreeze_account_$direct_inter(account: $Value, unfrozen_address: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, unfrozen_address))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(account)))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, unfrozen_address))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(!b#$Boolean($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, unfrozen_address))));



implementation {:inline 1} $AccountFreezing_unfreeze_account_$direct_inter(account: $Value, unfrozen_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(unfrozen_address);
    call $AccountFreezing_unfreeze_account_$def(account, unfrozen_address);
}



procedure {:inline 1} $AccountFreezing_unfreeze_account_$direct_intra(account: $Value, unfrozen_address: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS()))));



implementation {:inline 1} $AccountFreezing_unfreeze_account_$direct_intra(account: $Value, unfrozen_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(unfrozen_address);
    call $AccountFreezing_unfreeze_account_$def(account, unfrozen_address);
}



procedure {:inline 1} $AccountFreezing_unfreeze_account(account: $Value, unfrozen_address: $Value);



implementation {:inline 1} $AccountFreezing_unfreeze_account(account: $Value, unfrozen_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(unfrozen_address);
    call $AccountFreezing_unfreeze_account_$def(account, unfrozen_address);
}



function {:inline} $AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $AccountLimits_Window_$memory: $Memory, $tv0: $TypeValue, amount: $Value, addr: $Value) : $Value
{
  $AccountLimits_spec_receiving_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), amount)
}

function {:inline} $AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $AccountLimits_Window_$memory: $Memory, $tv0: $TypeValue, amount: $Value, addr: $Value) : $Value
{
  $AccountLimits_spec_withdrawal_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), amount)
}

function {:inline} $AccountLimits_spec_window_expired($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $tv0: $TypeValue, window: $Value, limits_definition: $Value) : $Value
{
  $Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))))
}

function {:inline} $AccountLimits_spec_window_reset_with_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $tv0: $TypeValue, window: $Value, limits_definition: $Value) : $Value
{
  (if b#$Boolean($AccountLimits_spec_window_expired($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0, window, limits_definition)) then $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)), $Integer(0)), $Integer(0)), $SelectField(window, $AccountLimits_Window_tracked_balance)), $SelectField(window, $AccountLimits_Window_limit_address))) else window)
}

function {:inline} $AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, window: $Value) : $Value
{
  $ResourceValue($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(window, $AccountLimits_Window_limit_address))
}

function {:inline} $AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, window: $Value) : $Value
{
  $AccountLimits_spec_is_unrestricted($tv0, $AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, window))
}

function {:inline} $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, window: $Value) : $Value
{
  $AccountLimits_spec_window_reset_with_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0, window, $AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, window))
}

function {:inline} $AccountLimits_spec_receiving_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, receiving: $Value, amount: $Value) : $Value
{
  $Boolean(b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)) || b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) <= i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_max_inflow)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) <= i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_max_holding)))))))
}

function {:inline} $AccountLimits_spec_withdrawal_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, sending: $Value, amount: $Value) : $Value
{
  $Boolean(b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)) || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) <= i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_LimitsDefinition_max_outflow)))))
}

function {:inline} $AccountLimits_spec_is_unrestricted($tv0: $TypeValue, limits_def: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($SelectField(limits_def, $AccountLimits_LimitsDefinition_max_inflow), $Integer($MAX_U64)))) && b#$Boolean($Boolean($IsEqual($SelectField(limits_def, $AccountLimits_LimitsDefinition_max_outflow), $Integer($MAX_U64)))))) && b#$Boolean($Boolean($IsEqual($SelectField(limits_def, $AccountLimits_LimitsDefinition_max_holding), $Integer($MAX_U64)))))) && b#$Boolean($Boolean($IsEqual($SelectField(limits_def, $AccountLimits_LimitsDefinition_time_period), $Integer(86400000000)))))
}

function {:inline} $AccountLimits_spec_has_window_published($AccountLimits_Window_$memory: $Memory, $tv0: $TypeValue, addr: $Value) : $Value
{
  $ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)
}

const unique $AccountLimits_AccountLimitMutationCapability: $TypeName;

const $AccountLimits_AccountLimitMutationCapability_dummy_field: $FieldName;

axiom $AccountLimits_AccountLimitMutationCapability_dummy_field == 0;

function $AccountLimits_AccountLimitMutationCapability_type_value() : $TypeValue;

axiom $AccountLimits_AccountLimitMutationCapability_type_value(): $TypeValue == $StructType($AccountLimits_AccountLimitMutationCapability, $EmptyTypeValueArray);

var $AccountLimits_AccountLimitMutationCapability_$memory: $Memory;

var $AccountLimits_AccountLimitMutationCapability_$memory_$old: $Memory;

function {:inline} $AccountLimits_AccountLimitMutationCapability_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $AccountLimits_AccountLimitMutationCapability_dummy_field))
}

function {:inline} $AccountLimits_AccountLimitMutationCapability_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $AccountLimits_AccountLimitMutationCapability_dummy_field))
}

procedure {:inline 1} $AccountLimits_AccountLimitMutationCapability_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $AccountLimits_AccountLimitMutationCapability_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $AccountLimits_AccountLimitMutationCapability_unpack($struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $AccountLimits_AccountLimitMutationCapability_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $AccountLimits_AccountLimitMutationCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}



const unique $AccountLimits_LimitsDefinition: $TypeName;

const $AccountLimits_LimitsDefinition_max_inflow: $FieldName;

axiom $AccountLimits_LimitsDefinition_max_inflow == 0;

const $AccountLimits_LimitsDefinition_max_outflow: $FieldName;

axiom $AccountLimits_LimitsDefinition_max_outflow == 1;

const $AccountLimits_LimitsDefinition_time_period: $FieldName;

axiom $AccountLimits_LimitsDefinition_time_period == 2;

const $AccountLimits_LimitsDefinition_max_holding: $FieldName;

axiom $AccountLimits_LimitsDefinition_max_holding == 3;

function $AccountLimits_LimitsDefinition_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier321"} { $AccountLimits_LimitsDefinition_type_value($tv0): $TypeValue } $AccountLimits_LimitsDefinition_type_value($tv0): $TypeValue == $StructType($AccountLimits_LimitsDefinition, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $AccountLimits_LimitsDefinition_$memory: $Memory;

var $AccountLimits_LimitsDefinition_$memory_$old: $Memory;

function {:inline} $AccountLimits_LimitsDefinition_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 4 && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_inflow)) && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_outflow)) && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_time_period)) && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_holding))
}

function {:inline} $AccountLimits_LimitsDefinition_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 4 && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_inflow)) && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_outflow)) && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_time_period)) && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_holding)) && b#$Boolean($Boolean(i#$Integer($SelectField($this, $AccountLimits_LimitsDefinition_max_inflow)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($SelectField($this, $AccountLimits_LimitsDefinition_max_outflow)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($SelectField($this, $AccountLimits_LimitsDefinition_time_period)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($SelectField($this, $AccountLimits_LimitsDefinition_max_holding)) > i#$Integer($Integer(0))))
}

procedure {:inline 1} $AccountLimits_LimitsDefinition_before_update_inv($tv0: $TypeValue, $before: $Value);



implementation {:inline 1} $AccountLimits_LimitsDefinition_before_update_inv($tv0: $TypeValue, $before: $Value)
{
    assume b#$Boolean($Boolean(i#$Integer($SelectField($before, $AccountLimits_LimitsDefinition_max_inflow)) > i#$Integer($Integer(0))));
    assume b#$Boolean($Boolean(i#$Integer($SelectField($before, $AccountLimits_LimitsDefinition_max_outflow)) > i#$Integer($Integer(0))));
    assume b#$Boolean($Boolean(i#$Integer($SelectField($before, $AccountLimits_LimitsDefinition_time_period)) > i#$Integer($Integer(0))));
    assume b#$Boolean($Boolean(i#$Integer($SelectField($before, $AccountLimits_LimitsDefinition_max_holding)) > i#$Integer($Integer(0))));
}



procedure {:inline 1} $AccountLimits_LimitsDefinition_after_update_inv($tv0: $TypeValue, $after: $Value);



implementation {:inline 1} $AccountLimits_LimitsDefinition_after_update_inv($tv0: $TypeValue, $after: $Value)
{
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_max_inflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_max_outflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_time_period)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_max_holding)) > i#$Integer($Integer(0))));
}



procedure {:inline 1} $AccountLimits_LimitsDefinition_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, max_inflow: $Value, max_outflow: $Value, time_period: $Value, max_holding: $Value) returns ($struct: $Value);



implementation {:inline 1} $AccountLimits_LimitsDefinition_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, max_inflow: $Value, max_outflow: $Value, time_period: $Value, max_holding: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(max_inflow);
    assume $IsValidU64(max_outflow);
    assume $IsValidU64(time_period);
    assume $IsValidU64(max_holding);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := max_inflow][1 := max_outflow][2 := time_period][3 := max_holding], 4));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }

    assert b#$Boolean($Boolean(i#$Integer($SelectField($struct, $AccountLimits_LimitsDefinition_max_inflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($struct, $AccountLimits_LimitsDefinition_max_outflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($struct, $AccountLimits_LimitsDefinition_time_period)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($struct, $AccountLimits_LimitsDefinition_max_holding)) > i#$Integer($Integer(0))));
}



procedure {:inline 1} $AccountLimits_LimitsDefinition_unpack($tv0: $TypeValue, $struct: $Value) returns (max_inflow: $Value, max_outflow: $Value, time_period: $Value, max_holding: $Value);



implementation {:inline 1} $AccountLimits_LimitsDefinition_unpack($tv0: $TypeValue, $struct: $Value) returns (max_inflow: $Value, max_outflow: $Value, time_period: $Value, max_holding: $Value)
{
    assume is#$Vector($struct);
    max_inflow := $SelectField($struct, $AccountLimits_LimitsDefinition_max_inflow);
    assume $IsValidU64(max_inflow);
    max_outflow := $SelectField($struct, $AccountLimits_LimitsDefinition_max_outflow);
    assume $IsValidU64(max_outflow);
    time_period := $SelectField($struct, $AccountLimits_LimitsDefinition_time_period);
    assume $IsValidU64(time_period);
    max_holding := $SelectField($struct, $AccountLimits_LimitsDefinition_max_holding);
    assume $IsValidU64(max_holding);
}



const unique $AccountLimits_Window: $TypeName;

const $AccountLimits_Window_window_start: $FieldName;

axiom $AccountLimits_Window_window_start == 0;

const $AccountLimits_Window_window_inflow: $FieldName;

axiom $AccountLimits_Window_window_inflow == 1;

const $AccountLimits_Window_window_outflow: $FieldName;

axiom $AccountLimits_Window_window_outflow == 2;

const $AccountLimits_Window_tracked_balance: $FieldName;

axiom $AccountLimits_Window_tracked_balance == 3;

const $AccountLimits_Window_limit_address: $FieldName;

axiom $AccountLimits_Window_limit_address == 4;

function $AccountLimits_Window_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier322"} { $AccountLimits_Window_type_value($tv0): $TypeValue } $AccountLimits_Window_type_value($tv0): $TypeValue == $StructType($AccountLimits_Window, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $AccountLimits_Window_$memory: $Memory;

var $AccountLimits_Window_$memory_$old: $Memory;

function {:inline} $AccountLimits_Window_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 5 && $IsValidU64($SelectField($this, $AccountLimits_Window_window_start)) && $IsValidU64($SelectField($this, $AccountLimits_Window_window_inflow)) && $IsValidU64($SelectField($this, $AccountLimits_Window_window_outflow)) && $IsValidU64($SelectField($this, $AccountLimits_Window_tracked_balance)) && is#$Address($SelectField($this, $AccountLimits_Window_limit_address))
}

function {:inline} $AccountLimits_Window_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 5 && $IsValidU64($SelectField($this, $AccountLimits_Window_window_start)) && $IsValidU64($SelectField($this, $AccountLimits_Window_window_inflow)) && $IsValidU64($SelectField($this, $AccountLimits_Window_window_outflow)) && $IsValidU64($SelectField($this, $AccountLimits_Window_tracked_balance)) && is#$Address($SelectField($this, $AccountLimits_Window_limit_address))
}

procedure {:inline 1} $AccountLimits_Window_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, window_start: $Value, window_inflow: $Value, window_outflow: $Value, tracked_balance: $Value, limit_address: $Value) returns ($struct: $Value);



implementation {:inline 1} $AccountLimits_Window_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, window_start: $Value, window_inflow: $Value, window_outflow: $Value, tracked_balance: $Value, limit_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(window_start);
    assume $IsValidU64(window_inflow);
    assume $IsValidU64(window_outflow);
    assume $IsValidU64(tracked_balance);
    assume is#$Address(limit_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := window_start][1 := window_inflow][2 := window_outflow][3 := tracked_balance][4 := limit_address], 5));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $AccountLimits_Window_unpack($tv0: $TypeValue, $struct: $Value) returns (window_start: $Value, window_inflow: $Value, window_outflow: $Value, tracked_balance: $Value, limit_address: $Value);



implementation {:inline 1} $AccountLimits_Window_unpack($tv0: $TypeValue, $struct: $Value) returns (window_start: $Value, window_inflow: $Value, window_outflow: $Value, tracked_balance: $Value, limit_address: $Value)
{
    assume is#$Vector($struct);
    window_start := $SelectField($struct, $AccountLimits_Window_window_start);
    assume $IsValidU64(window_start);
    window_inflow := $SelectField($struct, $AccountLimits_Window_window_inflow);
    assume $IsValidU64(window_inflow);
    window_outflow := $SelectField($struct, $AccountLimits_Window_window_outflow);
    assume $IsValidU64(window_outflow);
    tracked_balance := $SelectField($struct, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64(tracked_balance);
    limit_address := $SelectField($struct, $AccountLimits_Window_limit_address);
    assume is#$Address(limit_address);
}



procedure {:inline 1} $AccountLimits_can_receive_$def($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $AccountLimits_can_receive_$def($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var holding_ok: $Value;
  var inflow_ok: $Value;
  var limits_definition: $Mutation;
  var $t5: $Mutation;
  var $t6: $Mutation;
  var $t7: $Mutation;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Mutation;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $t19: $Mutation;
  var $t20: $Mutation;
  var $t21: $Value;
  var $t22: $Mutation;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Mutation;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Mutation;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Mutation;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Mutation;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Mutation;
  var $t49: $Mutation;
  var $t50: $Mutation;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Mutation;
  var $t56: $Mutation;
  var $t57: $Mutation;
  var $t58: $Value;
  var $t59: $Value;
  var $t60: $Value;
  var $t61: $Value;
  var $t62: $Value;
  var $t63: $Mutation;
  var $t64: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 11947, 0, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 11947, 1, receiving);
    }

    call $tmp := $CopyOrMoveValue(amount);
    $t61 := $tmp;
    call $tmp := $CopyOrMoveValue(receiving);
    $t62 := $tmp;
    call $t63 := $BorrowLoc(62, $t62);
    call $t7 := $CopyOrMoveRef($t63);
    call $tmp := $GetFieldFromReference($t7, $AccountLimits_Window_limit_address);
    $t8 := $tmp;
    call $t63 := $WritebackToReference($t7, $t63);
    call $tmp := $CopyOrMoveValue($t8);
    $t9 := $tmp;
    call $t10 := $BorrowGlobal($AccountLimits_LimitsDefinition_$memory, $t9, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 12109, $abort_code);
        goto Abort;
    }

    call $AccountLimits_LimitsDefinition_before_update_inv($tv0, $Dereference($t10));
    call limits_definition := $CopyOrMoveRef($t10);
    if (true)
    {
        assume $DebugTrackLocal(3, 12089, 4, $Dereference(limits_definition));
    }

    call $t11 := $CopyOrMoveRef(limits_definition);
    call $tmp := $ReadRef($t11);
    $t12 := $tmp;
    call limits_definition := $WritebackToReference($t11, limits_definition);
    call $t13 := $AccountLimits_is_unrestricted($tv0, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t13;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t14 := $CopyOrMoveRef($t63);
    call $t62 := $WritebackToValue($t14, 62, $t62);
    call $t15 := $CopyOrMoveRef(limits_definition);
    call $AccountLimits_LimitsDefinition_$memory := $WritebackToGlobal($AccountLimits_LimitsDefinition_$memory, $t15);
    call $AccountLimits_LimitsDefinition_after_update_inv($tv0, $Dereference($t15));
    $tmp := $Boolean(true);
    $t16 := $tmp;
    $ret0 := $t16;
    if (true)
    {
        assume $DebugTrackLocal(3, 12300, 65, $ret0);
    }

    $ret1 := $t62;
    if (true)
    {
        assume $DebugTrackLocal(3, 12300, 66, $ret1);
    }

    return;

  L2:
    call $t17 := $CopyOrMoveRef($t63);
    call $t18 := $CopyOrMoveRef(limits_definition);
    call $t6 := $CopyOrMoveRef($t18);
    if (true)
    {
        assume $DebugTrackLocal(3, 12334, 6, $Dereference($t6));
    }

    call $t5 := $CopyOrMoveRef($t17);
    if (true)
    {
        assume $DebugTrackLocal(3, 12334, 5, $Dereference($t5));
    }

    call $t19 := $CopyOrMoveRef($t5);
    call $t20 := $CopyOrMoveRef($t6);
    call $tmp := $ReadRef($t20);
    $t21 := $tmp;
    call limits_definition := $WritebackToReference($t20, limits_definition);
    call $tmp := $ReadRef($t19);
    $t64 := $tmp;
    call $t64 := $AccountLimits_reset_window($tv0, $t64, $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $WriteRef($t19, $t64);
    if (true)
    {
        assume $DebugTrackLocal(3, 13065, 4, $Dereference(limits_definition));
    }

    call $t63 := $WritebackToReference($t19, $t63);
    call $t22 := $CopyOrMoveRef($t63);
    call $tmp := $GetFieldFromReference($t22, $AccountLimits_Window_window_inflow);
    $t23 := $tmp;
    call $t63 := $WritebackToReference($t22, $t63);
    call $tmp := $CopyOrMoveValue($t23);
    $t24 := $tmp;
    call $tmp := $AddU64($t24, $t61);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 12567, $abort_code);
        goto Abort;
    }

    $t26 := $tmp;
    call $t27 := $CopyOrMoveRef(limits_definition);
    call $tmp := $GetFieldFromReference($t27, $AccountLimits_LimitsDefinition_max_inflow);
    $t28 := $tmp;
    call limits_definition := $WritebackToReference($t27, limits_definition);
    call $tmp := $CopyOrMoveValue($t28);
    $t29 := $tmp;
    call $tmp := $Le($t26, $t29);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue($t30);
    inflow_ok := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 12531, 3, $tmp);
    }

    call $t31 := $CopyOrMoveRef($t63);
    call $tmp := $GetFieldFromReference($t31, $AccountLimits_Window_tracked_balance);
    $t32 := $tmp;
    call $t63 := $WritebackToReference($t31, $t63);
    call $tmp := $CopyOrMoveValue($t32);
    $t33 := $tmp;
    call $tmp := $AddU64($t33, $t61);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 12718, $abort_code);
        goto Abort;
    }

    $t35 := $tmp;
    call $t36 := $CopyOrMoveRef(limits_definition);
    call $tmp := $GetFieldFromReference($t36, $AccountLimits_LimitsDefinition_max_holding);
    $t37 := $tmp;
    call $AccountLimits_LimitsDefinition_$memory := $WritebackToGlobal($AccountLimits_LimitsDefinition_$memory, $t36);
    call $AccountLimits_LimitsDefinition_after_update_inv($tv0, $Dereference($t36));
    call $tmp := $CopyOrMoveValue($t37);
    $t38 := $tmp;
    call $tmp := $Le($t35, $t38);
    $t39 := $tmp;
    call $tmp := $CopyOrMoveValue($t39);
    holding_ok := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 12679, 2, $tmp);
    }

    call $tmp := $And(inflow_ok, holding_ok);
    $t42 := $tmp;
    $tmp := $t42;
    if (b#$Boolean($tmp))
    {
        goto L3;
    }
    else
    {
        goto L4;
    }

  L4:
    goto L5;

  L3:
    call $t43 := $CopyOrMoveRef($t63);
    call $tmp := $GetFieldFromReference($t43, $AccountLimits_Window_window_inflow);
    $t44 := $tmp;
    call $t63 := $WritebackToReference($t43, $t63);
    call $tmp := $CopyOrMoveValue($t44);
    $t45 := $tmp;
    call $tmp := $AddU64($t45, $t61);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 12947, $abort_code);
        goto Abort;
    }

    $t47 := $tmp;
    call $t48 := $CopyOrMoveRef($t63);
    call $t49 := $BorrowField($t48, $AccountLimits_Window_window_inflow);
    call $t63 := $WritebackToReference($t48, $t63);
    call $t49 := $WriteRef($t49, $t47);
    if (true)
    {
        assume $DebugTrackLocal(3, 12897, 4, $Dereference(limits_definition));
    }

    call $t63 := $WritebackToReference($t49, $t63);
    call $t48 := $WritebackToReference($t49, $t48);
    call $t50 := $CopyOrMoveRef($t63);
    call $tmp := $GetFieldFromReference($t50, $AccountLimits_Window_tracked_balance);
    $t51 := $tmp;
    call $t63 := $WritebackToReference($t50, $t63);
    call $tmp := $CopyOrMoveValue($t51);
    $t52 := $tmp;
    call $tmp := $AddU64($t52, $t61);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 13023, $abort_code);
        goto Abort;
    }

    $t54 := $tmp;
    call $t55 := $CopyOrMoveRef($t63);
    call $t56 := $BorrowField($t55, $AccountLimits_Window_tracked_balance);
    call $t62 := $WritebackToValue($t55, 62, $t62);
    call $t56 := $WriteRef($t56, $t54);
    if (true)
    {
        assume $DebugTrackLocal(3, 12969, 4, $Dereference(limits_definition));
    }

    call $t62 := $WritebackToValue($t56, 62, $t62);
    call $t55 := $WritebackToReference($t56, $t55);
    goto L6;

  L5:
    call $t57 := $CopyOrMoveRef($t63);
    call $t62 := $WritebackToValue($t57, 62, $t62);
    goto L6;

  L6:
    call $tmp := $And(inflow_ok, holding_ok);
    $t60 := $tmp;
    $ret0 := $t60;
    if (true)
    {
        assume $DebugTrackLocal(3, 13052, 65, $ret0);
    }

    $ret1 := $t62;
    if (true)
    {
        assume $DebugTrackLocal(3, 13052, 66, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_can_receive_$direct_intra($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $AccountLimits_can_receive_$direct_intra($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $IsValidU64(amount);
    assume $AccountLimits_Window_is_well_formed(receiving);
    call $ret0, $ret1 := $AccountLimits_can_receive_$def($tv0, amount, receiving);
}



procedure {:inline 1} $AccountLimits_can_receive($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $AccountLimits_can_receive($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $IsValidU64(amount);
    assume $AccountLimits_Window_is_well_formed(receiving);
    call $ret0, $ret1 := $AccountLimits_can_receive_$def($tv0, amount, receiving);
}



procedure {:inline 1} $AccountLimits_can_withdraw_$def($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $AccountLimits_can_withdraw_$def($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var limits_definition: $Mutation;
  var outflow_ok: $Value;
  var $t4: $Mutation;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Mutation;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Mutation;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $t19: $Mutation;
  var $t20: $Mutation;
  var $t21: $Value;
  var $t22: $Mutation;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Mutation;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Mutation;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Mutation;
  var $t38: $Mutation;
  var $t39: $Value;
  var $t40: $Mutation;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Mutation;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Mutation;
  var $t52: $Mutation;
  var $t53: $Mutation;
  var $t54: $Value;
  var $t55: $Value;
  var $t56: $Value;
  var $t57: $Mutation;
  var $t58: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 15548, 0, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 15548, 1, sending);
    }

    call $tmp := $CopyOrMoveValue(amount);
    $t55 := $tmp;
    call $tmp := $CopyOrMoveValue(sending);
    $t56 := $tmp;
    call $t57 := $BorrowLoc(56, $t56);
    call $t7 := $CopyOrMoveRef($t57);
    call $tmp := $GetFieldFromReference($t7, $AccountLimits_Window_limit_address);
    $t8 := $tmp;
    call $t57 := $WritebackToReference($t7, $t57);
    call $tmp := $CopyOrMoveValue($t8);
    $t9 := $tmp;
    call $t10 := $BorrowGlobal($AccountLimits_LimitsDefinition_$memory, $t9, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 15709, $abort_code);
        goto Abort;
    }

    call $AccountLimits_LimitsDefinition_before_update_inv($tv0, $Dereference($t10));
    call limits_definition := $CopyOrMoveRef($t10);
    if (true)
    {
        assume $DebugTrackLocal(3, 15689, 2, $Dereference(limits_definition));
    }

    call $t11 := $CopyOrMoveRef(limits_definition);
    call $tmp := $ReadRef($t11);
    $t12 := $tmp;
    call limits_definition := $WritebackToReference($t11, limits_definition);
    call $t13 := $AccountLimits_is_unrestricted($tv0, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t13;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t14 := $CopyOrMoveRef($t57);
    call $t56 := $WritebackToValue($t14, 56, $t56);
    call $t15 := $CopyOrMoveRef(limits_definition);
    call $AccountLimits_LimitsDefinition_$memory := $WritebackToGlobal($AccountLimits_LimitsDefinition_$memory, $t15);
    call $AccountLimits_LimitsDefinition_after_update_inv($tv0, $Dereference($t15));
    $tmp := $Boolean(true);
    $t16 := $tmp;
    $ret0 := $t16;
    if (true)
    {
        assume $DebugTrackLocal(3, 15898, 59, $ret0);
    }

    $ret1 := $t56;
    if (true)
    {
        assume $DebugTrackLocal(3, 15898, 60, $ret1);
    }

    return;

  L2:
    call $t17 := $CopyOrMoveRef($t57);
    call $t18 := $CopyOrMoveRef(limits_definition);
    call $t5 := $CopyOrMoveRef($t18);
    if (true)
    {
        assume $DebugTrackLocal(3, 15932, 5, $Dereference($t5));
    }

    call $t4 := $CopyOrMoveRef($t17);
    if (true)
    {
        assume $DebugTrackLocal(3, 15932, 4, $Dereference($t4));
    }

    call $t19 := $CopyOrMoveRef($t4);
    call $t20 := $CopyOrMoveRef($t5);
    call $tmp := $ReadRef($t20);
    $t21 := $tmp;
    call limits_definition := $WritebackToReference($t20, limits_definition);
    call $tmp := $ReadRef($t19);
    $t58 := $tmp;
    call $t58 := $AccountLimits_reset_window($tv0, $t58, $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $WriteRef($t19, $t58);
    if (true)
    {
        assume $DebugTrackLocal(3, 16393, 2, $Dereference(limits_definition));
    }

    call $t57 := $WritebackToReference($t19, $t57);
    call $t22 := $CopyOrMoveRef($t57);
    call $tmp := $GetFieldFromReference($t22, $AccountLimits_Window_window_outflow);
    $t23 := $tmp;
    call $t57 := $WritebackToReference($t22, $t57);
    call $tmp := $CopyOrMoveValue($t23);
    $t24 := $tmp;
    call $tmp := $AddU64($t24, $t55);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 16041, $abort_code);
        goto Abort;
    }

    $t26 := $tmp;
    call $t27 := $CopyOrMoveRef(limits_definition);
    call $tmp := $GetFieldFromReference($t27, $AccountLimits_LimitsDefinition_max_outflow);
    $t28 := $tmp;
    call $AccountLimits_LimitsDefinition_$memory := $WritebackToGlobal($AccountLimits_LimitsDefinition_$memory, $t27);
    call $AccountLimits_LimitsDefinition_after_update_inv($tv0, $Dereference($t27));
    call $tmp := $CopyOrMoveValue($t28);
    $t29 := $tmp;
    call $tmp := $Le($t26, $t29);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue($t30);
    outflow_ok := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 16005, 3, $tmp);
    }

    $tmp := outflow_ok;
    if (b#$Boolean($tmp))
    {
        goto L3;
    }
    else
    {
        goto L4;
    }

  L4:
    goto L5;

  L3:
    call $t32 := $CopyOrMoveRef($t57);
    call $tmp := $GetFieldFromReference($t32, $AccountLimits_Window_window_outflow);
    $t33 := $tmp;
    call $t57 := $WritebackToReference($t32, $t57);
    call $tmp := $CopyOrMoveValue($t33);
    $t34 := $tmp;
    call $tmp := $AddU64($t34, $t55);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 16207, $abort_code);
        goto Abort;
    }

    $t36 := $tmp;
    call $t37 := $CopyOrMoveRef($t57);
    call $t38 := $BorrowField($t37, $AccountLimits_Window_window_outflow);
    call $t57 := $WritebackToReference($t37, $t57);
    call $t38 := $WriteRef($t38, $t36);
    if (true)
    {
        assume $DebugTrackLocal(3, 16159, 2, $Dereference(limits_definition));
    }

    call $t57 := $WritebackToReference($t38, $t57);
    call $t37 := $WritebackToReference($t38, $t37);
    call $t40 := $CopyOrMoveRef($t57);
    call $tmp := $GetFieldFromReference($t40, $AccountLimits_Window_tracked_balance);
    $t41 := $tmp;
    call $t57 := $WritebackToReference($t40, $t57);
    call $tmp := $CopyOrMoveValue($t41);
    $t42 := $tmp;
    call $tmp := $Ge($t55, $t42);
    $t43 := $tmp;
    $tmp := $t43;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    $tmp := $Integer(0);
    $t44 := $tmp;
    call $tmp := $CopyOrMoveValue($t44);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 16255, 6, $tmp);
    }

    goto L9;

  L8:
    call $t45 := $CopyOrMoveRef($t57);
    call $tmp := $GetFieldFromReference($t45, $AccountLimits_Window_tracked_balance);
    $t46 := $tmp;
    call $t57 := $WritebackToReference($t45, $t57);
    call $tmp := $CopyOrMoveValue($t46);
    $t47 := $tmp;
    call $tmp := $Sub($t47, $t55);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 16364, $abort_code);
        goto Abort;
    }

    $t49 := $tmp;
    call $tmp := $CopyOrMoveValue($t49);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 16255, 6, $tmp);
    }

    goto L9;

  L9:
    call $t51 := $CopyOrMoveRef($t57);
    call $t52 := $BorrowField($t51, $AccountLimits_Window_tracked_balance);
    call $t56 := $WritebackToValue($t51, 56, $t56);
    call $t52 := $WriteRef($t52, $t6);
    if (true)
    {
        assume $DebugTrackLocal(3, 16229, 2, $Dereference(limits_definition));
    }

    call $t56 := $WritebackToValue($t52, 56, $t56);
    call $t51 := $WritebackToReference($t52, $t51);
    goto L10;

  L5:
    call $t53 := $CopyOrMoveRef($t57);
    call $t56 := $WritebackToValue($t53, 56, $t56);
    goto L10;

  L10:
    $ret0 := outflow_ok;
    if (true)
    {
        assume $DebugTrackLocal(3, 16393, 59, $ret0);
    }

    $ret1 := $t56;
    if (true)
    {
        assume $DebugTrackLocal(3, 16393, 60, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_can_withdraw_$direct_intra($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $AccountLimits_can_withdraw_$direct_intra($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $IsValidU64(amount);
    assume $AccountLimits_Window_is_well_formed(sending);
    call $ret0, $ret1 := $AccountLimits_can_withdraw_$def($tv0, amount, sending);
}



procedure {:inline 1} $AccountLimits_can_withdraw($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $AccountLimits_can_withdraw($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $IsValidU64(amount);
    assume $AccountLimits_Window_is_well_formed(sending);
    call $ret0, $ret1 := $AccountLimits_can_withdraw_$def($tv0, amount, sending);
}



procedure {:inline 1} $AccountLimits_current_time_$def() returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_current_time_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t1 := $LibraTimestamp_is_not_initialized();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $Integer(0);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t0 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 19438, 0, $tmp);
    }

    goto L3;

  L2:
    call $t3 := $LibraTimestamp_now_microseconds();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t3);
    $t0 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 19438, 0, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t0;
    if (true)
    {
        assume $DebugTrackLocal(3, 19438, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_current_time_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_current_time_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $AccountLimits_current_time_$def();
}



procedure {:inline 1} $AccountLimits_current_time() returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_current_time() returns ($ret0: $Value)
{
    call $ret0 := $AccountLimits_current_time_$def();
}



procedure {:inline 1} $AccountLimits_grant_mutation_capability_$def(lr_account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_grant_mutation_capability_$def(lr_account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 2506, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t15 := $tmp;
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 2606, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t15);
    $t7 := $tmp;
    $tmp := $Integer(0);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(3, 2606, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t15);
    $t9 := $tmp;
    call $t10 := $Roles_has_libra_root_role($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 2666, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(2);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(3, 2666, i#$Integer($t12));
    }

    $abort_code := i#$Integer($t12);
    goto Abort;

  L2:
    $tmp := $Boolean(false);
    $t13 := $tmp;
    call $tmp := $AccountLimits_AccountLimitMutationCapability_pack(0, 0, 0, $t13);
    $t14 := $tmp;
    $ret0 := $t14;
    if (true)
    {
        assume $DebugTrackLocal(3, 2739, 16, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_grant_mutation_capability_$direct_inter(lr_account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_grant_mutation_capability_$direct_inter(lr_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(lr_account);
    call $ret0 := $AccountLimits_grant_mutation_capability_$def(lr_account);
}



procedure {:inline 1} $AccountLimits_grant_mutation_capability_$direct_intra(lr_account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_grant_mutation_capability_$direct_intra(lr_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(lr_account);
    call $ret0 := $AccountLimits_grant_mutation_capability_$def(lr_account);
}



procedure {:inline 1} $AccountLimits_grant_mutation_capability(lr_account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_grant_mutation_capability(lr_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(lr_account);
    call $ret0 := $AccountLimits_grant_mutation_capability_$def(lr_account);
}



procedure {:inline 1} $AccountLimits_has_limits_published_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_has_limits_published_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 18902, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;
    $tmp := $ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(3, 18975, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_has_limits_published_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_has_limits_published_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_has_limits_published_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_has_limits_published_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_has_limits_published_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_has_limits_published_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_has_limits_published($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_has_limits_published($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_has_limits_published_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_has_window_published_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_has_window_published_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 19027, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;
    $tmp := $ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(3, 19100, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_has_window_published_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_has_window_published($AccountLimits_Window_$memory, $tv0, addr))));



implementation {:inline 1} $AccountLimits_has_window_published_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_has_window_published_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_has_window_published_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_has_window_published_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_has_window_published_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_has_window_published($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_has_window_published($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_has_window_published_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_is_unlimited_account_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_is_unlimited_account_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 18727, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t4 := $tmp;
    call $tmp := $GetGlobal($AccountLimits_LimitsDefinition_$memory, $t4, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 18842, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $t3 := $AccountLimits_is_unrestricted($tv0, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(3, 18826, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_is_unlimited_account_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_is_unlimited_account_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_is_unlimited_account_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_is_unlimited_account_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_is_unlimited_account_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_is_unlimited_account_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_is_unlimited_account($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_is_unlimited_account($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_is_unlimited_account_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_is_unrestricted_$def($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_is_unrestricted_$def($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 17873, 0, limits_def);
    }

    call $tmp := $CopyOrMoveValue(limits_def);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t4 := $tmp;
    call $tmp := $GetFieldFromValue($t4, $AccountLimits_LimitsDefinition_max_inflow);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t6 := $tmp;
    $tmp := $Integer(18446744073709551615);
    $t7 := $tmp;
    $tmp := $Boolean($IsEqual($t6, $t7));
    $t8 := $tmp;
    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $CopyOrMoveValue($t31);
    $t9 := $tmp;
    call $tmp := $GetFieldFromValue($t9, $AccountLimits_LimitsDefinition_max_outflow);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;
    $tmp := $Integer(18446744073709551615);
    $t12 := $tmp;
    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 17960, 1, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Boolean(false);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 17960, 1, $tmp);
    }

    goto L3;

  L3:
    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    goto L6;

  L4:
    call $tmp := $CopyOrMoveValue($t31);
    $t16 := $tmp;
    call $tmp := $GetFieldFromValue($t16, $AccountLimits_LimitsDefinition_max_holding);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t18 := $tmp;
    $tmp := $Integer(18446744073709551615);
    $t19 := $tmp;
    $tmp := $Boolean($IsEqual($t18, $t19));
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 17960, 2, $tmp);
    }

    goto L7;

  L6:
    $tmp := $Boolean(false);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 17960, 2, $tmp);
    }

    goto L7;

  L7:
    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L8;
    }
    else
    {
        goto L9;
    }

  L9:
    goto L10;

  L8:
    call $tmp := $CopyOrMoveValue($t31);
    $t23 := $tmp;
    call $tmp := $GetFieldFromValue($t23, $AccountLimits_LimitsDefinition_time_period);
    $t24 := $tmp;
    call $tmp := $CopyOrMoveValue($t24);
    $t25 := $tmp;
    $tmp := $Integer(86400000000);
    $t26 := $tmp;
    $tmp := $Boolean($IsEqual($t25, $t26));
    $t27 := $tmp;
    call $tmp := $CopyOrMoveValue($t27);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 17960, 3, $tmp);
    }

    goto L11;

  L10:
    call $tmp := $CopyOrMoveValue($t31);
    $t28 := $tmp;
    $tmp := $Boolean(false);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue($t29);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 17960, 3, $tmp);
    }

    goto L11;

  L11:
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(3, 17960, 32, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_is_unrestricted_$direct_intra($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_is_unrestricted_$direct_intra($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value)
{
    assume $AccountLimits_LimitsDefinition_is_well_formed(limits_def);
    call $ret0 := $AccountLimits_is_unrestricted_$def($tv0, limits_def);
}



procedure {:inline 1} $AccountLimits_is_unrestricted($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_is_unrestricted($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value)
{
    assume $AccountLimits_LimitsDefinition_is_well_formed(limits_def);
    call $ret0 := $AccountLimits_is_unrestricted_$def($tv0, limits_def);
}



procedure {:inline 1} $AccountLimits_limits_definition_address_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_limits_definition_address_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 18567, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($AccountLimits_Window_$memory, $t5, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 18664, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $AccountLimits_Window_limit_address);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(3, 18664, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_limits_definition_address_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_limits_definition_address_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_limits_definition_address_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_limits_definition_address_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_limits_definition_address_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_limits_definition_address_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_limits_definition_address($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_limits_definition_address($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $AccountLimits_limits_definition_address_$def($tv0, addr);
}



procedure {:inline 1} $AccountLimits_publish_unrestricted_limits_$def($tv0: $TypeValue, publish_account: $Value);



implementation {:inline 1} $AccountLimits_publish_unrestricted_limits_$def($tv0: $TypeValue, publish_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 6503, 0, publish_account);
    }

    call $tmp := $CopyOrMoveValue(publish_account);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 6609, 5, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t7 := $tmp;
    $tmp := $Integer(18446744073709551615);
    $t8 := $tmp;
    $tmp := $Integer(18446744073709551615);
    $t9 := $tmp;
    $tmp := $Integer(86400000000);
    $t10 := $tmp;
    $tmp := $Integer(18446744073709551615);
    $t11 := $tmp;
    call $tmp := $AccountLimits_LimitsDefinition_pack(0, 0, 0, $tv0, $t8, $t9, $t10, $t11);
    $t12 := $tmp;
    call $AccountLimits_LimitsDefinition_$memory := $MoveTo($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t12, $t7);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 6588, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $AccountLimits_publish_unrestricted_limits_$direct_inter($tv0: $TypeValue, publish_account: $Value);



implementation {:inline 1} $AccountLimits_publish_unrestricted_limits_$direct_inter($tv0: $TypeValue, publish_account: $Value)
{
    assume is#$Address(publish_account);
    call $AccountLimits_publish_unrestricted_limits_$def($tv0, publish_account);
}



procedure {:inline 1} $AccountLimits_publish_unrestricted_limits_$direct_intra($tv0: $TypeValue, publish_account: $Value);



implementation {:inline 1} $AccountLimits_publish_unrestricted_limits_$direct_intra($tv0: $TypeValue, publish_account: $Value)
{
    assume is#$Address(publish_account);
    call $AccountLimits_publish_unrestricted_limits_$def($tv0, publish_account);
}



procedure {:inline 1} $AccountLimits_publish_unrestricted_limits($tv0: $TypeValue, publish_account: $Value);



implementation {:inline 1} $AccountLimits_publish_unrestricted_limits($tv0: $TypeValue, publish_account: $Value)
{
    assume is#$Address(publish_account);
    call $AccountLimits_publish_unrestricted_limits_$def($tv0, publish_account);
}



procedure {:inline 1} $AccountLimits_publish_window_$def($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value);



implementation {:inline 1} $AccountLimits_publish_window_$def($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 5488, 0, to_limit);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 5488, 1, _);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 5488, 2, limit_address);
    }

    call $tmp := $CopyOrMoveValue(to_limit);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(_);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue(limit_address);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue($t19);
    $t5 := $tmp;
    call $t6 := $Signer_address_of($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t6);
    $t7 := $tmp;
    call $tmp := $Not($t7);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 5644, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t19);
    $t10 := $tmp;
    $tmp := $Integer(5);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(3, 5644, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t19);
    $t12 := $tmp;
    call $t13 := $AccountLimits_current_time();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(0);
    $t14 := $tmp;
    $tmp := $Integer(0);
    $t15 := $tmp;
    $tmp := $Integer(0);
    $t16 := $tmp;
    call $tmp := $AccountLimits_Window_pack(0, 0, 0, $tv0, $t13, $t14, $t15, $t16, $t21);
    $t18 := $tmp;
    call $AccountLimits_Window_$memory := $MoveTo($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t18, $t12);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 5786, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $AccountLimits_publish_window_$direct_inter($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value);



implementation {:inline 1} $AccountLimits_publish_window_$direct_inter($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value)
{
    assume is#$Address(to_limit);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(_);
    assume is#$Address(limit_address);
    call $AccountLimits_publish_window_$def($tv0, to_limit, _, limit_address);
}



procedure {:inline 1} $AccountLimits_publish_window_$direct_intra($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value);



implementation {:inline 1} $AccountLimits_publish_window_$direct_intra($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value)
{
    assume is#$Address(to_limit);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(_);
    assume is#$Address(limit_address);
    call $AccountLimits_publish_window_$def($tv0, to_limit, _, limit_address);
}



procedure {:inline 1} $AccountLimits_publish_window($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value);



implementation {:inline 1} $AccountLimits_publish_window($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value)
{
    assume is#$Address(to_limit);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(_);
    assume is#$Address(limit_address);
    call $AccountLimits_publish_window_$def($tv0, to_limit, _, limit_address);
}



procedure {:inline 1} $AccountLimits_reset_window_$def($tv0: $TypeValue, window: $Value, limits_definition: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_reset_window_$def($tv0: $TypeValue, window: $Value, limits_definition: $Value) returns ($ret0: $Value)
{
  var current_time: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $t19: $Value;
  var $t20: $Mutation;
  var $t21: $Mutation;
  var $t22: $Mutation;
  var $t23: $Value;
  var $t24: $Mutation;
  var $t25: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 9747, 0, window);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 9747, 1, limits_definition);
    }

    call $tmp := $CopyOrMoveValue(window);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue(limits_definition);
    $t25 := $tmp;
    call $t24 := $BorrowLoc(23, $t23);
    call $t3 := $LibraTimestamp_now_microseconds();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t3);
    current_time := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 9867, 2, $tmp);
    }

    call $t5 := $CopyOrMoveRef($t24);
    call $tmp := $GetFieldFromReference($t5, $AccountLimits_Window_window_start);
    $t6 := $tmp;
    call $t24 := $WritebackToReference($t5, $t24);
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t25);
    $t8 := $tmp;
    call $tmp := $GetFieldFromValue($t8, $AccountLimits_LimitsDefinition_time_period);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t10 := $tmp;
    call $tmp := $AddU64($t7, $t10);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 9965, $abort_code);
        goto Abort;
    }

    $t11 := $tmp;
    call $tmp := $Gt(current_time, $t11);
    $t12 := $tmp;
    $tmp := $t12;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t14 := $CopyOrMoveRef($t24);
    call $t15 := $BorrowField($t14, $AccountLimits_Window_window_start);
    call $t24 := $WritebackToReference($t14, $t24);
    call $t15 := $WriteRef($t15, current_time);
    call $t24 := $WritebackToReference($t15, $t24);
    call $t14 := $WritebackToReference($t15, $t14);
    $tmp := $Integer(0);
    $t16 := $tmp;
    call $t17 := $CopyOrMoveRef($t24);
    call $t18 := $BorrowField($t17, $AccountLimits_Window_window_inflow);
    call $t24 := $WritebackToReference($t17, $t24);
    call $t18 := $WriteRef($t18, $t16);
    call $t24 := $WritebackToReference($t18, $t24);
    call $t17 := $WritebackToReference($t18, $t17);
    $tmp := $Integer(0);
    $t19 := $tmp;
    call $t20 := $CopyOrMoveRef($t24);
    call $t21 := $BorrowField($t20, $AccountLimits_Window_window_outflow);
    call $t23 := $WritebackToValue($t20, 23, $t23);
    call $t21 := $WriteRef($t21, $t19);
    call $t23 := $WritebackToValue($t21, 23, $t23);
    call $t20 := $WritebackToReference($t21, $t20);
    goto L3;

  L2:
    call $t22 := $CopyOrMoveRef($t24);
    call $t23 := $WritebackToValue($t22, 23, $t23);
    goto L3;

  L3:
    $ret0 := $t23;
    if (true)
    {
        assume $DebugTrackLocal(3, 9926, 26, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_reset_window_$direct_intra($tv0: $TypeValue, window: $Value, limits_definition: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, old($AccountLimits_spec_window_reset_with_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0, window, limits_definition)))));
  ensures $AccountLimits_Window_is_well_formed($ret0);



procedure {:inline 1} $AccountLimits_reset_window($tv0: $TypeValue, window: $Value, limits_definition: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, old($AccountLimits_spec_window_reset_with_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0, window, limits_definition)))));
  ensures $AccountLimits_Window_is_well_formed($ret0);



procedure {:inline 1} $AccountLimits_update_deposit_limits_$def($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_update_deposit_limits_$def($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 2997, 0, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 2997, 1, addr);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 2997, 2, _cap);
    }

    call $tmp := $CopyOrMoveValue(amount);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue(addr);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue(_cap);
    $t9 := $tmp;
    call $t5 := $BorrowGlobal($AccountLimits_Window_$memory, $t8, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 3243, $abort_code);
        goto Abort;
    }

    call $tmp := $ReadRef($t5);
    $t10 := $tmp;
    call $t6, $t10 := $AccountLimits_can_receive($tv0, $t7, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t5 := $WriteRef($t5, $t10);
    call $AccountLimits_Window_$memory := $WritebackToGlobal($AccountLimits_Window_$memory, $t5);
    $ret0 := $t6;
    if (true)
    {
        assume $DebugTrackLocal(3, 3188, 11, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_update_deposit_limits_$direct_inter($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, old($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, addr)))));



implementation {:inline 1} $AccountLimits_update_deposit_limits_$direct_inter($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(amount);
    assume is#$Address(addr);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(_cap);
    call $ret0 := $AccountLimits_update_deposit_limits_$def($tv0, amount, addr, _cap);
}



procedure {:inline 1} $AccountLimits_update_deposit_limits_$direct_intra($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_update_deposit_limits_$direct_intra($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(amount);
    assume is#$Address(addr);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(_cap);
    call $ret0 := $AccountLimits_update_deposit_limits_$def($tv0, amount, addr, _cap);
}



procedure {:inline 1} $AccountLimits_update_deposit_limits($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_update_deposit_limits($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(amount);
    assume is#$Address(addr);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(_cap);
    call $ret0 := $AccountLimits_update_deposit_limits_$def($tv0, amount, addr, _cap);
}



procedure {:inline 1} $AccountLimits_update_limits_definition_$def($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value);



implementation {:inline 1} $AccountLimits_update_limits_definition_$def($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value)
{
  var limits_def: $Mutation;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Mutation;
  var $t20: $Mutation;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Mutation;
  var $t26: $Mutation;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Mutation;
  var $t32: $Mutation;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Mutation;
  var $t38: $Mutation;
  var $t39: $Mutation;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 7016, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 7016, 1, limit_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 7016, 2, new_max_inflow);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 7016, 3, new_max_outflow);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 7016, 4, new_max_holding_balance);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 7016, 5, new_time_period);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t40 := $tmp;
    call $tmp := $CopyOrMoveValue(limit_address);
    $t41 := $tmp;
    call $tmp := $CopyOrMoveValue(new_max_inflow);
    $t42 := $tmp;
    call $tmp := $CopyOrMoveValue(new_max_outflow);
    $t43 := $tmp;
    call $tmp := $CopyOrMoveValue(new_max_holding_balance);
    $t44 := $tmp;
    call $tmp := $CopyOrMoveValue(new_time_period);
    $t45 := $tmp;
    call $tmp := $CopyOrMoveValue($t40);
    $t9 := $tmp;
    call $t10 := $Roles_has_treasury_compliance_role($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t10);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 7293, 7, $tmp);
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(3);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(3, 7293, i#$Integer($t12));
    }

    $abort_code := i#$Integer($t12);
    goto Abort;

  L0:
    call $t14 := $BorrowGlobal($AccountLimits_LimitsDefinition_$memory, $t41, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 7574, $abort_code);
        goto Abort;
    }

    call $AccountLimits_LimitsDefinition_before_update_inv($tv0, $Dereference($t14));
    call limits_def := $CopyOrMoveRef($t14);
    if (true)
    {
        assume $DebugTrackLocal(3, 7561, 6, $Dereference(limits_def));
    }

    $tmp := $Integer(0);
    $t16 := $tmp;
    call $tmp := $Gt($t42, $t16);
    $t17 := $tmp;
    $tmp := $t17;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $t19 := $CopyOrMoveRef(limits_def);
    call $t20 := $BorrowField($t19, $AccountLimits_LimitsDefinition_max_inflow);
    call limits_def := $WritebackToReference($t19, limits_def);
    call $t20 := $WriteRef($t20, $t42);
    if (true)
    {
        assume $DebugTrackLocal(3, 7670, 6, $Dereference(limits_def));
    }

    call limits_def := $WritebackToReference($t20, limits_def);
    call $t19 := $WritebackToReference($t20, $t19);
    goto L4;

  L4:
    $tmp := $Integer(0);
    $t22 := $tmp;
    call $tmp := $Gt($t43, $t22);
    $t23 := $tmp;
    $tmp := $t23;
    if (b#$Boolean($tmp))
    {
        goto L5;
    }
    else
    {
        goto L6;
    }

  L6:
    goto L7;

  L5:
    call $t25 := $CopyOrMoveRef(limits_def);
    call $t26 := $BorrowField($t25, $AccountLimits_LimitsDefinition_max_outflow);
    call limits_def := $WritebackToReference($t25, limits_def);
    call $t26 := $WriteRef($t26, $t43);
    if (true)
    {
        assume $DebugTrackLocal(3, 7747, 6, $Dereference(limits_def));
    }

    call limits_def := $WritebackToReference($t26, limits_def);
    call $t25 := $WritebackToReference($t26, $t25);
    goto L7;

  L7:
    $tmp := $Integer(0);
    $t28 := $tmp;
    call $tmp := $Gt($t44, $t28);
    $t29 := $tmp;
    $tmp := $t29;
    if (b#$Boolean($tmp))
    {
        goto L8;
    }
    else
    {
        goto L9;
    }

  L9:
    goto L10;

  L8:
    call $t31 := $CopyOrMoveRef(limits_def);
    call $t32 := $BorrowField($t31, $AccountLimits_LimitsDefinition_max_holding);
    call limits_def := $WritebackToReference($t31, limits_def);
    call $t32 := $WriteRef($t32, $t44);
    if (true)
    {
        assume $DebugTrackLocal(3, 7834, 6, $Dereference(limits_def));
    }

    call limits_def := $WritebackToReference($t32, limits_def);
    call $t31 := $WritebackToReference($t32, $t31);
    goto L10;

  L10:
    $tmp := $Integer(0);
    $t34 := $tmp;
    call $tmp := $Gt($t45, $t34);
    $t35 := $tmp;
    $tmp := $t35;
    if (b#$Boolean($tmp))
    {
        goto L11;
    }
    else
    {
        goto L12;
    }

  L12:
    goto L13;

  L11:
    call $t37 := $CopyOrMoveRef(limits_def);
    call $t38 := $BorrowField($t37, $AccountLimits_LimitsDefinition_time_period);
    call $AccountLimits_LimitsDefinition_$memory := $WritebackToGlobal($AccountLimits_LimitsDefinition_$memory, $t37);
    call $t38 := $WriteRef($t38, $t45);
    if (true)
    {
        assume $DebugTrackLocal(3, 7921, 6, $Dereference(limits_def));
    }

    call $AccountLimits_LimitsDefinition_$memory := $WritebackToGlobal($AccountLimits_LimitsDefinition_$memory, $t38);
    call $t37 := $WritebackToReference($t38, $t37);
    call $AccountLimits_LimitsDefinition_after_update_inv($tv0, $Dereference($t37));
    goto L14;

  L13:
    call $t39 := $CopyOrMoveRef(limits_def);
    call $AccountLimits_LimitsDefinition_$memory := $WritebackToGlobal($AccountLimits_LimitsDefinition_$memory, $t39);
    call $AccountLimits_LimitsDefinition_after_update_inv($tv0, $Dereference($t39));
    goto L14;

  L14:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $AccountLimits_update_limits_definition_$direct_inter($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value);



implementation {:inline 1} $AccountLimits_update_limits_definition_$direct_inter($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(limit_address);
    assume $IsValidU64(new_max_inflow);
    assume $IsValidU64(new_max_outflow);
    assume $IsValidU64(new_max_holding_balance);
    assume $IsValidU64(new_time_period);
    call $AccountLimits_update_limits_definition_$def($tv0, tc_account, limit_address, new_max_inflow, new_max_outflow, new_max_holding_balance, new_time_period);
}



procedure {:inline 1} $AccountLimits_update_limits_definition_$direct_intra($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value);



implementation {:inline 1} $AccountLimits_update_limits_definition_$direct_intra($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(limit_address);
    assume $IsValidU64(new_max_inflow);
    assume $IsValidU64(new_max_outflow);
    assume $IsValidU64(new_max_holding_balance);
    assume $IsValidU64(new_time_period);
    call $AccountLimits_update_limits_definition_$def($tv0, tc_account, limit_address, new_max_inflow, new_max_outflow, new_max_holding_balance, new_time_period);
}



procedure {:inline 1} $AccountLimits_update_limits_definition($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value);



implementation {:inline 1} $AccountLimits_update_limits_definition($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(limit_address);
    assume $IsValidU64(new_max_inflow);
    assume $IsValidU64(new_max_outflow);
    assume $IsValidU64(new_max_holding_balance);
    assume $IsValidU64(new_time_period);
    call $AccountLimits_update_limits_definition_$def($tv0, tc_account, limit_address, new_max_inflow, new_max_outflow, new_max_holding_balance, new_time_period);
}



procedure {:inline 1} $AccountLimits_update_window_info_$def($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value);



implementation {:inline 1} $AccountLimits_update_window_info_$def($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value)
{
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var window: $Mutation;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Mutation;
  var $t20: $Mutation;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Mutation;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Mutation;
  var $t28: $Mutation;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 8752, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 8752, 1, window_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 8752, 2, aggregate_balance);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 8752, 3, new_limit_address);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(window_address);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue(aggregate_balance);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue(new_limit_address);
    $t32 := $tmp;
    call $tmp := $CopyOrMoveValue($t29);
    $t9 := $tmp;
    call $t10 := $Roles_has_treasury_compliance_role($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t10);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 8955, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(3);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(3, 8955, i#$Integer($t12));
    }

    $abort_code := i#$Integer($t12);
    goto Abort;

  L0:
    call $t14 := $BorrowGlobal($AccountLimits_Window_$memory, $t30, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 9059, $abort_code);
        goto Abort;
    }

    call window := $CopyOrMoveRef($t14);
    if (true)
    {
        assume $DebugTrackLocal(3, 9050, 8, $Dereference(window));
    }

    $tmp := $Integer(0);
    $t16 := $tmp;
    $tmp := $Boolean(!$IsEqual($t31, $t16));
    $t17 := $tmp;
    $tmp := $t17;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $t19 := $CopyOrMoveRef(window);
    call $t20 := $BorrowField($t19, $AccountLimits_Window_tracked_balance);
    call window := $WritebackToReference($t19, window);
    call $t20 := $WriteRef($t20, $t31);
    if (true)
    {
        assume $DebugTrackLocal(3, 9151, 8, $Dereference(window));
    }

    call window := $WritebackToReference($t20, window);
    call $t19 := $WritebackToReference($t20, $t19);
    goto L4;

  L4:
    $tmp := $ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t32);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(3, 9205, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L5;
    }
    else
    {
        goto L6;
    }

  L6:
    call $t24 := $CopyOrMoveRef(window);
    call $AccountLimits_Window_$memory := $WritebackToGlobal($AccountLimits_Window_$memory, $t24);
    $tmp := $Integer(4);
    $t25 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(3, 9205, i#$Integer($t25));
    }

    $abort_code := i#$Integer($t25);
    goto Abort;

  L5:
    call $t27 := $CopyOrMoveRef(window);
    call $t28 := $BorrowField($t27, $AccountLimits_Window_limit_address);
    call $AccountLimits_Window_$memory := $WritebackToGlobal($AccountLimits_Window_$memory, $t27);
    call $t28 := $WriteRef($t28, $t32);
    if (true)
    {
        assume $DebugTrackLocal(3, 9306, 8, $Dereference(window));
    }

    call $AccountLimits_Window_$memory := $WritebackToGlobal($AccountLimits_Window_$memory, $t28);
    call $t27 := $WritebackToReference($t28, $t27);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $AccountLimits_update_window_info_$direct_inter($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value);



implementation {:inline 1} $AccountLimits_update_window_info_$direct_inter($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(window_address);
    assume $IsValidU64(aggregate_balance);
    assume is#$Address(new_limit_address);
    call $AccountLimits_update_window_info_$def($tv0, tc_account, window_address, aggregate_balance, new_limit_address);
}



procedure {:inline 1} $AccountLimits_update_window_info_$direct_intra($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value);



implementation {:inline 1} $AccountLimits_update_window_info_$direct_intra($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(window_address);
    assume $IsValidU64(aggregate_balance);
    assume is#$Address(new_limit_address);
    call $AccountLimits_update_window_info_$def($tv0, tc_account, window_address, aggregate_balance, new_limit_address);
}



procedure {:inline 1} $AccountLimits_update_window_info($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value);



implementation {:inline 1} $AccountLimits_update_window_info($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(window_address);
    assume $IsValidU64(aggregate_balance);
    assume is#$Address(new_limit_address);
    call $AccountLimits_update_window_info_$def($tv0, tc_account, window_address, aggregate_balance, new_limit_address);
}



procedure {:inline 1} $AccountLimits_update_withdrawal_limits_$def($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_update_withdrawal_limits_$def($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(3, 4160, 0, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 4160, 1, addr);
    }

    if (true)
    {
        assume $DebugTrackLocal(3, 4160, 2, _cap);
    }

    call $tmp := $CopyOrMoveValue(amount);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue(addr);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue(_cap);
    $t9 := $tmp;
    call $t5 := $BorrowGlobal($AccountLimits_Window_$memory, $t8, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(3, 4410, $abort_code);
        goto Abort;
    }

    call $tmp := $ReadRef($t5);
    $t10 := $tmp;
    call $t6, $t10 := $AccountLimits_can_withdraw($tv0, $t7, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t5 := $WriteRef($t5, $t10);
    call $AccountLimits_Window_$memory := $WritebackToGlobal($AccountLimits_Window_$memory, $t5);
    $ret0 := $t6;
    if (true)
    {
        assume $DebugTrackLocal(3, 4354, 11, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $AccountLimits_update_withdrawal_limits_$direct_inter($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, old($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, addr)))));



implementation {:inline 1} $AccountLimits_update_withdrawal_limits_$direct_inter($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(amount);
    assume is#$Address(addr);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(_cap);
    call $ret0 := $AccountLimits_update_withdrawal_limits_$def($tv0, amount, addr, _cap);
}



procedure {:inline 1} $AccountLimits_update_withdrawal_limits_$direct_intra($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_update_withdrawal_limits_$direct_intra($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(amount);
    assume is#$Address(addr);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(_cap);
    call $ret0 := $AccountLimits_update_withdrawal_limits_$def($tv0, amount, addr, _cap);
}



procedure {:inline 1} $AccountLimits_update_withdrawal_limits($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $AccountLimits_update_withdrawal_limits($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(amount);
    assume is#$Address(addr);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(_cap);
    call $ret0 := $AccountLimits_update_withdrawal_limits_$def($tv0, amount, addr, _cap);
}



const unique $ChainId_ChainId: $TypeName;

const $ChainId_ChainId_id: $FieldName;

axiom $ChainId_ChainId_id == 0;

function $ChainId_ChainId_type_value() : $TypeValue;

axiom $ChainId_ChainId_type_value(): $TypeValue == $StructType($ChainId_ChainId, $EmptyTypeValueArray);

var $ChainId_ChainId_$memory: $Memory;

var $ChainId_ChainId_$memory_$old: $Memory;

function {:inline} $ChainId_ChainId_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU8($SelectField($this, $ChainId_ChainId_id))
}

function {:inline} $ChainId_ChainId_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU8($SelectField($this, $ChainId_ChainId_id))
}

procedure {:inline 1} $ChainId_ChainId_pack($file_id: int, $byte_index: int, $var_idx: int, id: $Value) returns ($struct: $Value);



implementation {:inline 1} $ChainId_ChainId_pack($file_id: int, $byte_index: int, $var_idx: int, id: $Value) returns ($struct: $Value)
{
    assume $IsValidU8(id);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := id], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $ChainId_ChainId_unpack($struct: $Value) returns (id: $Value);



implementation {:inline 1} $ChainId_ChainId_unpack($struct: $Value) returns (id: $Value)
{
    assume is#$Vector($struct);
    id := $SelectField($struct, $ChainId_ChainId_id);
    assume $IsValidU8(id);
}



procedure {:inline 1} $ChainId_initialize_$def(lr_account: $Value, id: $Value);



implementation {:inline 1} $ChainId_initialize_$def(lr_account: $Value, id: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(4, 321, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(4, 321, 1, id);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue(id);
    $t21 := $tmp;
    call $t6 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(4, 382, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t20);
    $t8 := $tmp;
    $tmp := $Integer(0);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(4, 382, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t20);
    $t10 := $tmp;
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t12 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(4, 442, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t20);
    $t15 := $tmp;
    $tmp := $Integer(1);
    $t16 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(4, 442, i#$Integer($t16));
    }

    $abort_code := i#$Integer($t16);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t20);
    $t17 := $tmp;
    call $tmp := $ChainId_ChainId_pack(0, 0, 0, $t21);
    $t19 := $tmp;
    call $ChainId_ChainId_$memory := $MoveTo($ChainId_ChainId_$memory, $EmptyTypeValueArray, $t19, $t17);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(4, 581, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $ChainId_initialize_$direct_inter(lr_account: $Value, id: $Value);



implementation {:inline 1} $ChainId_initialize_$direct_inter(lr_account: $Value, id: $Value)
{
    assume is#$Address(lr_account);
    assume $IsValidU8(id);
    call $ChainId_initialize_$def(lr_account, id);
}



procedure {:inline 1} $ChainId_initialize_$direct_intra(lr_account: $Value, id: $Value);



implementation {:inline 1} $ChainId_initialize_$direct_intra(lr_account: $Value, id: $Value)
{
    assume is#$Address(lr_account);
    assume $IsValidU8(id);
    call $ChainId_initialize_$def(lr_account, id);
}



procedure {:inline 1} $ChainId_initialize(lr_account: $Value, id: $Value);



implementation {:inline 1} $ChainId_initialize(lr_account: $Value, id: $Value)
{
    assume is#$Address(lr_account);
    assume $IsValidU8(id);
    call $ChainId_initialize_$def(lr_account, id);
}



procedure {:inline 1} $ChainId_get_$def() returns ($ret0: $Value);



implementation {:inline 1} $ChainId_get_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($ChainId_ChainId_$memory, $t0, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(4, 727, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $ChainId_ChainId_id);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(4, 727, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $ChainId_get_$direct_inter() returns ($ret0: $Value);



implementation {:inline 1} $ChainId_get_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $ChainId_get_$def();
}



procedure {:inline 1} $ChainId_get_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $ChainId_get_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $ChainId_get_$def();
}



procedure {:inline 1} $ChainId_get() returns ($ret0: $Value);



implementation {:inline 1} $ChainId_get() returns ($ret0: $Value)
{
    call $ret0 := $ChainId_get_$def();
}



function {:inline} $LibraConfig_spec_has_config($LibraConfig_Configuration_$memory: $Memory) : $Value
{
  $ResourceExists($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraConfig_spec_get($LibraConfig_LibraConfig_$memory: $Memory, $tv0: $TypeValue) : $Value
{
  $SelectField($ResourceValue($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()), $LibraConfig_LibraConfig_payload)
}

function {:inline} $LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory: $Memory, $tv0: $TypeValue) : $Value
{
  $ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}

const unique $LibraConfig_LibraConfig: $TypeName;

const $LibraConfig_LibraConfig_payload: $FieldName;

axiom $LibraConfig_LibraConfig_payload == 0;

function $LibraConfig_LibraConfig_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier323"} { $LibraConfig_LibraConfig_type_value($tv0): $TypeValue } $LibraConfig_LibraConfig_type_value($tv0): $TypeValue == $StructType($LibraConfig_LibraConfig, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $LibraConfig_LibraConfig_$memory: $Memory;

var $LibraConfig_LibraConfig_$memory_$old: $Memory;

function {:inline} $LibraConfig_LibraConfig_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1
}

function {:inline} $LibraConfig_LibraConfig_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1
}

procedure {:inline 1} $LibraConfig_LibraConfig_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, payload: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraConfig_LibraConfig_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, payload: $Value) returns ($struct: $Value)
{
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := payload], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraConfig_LibraConfig_unpack($tv0: $TypeValue, $struct: $Value) returns (payload: $Value);



implementation {:inline 1} $LibraConfig_LibraConfig_unpack($tv0: $TypeValue, $struct: $Value) returns (payload: $Value)
{
    assume is#$Vector($struct);
    payload := $SelectField($struct, $LibraConfig_LibraConfig_payload);
}



const unique $LibraConfig_Configuration: $TypeName;

const $LibraConfig_Configuration_epoch: $FieldName;

axiom $LibraConfig_Configuration_epoch == 0;

const $LibraConfig_Configuration_last_reconfiguration_time: $FieldName;

axiom $LibraConfig_Configuration_last_reconfiguration_time == 1;

const $LibraConfig_Configuration_events: $FieldName;

axiom $LibraConfig_Configuration_events == 2;

function $LibraConfig_Configuration_type_value() : $TypeValue;

axiom $LibraConfig_Configuration_type_value(): $TypeValue == $StructType($LibraConfig_Configuration, $EmptyTypeValueArray);

var $LibraConfig_Configuration_$memory: $Memory;

var $LibraConfig_Configuration_$memory_$old: $Memory;

function {:inline} $LibraConfig_Configuration_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $LibraConfig_Configuration_epoch)) && $IsValidU64($SelectField($this, $LibraConfig_Configuration_last_reconfiguration_time)) && $Event_EventHandle_is_well_formed_types($SelectField($this, $LibraConfig_Configuration_events))
}

function {:inline} $LibraConfig_Configuration_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $LibraConfig_Configuration_epoch)) && $IsValidU64($SelectField($this, $LibraConfig_Configuration_last_reconfiguration_time)) && $Event_EventHandle_is_well_formed($SelectField($this, $LibraConfig_Configuration_events))
}

procedure {:inline 1} $LibraConfig_Configuration_pack($file_id: int, $byte_index: int, $var_idx: int, epoch: $Value, last_reconfiguration_time: $Value, events: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraConfig_Configuration_pack($file_id: int, $byte_index: int, $var_idx: int, epoch: $Value, last_reconfiguration_time: $Value, events: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(epoch);
    assume $IsValidU64(last_reconfiguration_time);
    assume $Event_EventHandle_is_well_formed(events);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := epoch][1 := last_reconfiguration_time][2 := events], 3));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraConfig_Configuration_unpack($struct: $Value) returns (epoch: $Value, last_reconfiguration_time: $Value, events: $Value);



implementation {:inline 1} $LibraConfig_Configuration_unpack($struct: $Value) returns (epoch: $Value, last_reconfiguration_time: $Value, events: $Value)
{
    assume is#$Vector($struct);
    epoch := $SelectField($struct, $LibraConfig_Configuration_epoch);
    assume $IsValidU64(epoch);
    last_reconfiguration_time := $SelectField($struct, $LibraConfig_Configuration_last_reconfiguration_time);
    assume $IsValidU64(last_reconfiguration_time);
    events := $SelectField($struct, $LibraConfig_Configuration_events);
    assume $Event_EventHandle_is_well_formed(events);
}



const unique $LibraConfig_ModifyConfigCapability: $TypeName;

const $LibraConfig_ModifyConfigCapability_dummy_field: $FieldName;

axiom $LibraConfig_ModifyConfigCapability_dummy_field == 0;

function $LibraConfig_ModifyConfigCapability_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier324"} { $LibraConfig_ModifyConfigCapability_type_value($tv0): $TypeValue } $LibraConfig_ModifyConfigCapability_type_value($tv0): $TypeValue == $StructType($LibraConfig_ModifyConfigCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $LibraConfig_ModifyConfigCapability_$memory: $Memory;

var $LibraConfig_ModifyConfigCapability_$memory_$old: $Memory;

function {:inline} $LibraConfig_ModifyConfigCapability_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $LibraConfig_ModifyConfigCapability_dummy_field))
}

function {:inline} $LibraConfig_ModifyConfigCapability_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $LibraConfig_ModifyConfigCapability_dummy_field))
}

procedure {:inline 1} $LibraConfig_ModifyConfigCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraConfig_ModifyConfigCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraConfig_ModifyConfigCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $LibraConfig_ModifyConfigCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LibraConfig_ModifyConfigCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}



const unique $LibraConfig_NewEpochEvent: $TypeName;

const $LibraConfig_NewEpochEvent_epoch: $FieldName;

axiom $LibraConfig_NewEpochEvent_epoch == 0;

function $LibraConfig_NewEpochEvent_type_value() : $TypeValue;

axiom $LibraConfig_NewEpochEvent_type_value(): $TypeValue == $StructType($LibraConfig_NewEpochEvent, $EmptyTypeValueArray);

var $LibraConfig_NewEpochEvent_$memory: $Memory;

var $LibraConfig_NewEpochEvent_$memory_$old: $Memory;

function {:inline} $LibraConfig_NewEpochEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $LibraConfig_NewEpochEvent_epoch))
}

function {:inline} $LibraConfig_NewEpochEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $LibraConfig_NewEpochEvent_epoch))
}

procedure {:inline 1} $LibraConfig_NewEpochEvent_pack($file_id: int, $byte_index: int, $var_idx: int, epoch: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraConfig_NewEpochEvent_pack($file_id: int, $byte_index: int, $var_idx: int, epoch: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(epoch);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := epoch], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraConfig_NewEpochEvent_unpack($struct: $Value) returns (epoch: $Value);



implementation {:inline 1} $LibraConfig_NewEpochEvent_unpack($struct: $Value) returns (epoch: $Value)
{
    assume is#$Vector($struct);
    epoch := $SelectField($struct, $LibraConfig_NewEpochEvent_epoch);
    assume $IsValidU64(epoch);
}



procedure {:inline 1} $LibraConfig_initialize_$def(config_account: $Value);



implementation {:inline 1} $LibraConfig_initialize_$def(config_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(17, 1182, 0, config_account);
    }

    call $tmp := $CopyOrMoveValue(config_account);
    $t22 := $tmp;
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 1254, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t22);
    $t7 := $tmp;
    $tmp := $Integer(0);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 1254, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t22);
    $t9 := $tmp;
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 1348, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t22);
    $t14 := $tmp;
    $tmp := $Integer(2);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 1348, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t22);
    $t16 := $tmp;
    $tmp := $Integer(0);
    $t17 := $tmp;
    $tmp := $Integer(0);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t19 := $tmp;
    call $t20 := $Event_new_event_handle($LibraConfig_NewEpochEvent_type_value(), $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraConfig_Configuration_pack(0, 0, 0, $t17, $t18, $t20);
    $t21 := $tmp;
    call $LibraConfig_Configuration_$memory := $MoveTo($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $t21, $t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(17, 1467, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraConfig_initialize_$direct_inter(config_account: $Value);



implementation {:inline 1} $LibraConfig_initialize_$direct_inter(config_account: $Value)
{
    assume is#$Address(config_account);
    call $LibraConfig_initialize_$def(config_account);
}



procedure {:inline 1} $LibraConfig_initialize_$direct_intra(config_account: $Value);



implementation {:inline 1} $LibraConfig_initialize_$direct_intra(config_account: $Value)
{
    assume is#$Address(config_account);
    call $LibraConfig_initialize_$def(config_account);
}



procedure {:inline 1} $LibraConfig_initialize(config_account: $Value);



implementation {:inline 1} $LibraConfig_initialize(config_account: $Value)
{
    assume is#$Address(config_account);
    call $LibraConfig_initialize_$def(config_account);
}



procedure {:inline 1} $LibraConfig_get_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $LibraConfig_get_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var addr: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t3 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t3);
    addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 1874, 0, $tmp);
    }

    $tmp := $ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 1926, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(3);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 1926, i#$Integer($t7));
    }

    $abort_code := i#$Integer($t7);
    goto Abort;

  L0:
    call $tmp := $GetGlobal($LibraConfig_LibraConfig_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(17, 2003, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $tmp := $GetFieldFromValue($t9, $LibraConfig_LibraConfig_payload);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;
    $ret0 := $t11;
    if (true)
    {
        assume $DebugTrackLocal(17, 2001, 12, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraConfig_get_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $LibraConfig_get_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $LibraConfig_get_$def($tv0);
}



procedure {:inline 1} $LibraConfig_get_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $LibraConfig_get_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $LibraConfig_get_$def($tv0);
}



procedure {:inline 1} $LibraConfig_get($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $LibraConfig_get($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $LibraConfig_get_$def($tv0);
}



procedure {:inline 1} $LibraConfig_emit_reconfiguration_event_$def();



implementation {:inline 1} $LibraConfig_emit_reconfiguration_event_$def()
{
  var config_ref: $Mutation;
  var $t1: $Value;
  var $t2: $Mutation;
  var $t3: $Mutation;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Mutation;
  var $t9: $Mutation;
  var $t10: $Mutation;
  var $t11: $Mutation;
  var $t12: $Mutation;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t1 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t2 := $BorrowGlobal($LibraConfig_Configuration_$memory, $t1, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(17, 6562, $abort_code);
        goto Abort;
    }

    call config_ref := $CopyOrMoveRef($t2);
    if (true)
    {
        assume $DebugTrackLocal(17, 6549, 0, $Dereference(config_ref));
    }

    call $t3 := $CopyOrMoveRef(config_ref);
    call $tmp := $GetFieldFromReference($t3, $LibraConfig_Configuration_epoch);
    $t4 := $tmp;
    call config_ref := $WritebackToReference($t3, config_ref);
    call $tmp := $CopyOrMoveValue($t4);
    $t5 := $tmp;
    $tmp := $Integer(1);
    $t6 := $tmp;
    call $tmp := $AddU64($t5, $t6);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(17, 6677, $abort_code);
        goto Abort;
    }

    $t7 := $tmp;
    call $t8 := $CopyOrMoveRef(config_ref);
    call $t9 := $BorrowField($t8, $LibraConfig_Configuration_epoch);
    call config_ref := $WritebackToReference($t8, config_ref);
    call $t9 := $WriteRef($t9, $t7);
    if (true)
    {
        assume $DebugTrackLocal(17, 6641, 0, $Dereference(config_ref));
    }

    call config_ref := $WritebackToReference($t9, config_ref);
    call $t8 := $WritebackToReference($t9, $t8);
    call $t10 := $CopyOrMoveRef(config_ref);
    call $t11 := $BorrowField($t10, $LibraConfig_Configuration_events);
    call config_ref := $WritebackToReference($t10, config_ref);
    call $t12 := $CopyOrMoveRef(config_ref);
    call $tmp := $GetFieldFromReference($t12, $LibraConfig_Configuration_epoch);
    $t13 := $tmp;
    call $LibraConfig_Configuration_$memory := $WritebackToGlobal($LibraConfig_Configuration_$memory, $t12);
    call $tmp := $CopyOrMoveValue($t13);
    $t14 := $tmp;
    call $tmp := $LibraConfig_NewEpochEvent_pack(0, 0, 0, $t14);
    $t15 := $tmp;
    call $tmp := $ReadRef($t11);
    $t16 := $tmp;
    call $t16 := $Event_emit_event($LibraConfig_NewEpochEvent_type_value(), $t16, $t15);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $WriteRef($t11, $t16);
    if (true)
    {
        assume $DebugTrackLocal(17, 6479, 0, $Dereference(config_ref));
    }

    call $LibraConfig_Configuration_$memory := $WritebackToGlobal($LibraConfig_Configuration_$memory, $t11);
    call $t10 := $WritebackToReference($t11, $t10);
    call $t12 := $WritebackToReference($t11, $t12);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraConfig_emit_reconfiguration_event_$direct_intra();



implementation {:inline 1} $LibraConfig_emit_reconfiguration_event_$direct_intra()
{
    call $LibraConfig_emit_reconfiguration_event_$def();
}



procedure {:inline 1} $LibraConfig_emit_reconfiguration_event();



implementation {:inline 1} $LibraConfig_emit_reconfiguration_event()
{
    call $LibraConfig_emit_reconfiguration_event_$def();
}



procedure {:inline 1} $LibraConfig_publish_new_config_$def($tv0: $TypeValue, config_account: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_publish_new_config_$def($tv0: $TypeValue, config_account: $Value, payload: $Value)
{
  var capability: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(17, 4127, 0, config_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(17, 4127, 1, payload);
    }

    call $tmp := $CopyOrMoveValue(config_account);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue(payload);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t3 := $tmp;
    call $t5 := $LibraConfig_publish_new_config_and_get_capability($tv0, $t3, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    capability := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 4253, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t6 := $tmp;
    call $LibraConfig_ModifyConfigCapability_$memory := $MoveTo($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), capability, $t6);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(17, 4346, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraConfig_publish_new_config_$direct_inter($tv0: $TypeValue, config_account: $Value, payload: $Value);
  ensures !$abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)))));
  ensures !$abort_flag ==> b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0));



implementation {:inline 1} $LibraConfig_publish_new_config_$direct_inter($tv0: $TypeValue, config_account: $Value, payload: $Value)
{
    assume is#$Address(config_account);
    call $LibraConfig_publish_new_config_$def($tv0, config_account, payload);
}



procedure {:inline 1} $LibraConfig_publish_new_config_$direct_intra($tv0: $TypeValue, config_account: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_publish_new_config_$direct_intra($tv0: $TypeValue, config_account: $Value, payload: $Value)
{
    assume is#$Address(config_account);
    call $LibraConfig_publish_new_config_$def($tv0, config_account, payload);
}



procedure {:inline 1} $LibraConfig_publish_new_config($tv0: $TypeValue, config_account: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_publish_new_config($tv0: $TypeValue, config_account: $Value, payload: $Value)
{
    assume is#$Address(config_account);
    call $LibraConfig_publish_new_config_$def($tv0, config_account, payload);
}



procedure {:inline 1} $LibraConfig_publish_new_config_and_get_capability_$def($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraConfig_publish_new_config_and_get_capability_$def($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(17, 3469, 0, config_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(17, 3469, 1, payload);
    }

    call $tmp := $CopyOrMoveValue(config_account);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(payload);
    $t30 := $tmp;
    call $t8 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 3643, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t29);
    $t10 := $tmp;
    $tmp := $Integer(0);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 3643, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t29);
    $t12 := $tmp;
    call $t13 := $Roles_has_libra_root_role($t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 3703, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t29);
    $t15 := $tmp;
    $tmp := $Integer(1);
    $t16 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 3703, i#$Integer($t16));
    }

    $abort_code := i#$Integer($t16);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t29);
    $t17 := $tmp;
    call $t18 := $Signer_address_of($t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t18, $t19));
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 3780, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $tmp := $CopyOrMoveValue($t29);
    $t22 := $tmp;
    $tmp := $Integer(2);
    $t23 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 3780, i#$Integer($t23));
    }

    $abort_code := i#$Integer($t23);
    goto Abort;

  L4:
    call $tmp := $CopyOrMoveValue($t29);
    $t24 := $tmp;
    call $tmp := $LibraConfig_LibraConfig_pack(0, 0, 0, $tv0, $t30);
    $t26 := $tmp;
    call $LibraConfig_LibraConfig_$memory := $MoveTo($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t26, $t24);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(17, 3899, $abort_code);
        goto Abort;
    }

    $tmp := $Boolean(false);
    $t27 := $tmp;
    call $tmp := $LibraConfig_ModifyConfigCapability_pack(0, 0, 0, $tv0, $t27);
    $t28 := $tmp;
    $ret0 := $t28;
    if (true)
    {
        assume $DebugTrackLocal(17, 3957, 31, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraConfig_publish_new_config_and_get_capability_$direct_inter($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraConfig_publish_new_config_and_get_capability_$direct_inter($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value)
{
    assume is#$Address(config_account);
    call $ret0 := $LibraConfig_publish_new_config_and_get_capability_$def($tv0, config_account, payload);
}



procedure {:inline 1} $LibraConfig_publish_new_config_and_get_capability_$direct_intra($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraConfig_publish_new_config_and_get_capability_$direct_intra($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value)
{
    assume is#$Address(config_account);
    call $ret0 := $LibraConfig_publish_new_config_and_get_capability_$def($tv0, config_account, payload);
}



procedure {:inline 1} $LibraConfig_publish_new_config_and_get_capability($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraConfig_publish_new_config_and_get_capability($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value)
{
    assume is#$Address(config_account);
    call $ret0 := $LibraConfig_publish_new_config_and_get_capability_$def($tv0, config_account, payload);
}



procedure {:inline 1} $LibraConfig_reconfigure_$def(lr_account: $Value);



implementation {:inline 1} $LibraConfig_reconfigure_$def(lr_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(17, 4511, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;
    call $t4 := $Roles_has_libra_root_role($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 4675, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(1);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 4675, i#$Integer($t6));
    }

    $abort_code := i#$Integer($t6);
    goto Abort;

  L0:
    call $LibraConfig_reconfigure_();
    assume $abort_flag == false;
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraConfig_reconfigure_$direct_inter(lr_account: $Value);



implementation {:inline 1} $LibraConfig_reconfigure_$direct_inter(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraConfig_reconfigure_$def(lr_account);
}



procedure {:inline 1} $LibraConfig_reconfigure_$direct_intra(lr_account: $Value);



implementation {:inline 1} $LibraConfig_reconfigure_$direct_intra(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraConfig_reconfigure_$def(lr_account);
}



procedure {:inline 1} $LibraConfig_reconfigure(lr_account: $Value);



implementation {:inline 1} $LibraConfig_reconfigure(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraConfig_reconfigure_$def(lr_account);
}



procedure {:inline 1} $LibraConfig_reconfigure__$def();



implementation {:inline 1} $LibraConfig_reconfigure__$def()
{
  var config_ref: $Mutation;
  var current_block_time: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Mutation;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Mutation;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t4 := $LibraTimestamp_is_not_initialized();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    return;

  L2:
    call $t5 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t6 := $BorrowGlobal($LibraConfig_Configuration_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(17, 5029, $abort_code);
        goto Abort;
    }

    call config_ref := $CopyOrMoveRef($t6);
    if (true)
    {
        assume $DebugTrackLocal(17, 5016, 0, $Dereference(config_ref));
    }

    call $t7 := $LibraTimestamp_now_microseconds();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    current_block_time := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 5314, 1, $tmp);
    }

    call $t9 := $CopyOrMoveRef(config_ref);
    call $tmp := $GetFieldFromReference($t9, $LibraConfig_Configuration_last_reconfiguration_time);
    $t10 := $tmp;
    call config_ref := $WritebackToReference($t9, config_ref);
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;
    call $tmp := $Gt(current_block_time, $t11);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 5378, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L3;
    }
    else
    {
        goto L4;
    }

  L4:
    call $t14 := $CopyOrMoveRef(config_ref);
    call $LibraConfig_Configuration_$memory := $WritebackToGlobal($LibraConfig_Configuration_$memory, $t14);
    $tmp := $Integer(5);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 5378, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L3:
    call $t17 := $CopyOrMoveRef(config_ref);
    call $t18 := $BorrowField($t17, $LibraConfig_Configuration_last_reconfiguration_time);
    call $LibraConfig_Configuration_$memory := $WritebackToGlobal($LibraConfig_Configuration_$memory, $t17);
    call $t18 := $WriteRef($t18, current_block_time);
    if (true)
    {
        assume $DebugTrackLocal(17, 5473, 0, $Dereference(config_ref));
    }

    call $LibraConfig_Configuration_$memory := $WritebackToGlobal($LibraConfig_Configuration_$memory, $t18);
    call $t17 := $WritebackToReference($t18, $t17);
    call $LibraConfig_emit_reconfiguration_event();
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraConfig_reconfigure__$direct_intra();



implementation {:inline 1} $LibraConfig_reconfigure__$direct_intra()
{
    call $LibraConfig_reconfigure__$def();
}



procedure {:inline 1} $LibraConfig_reconfigure_();



implementation {:inline 1} $LibraConfig_reconfigure_()
{
    call $LibraConfig_reconfigure__$def();
}



procedure {:inline 1} $LibraConfig_set_$def($tv0: $TypeValue, account: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_set_$def($tv0: $TypeValue, account: $Value, payload: $Value)
{
  var addr: $Value;
  var config: $Mutation;
  var signer_address: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Mutation;
  var $t23: $Value;
  var $t24: $Mutation;
  var $t25: $Mutation;
  var $t26: $Value;
  var $t27: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(17, 2197, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(17, 2197, 1, payload);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t26 := $tmp;
    call $tmp := $CopyOrMoveValue(payload);
    $t27 := $tmp;
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 2319, 2, $tmp);
    }

    $tmp := $ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 2371, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t26);
    $t13 := $tmp;
    $tmp := $Integer(3);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 2371, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t26);
    $t15 := $tmp;
    call $t16 := $Signer_address_of($t15);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t16);
    signer_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 2450, 4, $tmp);
    }

    $tmp := $ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), signer_address);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 2504, 7, $tmp);
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(4);
    $t20 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 2504, i#$Integer($t20));
    }

    $abort_code := i#$Integer($t20);
    goto Abort;

  L2:
    call $t22 := $BorrowGlobal($LibraConfig_LibraConfig_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(17, 2619, $abort_code);
        goto Abort;
    }

    call config := $CopyOrMoveRef($t22);
    if (true)
    {
        assume $DebugTrackLocal(17, 2610, 3, $Dereference(config));
    }

    call $t24 := $CopyOrMoveRef(config);
    call $t25 := $BorrowField($t24, $LibraConfig_LibraConfig_payload);
    call $LibraConfig_LibraConfig_$memory := $WritebackToGlobal($LibraConfig_LibraConfig_$memory, $t24);
    call $t25 := $WriteRef($t25, $t27);
    if (true)
    {
        assume $DebugTrackLocal(17, 2673, 3, $Dereference(config));
    }

    call $LibraConfig_LibraConfig_$memory := $WritebackToGlobal($LibraConfig_LibraConfig_$memory, $t25);
    call $t24 := $WritebackToReference($t25, $t24);
    call $LibraConfig_reconfigure_();
    assume $abort_flag == false;
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraConfig_set_$direct_inter($tv0: $TypeValue, account: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_set_$direct_inter($tv0: $TypeValue, account: $Value, payload: $Value)
{
    assume is#$Address(account);
    call $LibraConfig_set_$def($tv0, account, payload);
}



procedure {:inline 1} $LibraConfig_set_$direct_intra($tv0: $TypeValue, account: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_set_$direct_intra($tv0: $TypeValue, account: $Value, payload: $Value)
{
    assume is#$Address(account);
    call $LibraConfig_set_$def($tv0, account, payload);
}



procedure {:inline 1} $LibraConfig_set($tv0: $TypeValue, account: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_set($tv0: $TypeValue, account: $Value, payload: $Value)
{
    assume is#$Address(account);
    call $LibraConfig_set_$def($tv0, account, payload);
}



procedure {:inline 1} $LibraConfig_set_with_capability_and_reconfigure_$def($tv0: $TypeValue, _cap: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_set_with_capability_and_reconfigure_$def($tv0: $TypeValue, _cap: $Value, payload: $Value)
{
  var addr: $Value;
  var config: $Mutation;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Mutation;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(17, 2806, 0, _cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(17, 2806, 1, payload);
    }

    call $tmp := $CopyOrMoveValue(_cap);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(payload);
    $t17 := $tmp;
    call $t6 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 2999, 2, $tmp);
    }

    $tmp := $ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(17, 3051, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(3);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(17, 3051, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    call $t12 := $BorrowGlobal($LibraConfig_LibraConfig_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(17, 3139, $abort_code);
        goto Abort;
    }

    call config := $CopyOrMoveRef($t12);
    if (true)
    {
        assume $DebugTrackLocal(17, 3130, 3, $Dereference(config));
    }

    call $t14 := $CopyOrMoveRef(config);
    call $t15 := $BorrowField($t14, $LibraConfig_LibraConfig_payload);
    call $LibraConfig_LibraConfig_$memory := $WritebackToGlobal($LibraConfig_LibraConfig_$memory, $t14);
    call $t15 := $WriteRef($t15, $t17);
    if (true)
    {
        assume $DebugTrackLocal(17, 3193, 3, $Dereference(config));
    }

    call $LibraConfig_LibraConfig_$memory := $WritebackToGlobal($LibraConfig_LibraConfig_$memory, $t15);
    call $t14 := $WritebackToReference($t15, $t14);
    call $LibraConfig_reconfigure_();
    assume $abort_flag == false;
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraConfig_set_with_capability_and_reconfigure_$direct_inter($tv0: $TypeValue, _cap: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_set_with_capability_and_reconfigure_$direct_inter($tv0: $TypeValue, _cap: $Value, payload: $Value)
{
    assume $LibraConfig_ModifyConfigCapability_is_well_formed(_cap);
    call $LibraConfig_set_with_capability_and_reconfigure_$def($tv0, _cap, payload);
}



procedure {:inline 1} $LibraConfig_set_with_capability_and_reconfigure_$direct_intra($tv0: $TypeValue, _cap: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_set_with_capability_and_reconfigure_$direct_intra($tv0: $TypeValue, _cap: $Value, payload: $Value)
{
    assume $LibraConfig_ModifyConfigCapability_is_well_formed(_cap);
    call $LibraConfig_set_with_capability_and_reconfigure_$def($tv0, _cap, payload);
}



procedure {:inline 1} $LibraConfig_set_with_capability_and_reconfigure($tv0: $TypeValue, _cap: $Value, payload: $Value);



implementation {:inline 1} $LibraConfig_set_with_capability_and_reconfigure($tv0: $TypeValue, _cap: $Value, payload: $Value)
{
    assume $LibraConfig_ModifyConfigCapability_is_well_formed(_cap);
    call $LibraConfig_set_with_capability_and_reconfigure_$def($tv0, _cap, payload);
}



function {:inline} $RegisteredCurrencies_get_currency_codes($LibraConfig_LibraConfig_$memory: $Memory) : $Value
{
  $SelectField($LibraConfig_spec_get($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes)
}

const unique $RegisteredCurrencies_RegisteredCurrencies: $TypeName;

const $RegisteredCurrencies_RegisteredCurrencies_currency_codes: $FieldName;

axiom $RegisteredCurrencies_RegisteredCurrencies_currency_codes == 0;

function $RegisteredCurrencies_RegisteredCurrencies_type_value() : $TypeValue;

axiom $RegisteredCurrencies_RegisteredCurrencies_type_value(): $TypeValue == $StructType($RegisteredCurrencies_RegisteredCurrencies, $EmptyTypeValueArray);

var $RegisteredCurrencies_RegisteredCurrencies_$memory: $Memory;

var $RegisteredCurrencies_RegisteredCurrencies_$memory_$old: $Memory;

function {:inline} $RegisteredCurrencies_RegisteredCurrencies_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Vector_is_well_formed($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) && (forall $$0: int :: {:qid "quantifier325"} { $select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) ==> $Vector_is_well_formed($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0)) && (forall $$1: int :: {:qid "quantifier326"} { $select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0), $$1) } $$1 >= 0 && $$1 < $vlen($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0)) ==> $IsValidU8($select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0), $$1))))
}

function {:inline} $RegisteredCurrencies_RegisteredCurrencies_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Vector_is_well_formed($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) && (forall $$0: int :: {:qid "quantifier327"} { $select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) ==> $Vector_is_well_formed($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0)) && (forall $$1: int :: {:qid "quantifier328"} { $select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0), $$1) } $$1 >= 0 && $$1 < $vlen($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0)) ==> $IsValidU8($select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes), $$0), $$1))))
}

procedure {:inline 1} $RegisteredCurrencies_RegisteredCurrencies_pack($file_id: int, $byte_index: int, $var_idx: int, currency_codes: $Value) returns ($struct: $Value);



implementation {:inline 1} $RegisteredCurrencies_RegisteredCurrencies_pack($file_id: int, $byte_index: int, $var_idx: int, currency_codes: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(currency_codes) && (forall $$0: int :: {:qid "quantifier329"} { $select_vector(currency_codes, $$0) } $$0 >= 0 && $$0 < $vlen(currency_codes) ==> $Vector_is_well_formed($select_vector(currency_codes, $$0)) && (forall $$1: int :: {:qid "quantifier330"} { $select_vector($select_vector(currency_codes, $$0), $$1) } $$1 >= 0 && $$1 < $vlen($select_vector(currency_codes, $$0)) ==> $IsValidU8($select_vector($select_vector(currency_codes, $$0), $$1))));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := currency_codes], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $RegisteredCurrencies_RegisteredCurrencies_unpack($struct: $Value) returns (currency_codes: $Value);



implementation {:inline 1} $RegisteredCurrencies_RegisteredCurrencies_unpack($struct: $Value) returns (currency_codes: $Value)
{
    assume is#$Vector($struct);
    currency_codes := $SelectField($struct, $RegisteredCurrencies_RegisteredCurrencies_currency_codes);
    assume $Vector_is_well_formed(currency_codes) && (forall $$0: int :: {:qid "quantifier331"} { $select_vector(currency_codes, $$0) } $$0 >= 0 && $$0 < $vlen(currency_codes) ==> $Vector_is_well_formed($select_vector(currency_codes, $$0)) && (forall $$1: int :: {:qid "quantifier332"} { $select_vector($select_vector(currency_codes, $$0), $$1) } $$1 >= 0 && $$1 < $vlen($select_vector(currency_codes, $$0)) ==> $IsValidU8($select_vector($select_vector(currency_codes, $$0), $$1))));
}



procedure {:inline 1} $RegisteredCurrencies_initialize_$def(config_account: $Value);



implementation {:inline 1} $RegisteredCurrencies_initialize_$def(config_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(21, 724, 0, config_account);
    }

    call $tmp := $CopyOrMoveValue(config_account);
    $t19 := $tmp;
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(21, 781, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t19);
    $t7 := $tmp;
    $tmp := $Integer(0);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(21, 781, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t19);
    $t9 := $tmp;
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(21, 842, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t19);
    $t14 := $tmp;
    $tmp := $Integer(1);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(21, 842, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t19);
    $t16 := $tmp;
    call $t17 := $Vector_empty($Vector_type_value($IntegerType()));
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $RegisteredCurrencies_RegisteredCurrencies_pack(0, 0, 0, $t17);
    $t18 := $tmp;
    call $LibraConfig_publish_new_config($RegisteredCurrencies_RegisteredCurrencies_type_value(), $t16, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $RegisteredCurrencies_initialize_$direct_inter(config_account: $Value);
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(config_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) ==> $abort_flag;
  ensures !$abort_flag ==> b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($vlen_value($RegisteredCurrencies_get_currency_codes($LibraConfig_LibraConfig_$memory)), $Integer(0))));



implementation {:inline 1} $RegisteredCurrencies_initialize_$direct_inter(config_account: $Value)
{
    assume is#$Address(config_account);
    call $RegisteredCurrencies_initialize_$def(config_account);
}



procedure {:inline 1} $RegisteredCurrencies_initialize_$direct_intra(config_account: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))));



implementation {:inline 1} $RegisteredCurrencies_initialize_$direct_intra(config_account: $Value)
{
    assume is#$Address(config_account);
    call $RegisteredCurrencies_initialize_$def(config_account);
}



procedure {:inline 1} $RegisteredCurrencies_initialize(config_account: $Value);



implementation {:inline 1} $RegisteredCurrencies_initialize(config_account: $Value)
{
    assume is#$Address(config_account);
    call $RegisteredCurrencies_initialize_$def(config_account);
}



procedure {:inline 1} $RegisteredCurrencies_add_currency_code_$def(lr_account: $Value, currency_code: $Value);



implementation {:inline 1} $RegisteredCurrencies_add_currency_code_$def(lr_account: $Value, currency_code: $Value)
{
  var config: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(21, 1929, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(21, 1929, 1, currency_code);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(currency_code);
    $t20 := $tmp;
    call $t5 := $LibraConfig_get($RegisteredCurrencies_RegisteredCurrencies_type_value());
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    config := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(21, 2043, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue(config);
    $t6 := $tmp;
    call $tmp := $GetFieldFromValue($t6, $RegisteredCurrencies_RegisteredCurrencies_currency_codes);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t8 := $tmp;
    call $t9 := $Vector_contains($Vector_type_value($IntegerType()), $t7, $t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t9);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(21, 2102, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t19);
    $t12 := $tmp;
    $tmp := $Integer(2);
    $t13 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(21, 2102, i#$Integer($t13));
    }

    $abort_code := i#$Integer($t13);
    goto Abort;

  L0:
    call $t14 := $BorrowLoc(2, config);
    call $t15 := $BorrowField($t14, $RegisteredCurrencies_RegisteredCurrencies_currency_codes);
    call config := $WritebackToValue($t14, 2, config);
    call $tmp := $ReadRef($t15);
    $t21 := $tmp;
    call $t21 := $Vector_push_back($Vector_type_value($IntegerType()), $t21, $t20);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $WriteRef($t15, $t21);
    call config := $WritebackToValue($t15, 2, config);
    call $t14 := $WritebackToReference($t15, $t14);
    call $tmp := $CopyOrMoveValue($t19);
    $t17 := $tmp;
    call $LibraConfig_set($RegisteredCurrencies_RegisteredCurrencies_type_value(), $t17, config);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $RegisteredCurrencies_add_currency_code_$direct_inter(lr_account: $Value, currency_code: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $RegisteredCurrencies_RegisteredCurrencies_type_value()], 1), $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $RegisteredCurrencies_RegisteredCurrencies_type_value()], 1), $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code)));
  ensures !$abort_flag ==> b#$Boolean($Vector_eq_push_back($Vector_type_value($IntegerType()), $RegisteredCurrencies_get_currency_codes($LibraConfig_LibraConfig_$memory), old($RegisteredCurrencies_get_currency_codes($LibraConfig_LibraConfig_$memory)), currency_code));



implementation {:inline 1} $RegisteredCurrencies_add_currency_code_$direct_inter(lr_account: $Value, currency_code: $Value)
{
    assume is#$Address(lr_account);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier333"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    call $RegisteredCurrencies_add_currency_code_$def(lr_account, currency_code);
}



procedure {:inline 1} $RegisteredCurrencies_add_currency_code_$direct_intra(lr_account: $Value, currency_code: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))));



implementation {:inline 1} $RegisteredCurrencies_add_currency_code_$direct_intra(lr_account: $Value, currency_code: $Value)
{
    assume is#$Address(lr_account);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier334"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    call $RegisteredCurrencies_add_currency_code_$def(lr_account, currency_code);
}



procedure {:inline 1} $RegisteredCurrencies_add_currency_code(lr_account: $Value, currency_code: $Value);



implementation {:inline 1} $RegisteredCurrencies_add_currency_code(lr_account: $Value, currency_code: $Value)
{
    assume is#$Address(lr_account);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier335"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    call $RegisteredCurrencies_add_currency_code_$def(lr_account, currency_code);
}



function {:inline} $FixedPoint32_spec_multiply_u64(val: $Value, multiplier: $Value) : $Value;

axiom (forall val: $Value, multiplier: $Value :: {:qid "quantifier336"} $IsValidU64($FixedPoint32_spec_multiply_u64(val, multiplier)));

function {:inline} $FixedPoint32_spec_divide_u64(val: $Value, divisor: $Value) : $Value;

axiom (forall val: $Value, divisor: $Value :: {:qid "quantifier337"} $IsValidU64($FixedPoint32_spec_divide_u64(val, divisor)));

function {:inline} $FixedPoint32_spec_create_from_rational(numerator: $Value, denominator: $Value) : $Value;

axiom (forall numerator: $Value, denominator: $Value :: {:qid "quantifier338"} $FixedPoint32_FixedPoint32_is_well_formed($FixedPoint32_spec_create_from_rational(numerator, denominator)));

const unique $FixedPoint32_FixedPoint32: $TypeName;

const $FixedPoint32_FixedPoint32_value: $FieldName;

axiom $FixedPoint32_FixedPoint32_value == 0;

function $FixedPoint32_FixedPoint32_type_value() : $TypeValue;

axiom $FixedPoint32_FixedPoint32_type_value(): $TypeValue == $StructType($FixedPoint32_FixedPoint32, $EmptyTypeValueArray);

var $FixedPoint32_FixedPoint32_$memory: $Memory;

var $FixedPoint32_FixedPoint32_$memory_$old: $Memory;

function {:inline} $FixedPoint32_FixedPoint32_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $FixedPoint32_FixedPoint32_value))
}

function {:inline} $FixedPoint32_FixedPoint32_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $FixedPoint32_FixedPoint32_value))
}

procedure {:inline 1} $FixedPoint32_FixedPoint32_pack($file_id: int, $byte_index: int, $var_idx: int, value: $Value) returns ($struct: $Value);



implementation {:inline 1} $FixedPoint32_FixedPoint32_pack($file_id: int, $byte_index: int, $var_idx: int, value: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(value);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := value], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $FixedPoint32_FixedPoint32_unpack($struct: $Value) returns (value: $Value);



implementation {:inline 1} $FixedPoint32_FixedPoint32_unpack($struct: $Value) returns (value: $Value)
{
    assume is#$Vector($struct);
    value := $SelectField($struct, $FixedPoint32_FixedPoint32_value);
    assume $IsValidU64(value);
}



procedure {:inline 1} $FixedPoint32_create_from_rational_$def(numerator: $Value, denominator: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_create_from_rational_$def(numerator: $Value, denominator: $Value) returns ($ret0: $Value)
{
  var quotient: $Value;
  var scaled_denominator: $Value;
  var scaled_numerator: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(11, 3072, 0, numerator);
    }

    if (true)
    {
        assume $DebugTrackLocal(11, 3072, 1, denominator);
    }

    call $tmp := $CopyOrMoveValue(numerator);
    $t32 := $tmp;
    call $tmp := $CopyOrMoveValue(denominator);
    $t33 := $tmp;
    call $tmp := $CastU128($t32);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 3364, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    $tmp := $Integer(64);
    $t10 := $tmp;
    call $tmp := $Shl($t9, $t10);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    scaled_numerator := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 3345, 4, $tmp);
    }

    call $tmp := $CastU128($t33);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 3424, $abort_code);
        goto Abort;
    }

    $t13 := $tmp;
    $tmp := $Integer(32);
    $t14 := $tmp;
    call $tmp := $Shl($t13, $t14);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    scaled_denominator := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 3403, 3, $tmp);
    }

    call $tmp := $Div(scaled_numerator, scaled_denominator);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 3587, $abort_code);
        goto Abort;
    }

    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    quotient := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 3559, 2, $tmp);
    }

    $tmp := $Integer(0);
    $t20 := $tmp;
    $tmp := $Boolean(!$IsEqual(quotient, $t20));
    $t21 := $tmp;
    $tmp := $t21;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $Boolean(true);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 3730, 7, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Integer(0);
    $t24 := $tmp;
    $tmp := $Boolean($IsEqual($t32, $t24));
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue($t25);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 3730, 7, $tmp);
    }

    goto L3;

  L3:
    call $tmp := $CopyOrMoveValue($t7);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 3723, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    $tmp := $Integer(0);
    $t28 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(11, 3723, i#$Integer($t28));
    }

    $abort_code := i#$Integer($t28);
    goto Abort;

  L4:
    call $tmp := $CastU64(quotient);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 3952, $abort_code);
        goto Abort;
    }

    $t30 := $tmp;
    call $tmp := $FixedPoint32_FixedPoint32_pack(0, 0, 0, $t30);
    $t31 := $tmp;
    $ret0 := $t31;
    if (true)
    {
        assume $DebugTrackLocal(11, 3930, 34, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $FixedPoint32_create_from_rational_$direct_inter(numerator: $Value, denominator: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_create_from_rational(numerator, denominator))));
  ensures $FixedPoint32_FixedPoint32_is_well_formed($ret0);



procedure {:inline 1} $FixedPoint32_create_from_rational_$direct_intra(numerator: $Value, denominator: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_create_from_rational(numerator, denominator))));
  ensures $FixedPoint32_FixedPoint32_is_well_formed($ret0);



procedure {:inline 1} $FixedPoint32_create_from_rational(numerator: $Value, denominator: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_create_from_rational(numerator, denominator))));
  ensures $FixedPoint32_FixedPoint32_is_well_formed($ret0);



procedure {:inline 1} $FixedPoint32_create_from_raw_value_$def(value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_create_from_raw_value_$def(value: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(11, 4211, 0, value);
    }

    call $tmp := $CopyOrMoveValue(value);
    $t3 := $tmp;
    call $tmp := $FixedPoint32_FixedPoint32_pack(0, 0, 0, $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(11, 4280, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $FixedPoint32_create_from_raw_value_$direct_inter(value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_create_from_raw_value_$direct_inter(value: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(value);
    call $ret0 := $FixedPoint32_create_from_raw_value_$def(value);
}



procedure {:inline 1} $FixedPoint32_create_from_raw_value_$direct_intra(value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_create_from_raw_value_$direct_intra(value: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(value);
    call $ret0 := $FixedPoint32_create_from_raw_value_$def(value);
}



procedure {:inline 1} $FixedPoint32_create_from_raw_value(value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_create_from_raw_value(value: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(value);
    call $ret0 := $FixedPoint32_create_from_raw_value_$def(value);
}



procedure {:inline 1} $FixedPoint32_divide_u64_$def(num: $Value, divisor: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_divide_u64_$def(num: $Value, divisor: $Value) returns ($ret0: $Value)
{
  var quotient: $Value;
  var scaled_value: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(11, 2025, 0, num);
    }

    if (true)
    {
        assume $DebugTrackLocal(11, 2025, 1, divisor);
    }

    call $tmp := $CopyOrMoveValue(num);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(divisor);
    $t17 := $tmp;
    call $tmp := $CastU128($t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 2230, $abort_code);
        goto Abort;
    }

    $t5 := $tmp;
    $tmp := $Integer(32);
    $t6 := $tmp;
    call $tmp := $Shl($t5, $t6);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    scaled_value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 2215, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t17);
    $t9 := $tmp;
    call $tmp := $GetFieldFromValue($t9, $FixedPoint32_FixedPoint32_value);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;
    call $tmp := $CastU128($t11);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 2344, $abort_code);
        goto Abort;
    }

    $t12 := $tmp;
    call $tmp := $Div(scaled_value, $t12);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 2342, $abort_code);
        goto Abort;
    }

    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    quotient := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 2318, 2, $tmp);
    }

    call $tmp := $CastU64(quotient);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 2487, $abort_code);
        goto Abort;
    }

    $t15 := $tmp;
    $ret0 := $t15;
    if (true)
    {
        assume $DebugTrackLocal(11, 2487, 18, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $FixedPoint32_divide_u64_$direct_inter(num: $Value, divisor: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_divide_u64(num, divisor))));
  ensures $IsValidU64($ret0);



procedure {:inline 1} $FixedPoint32_divide_u64_$direct_intra(num: $Value, divisor: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_divide_u64(num, divisor))));
  ensures $IsValidU64($ret0);



procedure {:inline 1} $FixedPoint32_divide_u64(num: $Value, divisor: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_divide_u64(num, divisor))));
  ensures $IsValidU64($ret0);



procedure {:inline 1} $FixedPoint32_get_raw_value_$def(num: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_get_raw_value_$def(num: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(11, 4494, 0, num);
    }

    call $tmp := $CopyOrMoveValue(num);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $FixedPoint32_FixedPoint32_value);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(11, 4553, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $FixedPoint32_get_raw_value_$direct_inter(num: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_get_raw_value_$direct_inter(num: $Value) returns ($ret0: $Value)
{
    assume $FixedPoint32_FixedPoint32_is_well_formed(num);
    call $ret0 := $FixedPoint32_get_raw_value_$def(num);
}



procedure {:inline 1} $FixedPoint32_get_raw_value_$direct_intra(num: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_get_raw_value_$direct_intra(num: $Value) returns ($ret0: $Value)
{
    assume $FixedPoint32_FixedPoint32_is_well_formed(num);
    call $ret0 := $FixedPoint32_get_raw_value_$def(num);
}



procedure {:inline 1} $FixedPoint32_get_raw_value(num: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_get_raw_value(num: $Value) returns ($ret0: $Value)
{
    assume $FixedPoint32_FixedPoint32_is_well_formed(num);
    call $ret0 := $FixedPoint32_get_raw_value_$def(num);
}



procedure {:inline 1} $FixedPoint32_multiply_u64_$def(num: $Value, multiplier: $Value) returns ($ret0: $Value);



implementation {:inline 1} $FixedPoint32_multiply_u64_$def(num: $Value, multiplier: $Value) returns ($ret0: $Value)
{
  var product: $Value;
  var unscaled_product: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(11, 445, 0, num);
    }

    if (true)
    {
        assume $DebugTrackLocal(11, 445, 1, multiplier);
    }

    call $tmp := $CopyOrMoveValue(num);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(multiplier);
    $t17 := $tmp;
    call $tmp := $CastU128($t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 729, $abort_code);
        goto Abort;
    }

    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t6 := $tmp;
    call $tmp := $GetFieldFromValue($t6, $FixedPoint32_FixedPoint32_value);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t8 := $tmp;
    call $tmp := $CastU128($t8);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 745, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $tmp := $MulU128($t5, $t9);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 743, $abort_code);
        goto Abort;
    }

    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    unscaled_product := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 710, 3, $tmp);
    }

    $tmp := $Integer(32);
    $t12 := $tmp;
    call $tmp := $Shr(unscaled_product, $t12);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    product := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(11, 918, 2, $tmp);
    }

    call $tmp := $CastU64(product);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(11, 1070, $abort_code);
        goto Abort;
    }

    $t15 := $tmp;
    $ret0 := $t15;
    if (true)
    {
        assume $DebugTrackLocal(11, 1070, 18, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $FixedPoint32_multiply_u64_$direct_inter(num: $Value, multiplier: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_multiply_u64(num, multiplier))));
  ensures $IsValidU64($ret0);



procedure {:inline 1} $FixedPoint32_multiply_u64_$direct_intra(num: $Value, multiplier: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_multiply_u64(num, multiplier))));
  ensures $IsValidU64($ret0);



procedure {:inline 1} $FixedPoint32_multiply_u64(num: $Value, multiplier: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_multiply_u64(num, multiplier))));
  ensures $IsValidU64($ret0);



function {:inline} $Libra_spec_has_burn_cap($Libra_BurnCapability_$memory: $Memory, $tv0: $TypeValue, addr: $Value) : $Value
{
  $ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)
}

function {:inline} $Libra_spec_market_cap($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue) : $Value
{
  $SelectField($ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)
}

function {:inline} $Libra_spec_is_currency($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue) : $Value
{
  $ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_spec_currency_info($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue) : $Value
{
  $ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_spec_approx_lbr_for_value($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue, value: $Value) : $Value
{
  $FixedPoint32_spec_multiply_u64(value, $SelectField($ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_to_lbr_exchange_rate))
}

function {:inline} $Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue) : $Value
{
  $Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_is_synthetic)))))
}

function {:inline} $Libra_spec_has_mint_capability($Libra_MintCapability_$memory: $Memory, $tv0: $TypeValue, addr1: $Value) : $Value
{
  $ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1)
}

const unique $Libra_Libra: $TypeName;

const $Libra_Libra_value: $FieldName;

axiom $Libra_Libra_value == 0;

function $Libra_Libra_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier339"} { $Libra_Libra_type_value($tv0): $TypeValue } $Libra_Libra_type_value($tv0): $TypeValue == $StructType($Libra_Libra, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $Libra_Libra_$memory: $Memory;

var $Libra_Libra_$memory_$old: $Memory;

function {:inline} $Libra_Libra_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $Libra_Libra_value))
}

function {:inline} $Libra_Libra_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $Libra_Libra_value))
}

procedure {:inline 1} $Libra_Libra_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, value: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_Libra_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, value: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(value);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := value], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_Libra_unpack($tv0: $TypeValue, $struct: $Value) returns (value: $Value);



implementation {:inline 1} $Libra_Libra_unpack($tv0: $TypeValue, $struct: $Value) returns (value: $Value)
{
    assume is#$Vector($struct);
    value := $SelectField($struct, $Libra_Libra_value);
    assume $IsValidU64(value);
}



const unique $Libra_BurnCapability: $TypeName;

const $Libra_BurnCapability_dummy_field: $FieldName;

axiom $Libra_BurnCapability_dummy_field == 0;

function $Libra_BurnCapability_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier340"} { $Libra_BurnCapability_type_value($tv0): $TypeValue } $Libra_BurnCapability_type_value($tv0): $TypeValue == $StructType($Libra_BurnCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $Libra_BurnCapability_$memory: $Memory;

var $Libra_BurnCapability_$memory_$old: $Memory;

function {:inline} $Libra_BurnCapability_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Libra_BurnCapability_dummy_field))
}

function {:inline} $Libra_BurnCapability_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Libra_BurnCapability_dummy_field))
}

procedure {:inline 1} $Libra_BurnCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_BurnCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_BurnCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $Libra_BurnCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Libra_BurnCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}



const unique $Libra_BurnEvent: $TypeName;

const $Libra_BurnEvent_amount: $FieldName;

axiom $Libra_BurnEvent_amount == 0;

const $Libra_BurnEvent_currency_code: $FieldName;

axiom $Libra_BurnEvent_currency_code == 1;

const $Libra_BurnEvent_preburn_address: $FieldName;

axiom $Libra_BurnEvent_preburn_address == 2;

function $Libra_BurnEvent_type_value() : $TypeValue;

axiom $Libra_BurnEvent_type_value(): $TypeValue == $StructType($Libra_BurnEvent, $EmptyTypeValueArray);

var $Libra_BurnEvent_$memory: $Memory;

var $Libra_BurnEvent_$memory_$old: $Memory;

function {:inline} $Libra_BurnEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $Libra_BurnEvent_amount)) && $Vector_is_well_formed($SelectField($this, $Libra_BurnEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier341"} { $select_vector($SelectField($this, $Libra_BurnEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_BurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_BurnEvent_currency_code), $$0))) && is#$Address($SelectField($this, $Libra_BurnEvent_preburn_address))
}

function {:inline} $Libra_BurnEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $Libra_BurnEvent_amount)) && $Vector_is_well_formed($SelectField($this, $Libra_BurnEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier342"} { $select_vector($SelectField($this, $Libra_BurnEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_BurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_BurnEvent_currency_code), $$0))) && is#$Address($SelectField($this, $Libra_BurnEvent_preburn_address))
}

procedure {:inline 1} $Libra_BurnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_BurnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier343"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    assume is#$Address(preburn_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := preburn_address], 3));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_BurnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value);



implementation {:inline 1} $Libra_BurnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_BurnEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_BurnEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier344"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    preburn_address := $SelectField($struct, $Libra_BurnEvent_preburn_address);
    assume is#$Address(preburn_address);
}



const unique $Libra_CancelBurnEvent: $TypeName;

const $Libra_CancelBurnEvent_amount: $FieldName;

axiom $Libra_CancelBurnEvent_amount == 0;

const $Libra_CancelBurnEvent_currency_code: $FieldName;

axiom $Libra_CancelBurnEvent_currency_code == 1;

const $Libra_CancelBurnEvent_preburn_address: $FieldName;

axiom $Libra_CancelBurnEvent_preburn_address == 2;

function $Libra_CancelBurnEvent_type_value() : $TypeValue;

axiom $Libra_CancelBurnEvent_type_value(): $TypeValue == $StructType($Libra_CancelBurnEvent, $EmptyTypeValueArray);

var $Libra_CancelBurnEvent_$memory: $Memory;

var $Libra_CancelBurnEvent_$memory_$old: $Memory;

function {:inline} $Libra_CancelBurnEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $Libra_CancelBurnEvent_amount)) && $Vector_is_well_formed($SelectField($this, $Libra_CancelBurnEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier345"} { $select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CancelBurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code), $$0))) && is#$Address($SelectField($this, $Libra_CancelBurnEvent_preburn_address))
}

function {:inline} $Libra_CancelBurnEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $Libra_CancelBurnEvent_amount)) && $Vector_is_well_formed($SelectField($this, $Libra_CancelBurnEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier346"} { $select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CancelBurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code), $$0))) && is#$Address($SelectField($this, $Libra_CancelBurnEvent_preburn_address))
}

procedure {:inline 1} $Libra_CancelBurnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_CancelBurnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier347"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    assume is#$Address(preburn_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := preburn_address], 3));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_CancelBurnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value);



implementation {:inline 1} $Libra_CancelBurnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_CancelBurnEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_CancelBurnEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier348"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    preburn_address := $SelectField($struct, $Libra_CancelBurnEvent_preburn_address);
    assume is#$Address(preburn_address);
}



const unique $Libra_CurrencyInfo: $TypeName;

const $Libra_CurrencyInfo_total_value: $FieldName;

axiom $Libra_CurrencyInfo_total_value == 0;

const $Libra_CurrencyInfo_preburn_value: $FieldName;

axiom $Libra_CurrencyInfo_preburn_value == 1;

const $Libra_CurrencyInfo_to_lbr_exchange_rate: $FieldName;

axiom $Libra_CurrencyInfo_to_lbr_exchange_rate == 2;

const $Libra_CurrencyInfo_is_synthetic: $FieldName;

axiom $Libra_CurrencyInfo_is_synthetic == 3;

const $Libra_CurrencyInfo_scaling_factor: $FieldName;

axiom $Libra_CurrencyInfo_scaling_factor == 4;

const $Libra_CurrencyInfo_fractional_part: $FieldName;

axiom $Libra_CurrencyInfo_fractional_part == 5;

const $Libra_CurrencyInfo_currency_code: $FieldName;

axiom $Libra_CurrencyInfo_currency_code == 6;

const $Libra_CurrencyInfo_can_mint: $FieldName;

axiom $Libra_CurrencyInfo_can_mint == 7;

const $Libra_CurrencyInfo_mint_events: $FieldName;

axiom $Libra_CurrencyInfo_mint_events == 8;

const $Libra_CurrencyInfo_burn_events: $FieldName;

axiom $Libra_CurrencyInfo_burn_events == 9;

const $Libra_CurrencyInfo_preburn_events: $FieldName;

axiom $Libra_CurrencyInfo_preburn_events == 10;

const $Libra_CurrencyInfo_cancel_burn_events: $FieldName;

axiom $Libra_CurrencyInfo_cancel_burn_events == 11;

const $Libra_CurrencyInfo_exchange_rate_update_events: $FieldName;

axiom $Libra_CurrencyInfo_exchange_rate_update_events == 12;

function $Libra_CurrencyInfo_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier349"} { $Libra_CurrencyInfo_type_value($tv0): $TypeValue } $Libra_CurrencyInfo_type_value($tv0): $TypeValue == $StructType($Libra_CurrencyInfo, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $Libra_CurrencyInfo_$memory: $Memory;

var $Libra_CurrencyInfo_$memory_$old: $Memory;

function {:inline} $Libra_CurrencyInfo_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 13 && $IsValidU128($SelectField($this, $Libra_CurrencyInfo_total_value)) && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_preburn_value)) && $FixedPoint32_FixedPoint32_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_to_lbr_exchange_rate)) && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_is_synthetic)) && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_scaling_factor)) && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_fractional_part)) && $Vector_is_well_formed($SelectField($this, $Libra_CurrencyInfo_currency_code)) && (forall $$0: int :: {:qid "quantifier350"} { $select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CurrencyInfo_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code), $$0))) && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_can_mint)) && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_mint_events)) && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_burn_events)) && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_preburn_events)) && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_cancel_burn_events)) && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_exchange_rate_update_events))
}

function {:inline} $Libra_CurrencyInfo_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 13 && $IsValidU128($SelectField($this, $Libra_CurrencyInfo_total_value)) && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_preburn_value)) && $FixedPoint32_FixedPoint32_is_well_formed($SelectField($this, $Libra_CurrencyInfo_to_lbr_exchange_rate)) && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_is_synthetic)) && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_scaling_factor)) && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_fractional_part)) && $Vector_is_well_formed($SelectField($this, $Libra_CurrencyInfo_currency_code)) && (forall $$0: int :: {:qid "quantifier351"} { $select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CurrencyInfo_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code), $$0))) && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_can_mint)) && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_mint_events)) && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_burn_events)) && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_preburn_events)) && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_cancel_burn_events)) && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_exchange_rate_update_events))
}

procedure {:inline 1} $Libra_CurrencyInfo_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, total_value: $Value, preburn_value: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value, can_mint: $Value, mint_events: $Value, burn_events: $Value, preburn_events: $Value, cancel_burn_events: $Value, exchange_rate_update_events: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_CurrencyInfo_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, total_value: $Value, preburn_value: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value, can_mint: $Value, mint_events: $Value, burn_events: $Value, preburn_events: $Value, cancel_burn_events: $Value, exchange_rate_update_events: $Value) returns ($struct: $Value)
{
    assume $IsValidU128(total_value);
    assume $IsValidU64(preburn_value);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    assume is#$Boolean(is_synthetic);
    assume $IsValidU64(scaling_factor);
    assume $IsValidU64(fractional_part);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier352"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    assume is#$Boolean(can_mint);
    assume $Event_EventHandle_is_well_formed(mint_events);
    assume $Event_EventHandle_is_well_formed(burn_events);
    assume $Event_EventHandle_is_well_formed(preburn_events);
    assume $Event_EventHandle_is_well_formed(cancel_burn_events);
    assume $Event_EventHandle_is_well_formed(exchange_rate_update_events);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := total_value][1 := preburn_value][2 := to_lbr_exchange_rate][3 := is_synthetic][4 := scaling_factor][5 := fractional_part][6 := currency_code][7 := can_mint][8 := mint_events][9 := burn_events][10 := preburn_events][11 := cancel_burn_events][12 := exchange_rate_update_events], 13));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_CurrencyInfo_unpack($tv0: $TypeValue, $struct: $Value) returns (total_value: $Value, preburn_value: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value, can_mint: $Value, mint_events: $Value, burn_events: $Value, preburn_events: $Value, cancel_burn_events: $Value, exchange_rate_update_events: $Value);



implementation {:inline 1} $Libra_CurrencyInfo_unpack($tv0: $TypeValue, $struct: $Value) returns (total_value: $Value, preburn_value: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value, can_mint: $Value, mint_events: $Value, burn_events: $Value, preburn_events: $Value, cancel_burn_events: $Value, exchange_rate_update_events: $Value)
{
    assume is#$Vector($struct);
    total_value := $SelectField($struct, $Libra_CurrencyInfo_total_value);
    assume $IsValidU128(total_value);
    preburn_value := $SelectField($struct, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64(preburn_value);
    to_lbr_exchange_rate := $SelectField($struct, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    is_synthetic := $SelectField($struct, $Libra_CurrencyInfo_is_synthetic);
    assume is#$Boolean(is_synthetic);
    scaling_factor := $SelectField($struct, $Libra_CurrencyInfo_scaling_factor);
    assume $IsValidU64(scaling_factor);
    fractional_part := $SelectField($struct, $Libra_CurrencyInfo_fractional_part);
    assume $IsValidU64(fractional_part);
    currency_code := $SelectField($struct, $Libra_CurrencyInfo_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier353"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    can_mint := $SelectField($struct, $Libra_CurrencyInfo_can_mint);
    assume is#$Boolean(can_mint);
    mint_events := $SelectField($struct, $Libra_CurrencyInfo_mint_events);
    assume $Event_EventHandle_is_well_formed(mint_events);
    burn_events := $SelectField($struct, $Libra_CurrencyInfo_burn_events);
    assume $Event_EventHandle_is_well_formed(burn_events);
    preburn_events := $SelectField($struct, $Libra_CurrencyInfo_preburn_events);
    assume $Event_EventHandle_is_well_formed(preburn_events);
    cancel_burn_events := $SelectField($struct, $Libra_CurrencyInfo_cancel_burn_events);
    assume $Event_EventHandle_is_well_formed(cancel_burn_events);
    exchange_rate_update_events := $SelectField($struct, $Libra_CurrencyInfo_exchange_rate_update_events);
    assume $Event_EventHandle_is_well_formed(exchange_rate_update_events);
}



const unique $Libra_MintCapability: $TypeName;

const $Libra_MintCapability_dummy_field: $FieldName;

axiom $Libra_MintCapability_dummy_field == 0;

function $Libra_MintCapability_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier354"} { $Libra_MintCapability_type_value($tv0): $TypeValue } $Libra_MintCapability_type_value($tv0): $TypeValue == $StructType($Libra_MintCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $Libra_MintCapability_$memory: $Memory;

var $Libra_MintCapability_$memory_$old: $Memory;

function {:inline} $Libra_MintCapability_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Libra_MintCapability_dummy_field))
}

function {:inline} $Libra_MintCapability_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Libra_MintCapability_dummy_field))
}

procedure {:inline 1} $Libra_MintCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_MintCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_MintCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $Libra_MintCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Libra_MintCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}



const unique $Libra_MintEvent: $TypeName;

const $Libra_MintEvent_amount: $FieldName;

axiom $Libra_MintEvent_amount == 0;

const $Libra_MintEvent_currency_code: $FieldName;

axiom $Libra_MintEvent_currency_code == 1;

function $Libra_MintEvent_type_value() : $TypeValue;

axiom $Libra_MintEvent_type_value(): $TypeValue == $StructType($Libra_MintEvent, $EmptyTypeValueArray);

var $Libra_MintEvent_$memory: $Memory;

var $Libra_MintEvent_$memory_$old: $Memory;

function {:inline} $Libra_MintEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $IsValidU64($SelectField($this, $Libra_MintEvent_amount)) && $Vector_is_well_formed($SelectField($this, $Libra_MintEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier355"} { $select_vector($SelectField($this, $Libra_MintEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_MintEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_MintEvent_currency_code), $$0)))
}

function {:inline} $Libra_MintEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $IsValidU64($SelectField($this, $Libra_MintEvent_amount)) && $Vector_is_well_formed($SelectField($this, $Libra_MintEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier356"} { $select_vector($SelectField($this, $Libra_MintEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_MintEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_MintEvent_currency_code), $$0)))
}

procedure {:inline 1} $Libra_MintEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_MintEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier357"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_MintEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value);



implementation {:inline 1} $Libra_MintEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_MintEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_MintEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier358"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
}



const unique $Libra_Preburn: $TypeName;

const $Libra_Preburn_to_burn: $FieldName;

axiom $Libra_Preburn_to_burn == 0;

function $Libra_Preburn_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier359"} { $Libra_Preburn_type_value($tv0): $TypeValue } $Libra_Preburn_type_value($tv0): $TypeValue == $StructType($Libra_Preburn, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $Libra_Preburn_$memory: $Memory;

var $Libra_Preburn_$memory_$old: $Memory;

function {:inline} $Libra_Preburn_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Libra_Libra_is_well_formed_types($SelectField($this, $Libra_Preburn_to_burn))
}

function {:inline} $Libra_Preburn_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Libra_Libra_is_well_formed($SelectField($this, $Libra_Preburn_to_burn))
}

procedure {:inline 1} $Libra_Preburn_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, to_burn: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_Preburn_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, to_burn: $Value) returns ($struct: $Value)
{
    assume $Libra_Libra_is_well_formed(to_burn);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := to_burn], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_Preburn_unpack($tv0: $TypeValue, $struct: $Value) returns (to_burn: $Value);



implementation {:inline 1} $Libra_Preburn_unpack($tv0: $TypeValue, $struct: $Value) returns (to_burn: $Value)
{
    assume is#$Vector($struct);
    to_burn := $SelectField($struct, $Libra_Preburn_to_burn);
    assume $Libra_Libra_is_well_formed(to_burn);
}



const unique $Libra_PreburnEvent: $TypeName;

const $Libra_PreburnEvent_amount: $FieldName;

axiom $Libra_PreburnEvent_amount == 0;

const $Libra_PreburnEvent_currency_code: $FieldName;

axiom $Libra_PreburnEvent_currency_code == 1;

const $Libra_PreburnEvent_preburn_address: $FieldName;

axiom $Libra_PreburnEvent_preburn_address == 2;

function $Libra_PreburnEvent_type_value() : $TypeValue;

axiom $Libra_PreburnEvent_type_value(): $TypeValue == $StructType($Libra_PreburnEvent, $EmptyTypeValueArray);

var $Libra_PreburnEvent_$memory: $Memory;

var $Libra_PreburnEvent_$memory_$old: $Memory;

function {:inline} $Libra_PreburnEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $Libra_PreburnEvent_amount)) && $Vector_is_well_formed($SelectField($this, $Libra_PreburnEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier360"} { $select_vector($SelectField($this, $Libra_PreburnEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_PreburnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_PreburnEvent_currency_code), $$0))) && is#$Address($SelectField($this, $Libra_PreburnEvent_preburn_address))
}

function {:inline} $Libra_PreburnEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $Libra_PreburnEvent_amount)) && $Vector_is_well_formed($SelectField($this, $Libra_PreburnEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier361"} { $select_vector($SelectField($this, $Libra_PreburnEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_PreburnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_PreburnEvent_currency_code), $$0))) && is#$Address($SelectField($this, $Libra_PreburnEvent_preburn_address))
}

procedure {:inline 1} $Libra_PreburnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_PreburnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier362"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    assume is#$Address(preburn_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := preburn_address], 3));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_PreburnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value);



implementation {:inline 1} $Libra_PreburnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_PreburnEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_PreburnEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier363"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    preburn_address := $SelectField($struct, $Libra_PreburnEvent_preburn_address);
    assume is#$Address(preburn_address);
}



const unique $Libra_RegisterNewCurrency: $TypeName;

const $Libra_RegisterNewCurrency_dummy_field: $FieldName;

axiom $Libra_RegisterNewCurrency_dummy_field == 0;

function $Libra_RegisterNewCurrency_type_value() : $TypeValue;

axiom $Libra_RegisterNewCurrency_type_value(): $TypeValue == $StructType($Libra_RegisterNewCurrency, $EmptyTypeValueArray);

var $Libra_RegisterNewCurrency_$memory: $Memory;

var $Libra_RegisterNewCurrency_$memory_$old: $Memory;

function {:inline} $Libra_RegisterNewCurrency_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Libra_RegisterNewCurrency_dummy_field))
}

function {:inline} $Libra_RegisterNewCurrency_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Libra_RegisterNewCurrency_dummy_field))
}

procedure {:inline 1} $Libra_RegisterNewCurrency_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_RegisterNewCurrency_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_RegisterNewCurrency_unpack($struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $Libra_RegisterNewCurrency_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Libra_RegisterNewCurrency_dummy_field);
    assume is#$Boolean(dummy_field);
}



const unique $Libra_ToLBRExchangeRateUpdateEvent: $TypeName;

const $Libra_ToLBRExchangeRateUpdateEvent_currency_code: $FieldName;

axiom $Libra_ToLBRExchangeRateUpdateEvent_currency_code == 0;

const $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate: $FieldName;

axiom $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate == 1;

function $Libra_ToLBRExchangeRateUpdateEvent_type_value() : $TypeValue;

axiom $Libra_ToLBRExchangeRateUpdateEvent_type_value(): $TypeValue == $StructType($Libra_ToLBRExchangeRateUpdateEvent, $EmptyTypeValueArray);

var $Libra_ToLBRExchangeRateUpdateEvent_$memory: $Memory;

var $Libra_ToLBRExchangeRateUpdateEvent_$memory_$old: $Memory;

function {:inline} $Libra_ToLBRExchangeRateUpdateEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $Vector_is_well_formed($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier364"} { $select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code), $$0))) && $IsValidU64($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate))
}

function {:inline} $Libra_ToLBRExchangeRateUpdateEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $Vector_is_well_formed($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier365"} { $select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code), $$0))) && $IsValidU64($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate))
}

procedure {:inline 1} $Libra_ToLBRExchangeRateUpdateEvent_pack($file_id: int, $byte_index: int, $var_idx: int, currency_code: $Value, new_to_lbr_exchange_rate: $Value) returns ($struct: $Value);



implementation {:inline 1} $Libra_ToLBRExchangeRateUpdateEvent_pack($file_id: int, $byte_index: int, $var_idx: int, currency_code: $Value, new_to_lbr_exchange_rate: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier366"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    assume $IsValidU64(new_to_lbr_exchange_rate);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := currency_code][1 := new_to_lbr_exchange_rate], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Libra_ToLBRExchangeRateUpdateEvent_unpack($struct: $Value) returns (currency_code: $Value, new_to_lbr_exchange_rate: $Value);



implementation {:inline 1} $Libra_ToLBRExchangeRateUpdateEvent_unpack($struct: $Value) returns (currency_code: $Value, new_to_lbr_exchange_rate: $Value)
{
    assume is#$Vector($struct);
    currency_code := $SelectField($struct, $Libra_ToLBRExchangeRateUpdateEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier367"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    new_to_lbr_exchange_rate := $SelectField($struct, $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate);
    assume $IsValidU64(new_to_lbr_exchange_rate);
}



procedure {:inline 1} $Libra_initialize_$def(config_account: $Value);



implementation {:inline 1} $Libra_initialize_$def(config_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 10208, 0, config_account);
    }

    call $tmp := $CopyOrMoveValue(config_account);
    $t17 := $tmp;
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 10280, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t17);
    $t7 := $tmp;
    $tmp := $Integer(0);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 10280, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t17);
    $t9 := $tmp;
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 10374, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t17);
    $t14 := $tmp;
    $tmp := $Integer(1);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 10374, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t17);
    $t16 := $tmp;
    call $RegisteredCurrencies_initialize($t16);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_initialize_$direct_inter(config_account: $Value);



implementation {:inline 1} $Libra_initialize_$direct_inter(config_account: $Value)
{
    assume is#$Address(config_account);
    call $Libra_initialize_$def(config_account);
}



procedure {:inline 1} $Libra_initialize_$direct_intra(config_account: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier368"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier369"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier370"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier371"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier372"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier373"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier374"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_initialize_$direct_intra(config_account: $Value)
{
    assume is#$Address(config_account);
    call $Libra_initialize_$def(config_account);
}



procedure {:inline 1} $Libra_initialize(config_account: $Value);



implementation {:inline 1} $Libra_initialize(config_account: $Value)
{
    assume is#$Address(config_account);
    call $Libra_initialize_$def(config_account);
}



procedure {:inline 1} $Libra_currency_code_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_currency_code_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 37667, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_currency_code);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(15, 37665, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_currency_code_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_currency_code))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier375"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $Libra_currency_code_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier376"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier377"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier378"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier379"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier380"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier381"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier382"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_currency_code))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier383"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier384"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier385"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier386"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier387"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier388"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier389"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier390"} is#$Type(coin_type) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier391"} is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1))))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier392"} is#$Type(coin_type) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier393"} is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr1))))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)))))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier394"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $Libra_currency_code($tv0: $TypeValue) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_currency_code))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier395"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $Libra_value_$def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_value_$def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 26579, 0, coin);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Libra_Libra_value);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(15, 26645, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_value_$direct_inter($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_value_$direct_inter($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $ret0 := $Libra_value_$def($tv0, coin);
}



procedure {:inline 1} $Libra_value_$direct_intra($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier396"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier397"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier398"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier399"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier400"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier401"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier402"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_value_$direct_intra($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $ret0 := $Libra_value_$def($tv0, coin);
}



procedure {:inline 1} $Libra_value($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_value($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $ret0 := $Libra_value_$def($tv0, coin);
}



procedure {:inline 1} $Libra_approx_lbr_for_coin_$def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_approx_lbr_for_coin_$def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
  var from_value: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 35804, 0, coin);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;
    call $t3 := $Libra_value($tv0, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t3);
    from_value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 35922, 1, $tmp);
    }

    call $t5 := $Libra_approx_lbr_for_value($tv0, from_value);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t5;
    if (true)
    {
        assume $DebugTrackLocal(15, 35956, 7, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_approx_lbr_for_coin_$direct_inter($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_approx_lbr_for_coin_$direct_inter($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $ret0 := $Libra_approx_lbr_for_coin_$def($tv0, coin);
}



procedure {:inline 1} $Libra_approx_lbr_for_coin_$direct_intra($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier403"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier404"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier405"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier406"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier407"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier408"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier409"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_approx_lbr_for_coin_$direct_intra($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $ret0 := $Libra_approx_lbr_for_coin_$def($tv0, coin);
}



procedure {:inline 1} $Libra_approx_lbr_for_coin($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_approx_lbr_for_coin($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $ret0 := $Libra_approx_lbr_for_coin_$def($tv0, coin);
}



procedure {:inline 1} $Libra_approx_lbr_for_value_$def($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_approx_lbr_for_value_$def($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value)
{
  var lbr_exchange_rate: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 35386, 0, from_value);
    }

    call $tmp := $CopyOrMoveValue(from_value);
    $t6 := $tmp;
    call $t2 := $Libra_lbr_exchange_rate($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t2);
    lbr_exchange_rate := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 35494, 1, $tmp);
    }

    call $t5 := $FixedPoint32_multiply_u64($t6, lbr_exchange_rate);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t5;
    if (true)
    {
        assume $DebugTrackLocal(15, 35557, 7, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_approx_lbr_for_value_$direct_inter($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_approx_lbr_for_value_$direct_inter($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(from_value);
    call $ret0 := $Libra_approx_lbr_for_value_$def($tv0, from_value);
}



procedure {:inline 1} $Libra_approx_lbr_for_value_$direct_intra($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier410"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier411"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier412"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier413"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier414"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier415"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier416"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_approx_lbr_for_value_$direct_intra($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(from_value);
    call $ret0 := $Libra_approx_lbr_for_value_$def($tv0, from_value);
}



procedure {:inline 1} $Libra_approx_lbr_for_value($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_approx_lbr_for_value($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(from_value);
    call $ret0 := $Libra_approx_lbr_for_value_$def($tv0, from_value);
}



procedure {:inline 1} $Libra_assert_is_SCS_currency_$def($tv0: $TypeValue);



implementation {:inline 1} $Libra_assert_is_SCS_currency_$def($tv0: $TypeValue)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t2 := $Libra_is_SCS_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t2);
    $t0 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 40887, 0, $tmp);
    }

    $tmp := $t0;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(9);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 40887, i#$Integer($t4));
    }

    $abort_code := i#$Integer($t4);
    goto Abort;

  L0:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_assert_is_SCS_currency_$direct_intra($tv0: $TypeValue);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier417"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier418"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier419"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier420"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier421"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier422"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier423"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_assert_is_SCS_currency_$direct_intra($tv0: $TypeValue)
{
    call $Libra_assert_is_SCS_currency_$def($tv0);
}



procedure {:inline 1} $Libra_assert_is_SCS_currency($tv0: $TypeValue);



implementation {:inline 1} $Libra_assert_is_SCS_currency($tv0: $TypeValue)
{
    call $Libra_assert_is_SCS_currency_$def($tv0);
}



procedure {:inline 1} $Libra_assert_is_currency_$def($tv0: $TypeValue);



implementation {:inline 1} $Libra_assert_is_currency_$def($tv0: $TypeValue)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t2 := $Libra_is_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t2);
    $t0 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 40744, 0, $tmp);
    }

    $tmp := $t0;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(8);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 40744, i#$Integer($t4));
    }

    $abort_code := i#$Integer($t4);
    goto Abort;

  L0:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_assert_is_currency_$direct_intra($tv0: $TypeValue);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier424"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier425"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier426"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier427"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier428"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier429"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier430"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_assert_is_currency_$direct_intra($tv0: $TypeValue)
{
    call $Libra_assert_is_currency_$def($tv0);
}



procedure {:inline 1} $Libra_assert_is_currency($tv0: $TypeValue);



implementation {:inline 1} $Libra_assert_is_currency($tv0: $TypeValue)
{
    call $Libra_assert_is_currency_$def($tv0);
}



procedure {:inline 1} $Libra_burn_$def($tv0: $TypeValue, account: $Value, preburn_address: $Value);



implementation {:inline 1} $Libra_burn_$def($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 12702, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 12702, 1, preburn_address);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_BurnCapability_$memory, $t4, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 12914, $abort_code);
        goto Abort;
    }

    $t5 := $tmp;
    call $Libra_burn_with_capability($tv0, $t7, $t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_burn_$direct_inter($tv0: $TypeValue, account: $Value, preburn_address: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account))))));



implementation {:inline 1} $Libra_burn_$direct_inter($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $Libra_burn_$def($tv0, account, preburn_address);
}



procedure {:inline 1} $Libra_burn_$direct_intra($tv0: $TypeValue, account: $Value, preburn_address: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier431"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier432"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier433"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier434"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier435"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier436"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier437"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_burn_$direct_intra($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $Libra_burn_$def($tv0, account, preburn_address);
}



procedure {:inline 1} $Libra_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value);



implementation {:inline 1} $Libra_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $Libra_burn_$def($tv0, account, preburn_address);
}



procedure {:inline 1} $Libra_burn_with_capability_$def($tv0: $TypeValue, preburn_address: $Value, capability: $Value);



implementation {:inline 1} $Libra_burn_with_capability_$def($tv0: $TypeValue, preburn_address: $Value, capability: $Value)
{
  var $t2: $Value;
  var $t3: $Mutation;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 20730, 0, preburn_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 20730, 1, capability);
    }

    call $tmp := $CopyOrMoveValue(preburn_address);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue(capability);
    $t7 := $tmp;
    call $t3 := $BorrowGlobal($Libra_Preburn_$memory, $t6, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 20992, $abort_code);
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t5 := $tmp;
    call $tmp := $ReadRef($t3);
    $t8 := $tmp;
    call $t8 := $Libra_burn_with_resource_cap($tv0, $t8, $t6, $t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t3 := $WriteRef($t3, $t8);
    call $Libra_Preburn_$memory := $WritebackToGlobal($Libra_Preburn_$memory, $t3);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_burn_with_capability_$direct_inter($tv0: $TypeValue, preburn_address: $Value, capability: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean($IsEqual($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) - i#$Integer($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)))) < i#$Integer($Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) - i#$Integer($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)))) < i#$Integer($Integer(0))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address))))) || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean($IsEqual($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) - i#$Integer($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)))) < i#$Integer($Integer(0))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) - i#$Integer($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)))) < i#$Integer($Integer(0)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) - i#$Integer(old($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))) - i#$Integer(old($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)))))));



implementation {:inline 1} $Libra_burn_with_capability_$direct_inter($tv0: $TypeValue, preburn_address: $Value, capability: $Value)
{
    assume is#$Address(preburn_address);
    assume $Libra_BurnCapability_is_well_formed(capability);
    call $Libra_burn_with_capability_$def($tv0, preburn_address, capability);
}



procedure {:inline 1} $Libra_burn_with_capability_$direct_intra($tv0: $TypeValue, preburn_address: $Value, capability: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier438"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier439"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier440"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier441"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier442"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier443"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier444"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_burn_with_capability_$direct_intra($tv0: $TypeValue, preburn_address: $Value, capability: $Value)
{
    assume is#$Address(preburn_address);
    assume $Libra_BurnCapability_is_well_formed(capability);
    call $Libra_burn_with_capability_$def($tv0, preburn_address, capability);
}



procedure {:inline 1} $Libra_burn_with_capability($tv0: $TypeValue, preburn_address: $Value, capability: $Value);



implementation {:inline 1} $Libra_burn_with_capability($tv0: $TypeValue, preburn_address: $Value, capability: $Value)
{
    assume is#$Address(preburn_address);
    assume $Libra_BurnCapability_is_well_formed(capability);
    call $Libra_burn_with_capability_$def($tv0, preburn_address, capability);
}



procedure {:inline 1} $Libra_burn_with_resource_cap_$def($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_burn_with_resource_cap_$def($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
  var currency_code: $Value;
  var info: $Mutation;
  var $t5: $Value;
  var $t6: $Value;
  var value: $Value;
  var $t8: $Value;
  var $t9: $Mutation;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Mutation;
  var $t19: $Mutation;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Mutation;
  var $t24: $Mutation;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Mutation;
  var $t31: $Mutation;
  var $t32: $Mutation;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Mutation;
  var $t38: $Mutation;
  var $t39: $Mutation;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Mutation;
  var $t44: $Mutation;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Mutation;
  var $t50: $Value;
  var $t51: $Mutation;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 21864, 0, preburn);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 21864, 1, preburn_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 21864, 2, _capability);
    }

    call $tmp := $CopyOrMoveValue(preburn);
    $t50 := $tmp;
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t52 := $tmp;
    call $tmp := $CopyOrMoveValue(_capability);
    $t53 := $tmp;
    call $t51 := $BorrowLoc(50, $t50);
    call $t8 := $Libra_currency_code($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    currency_code := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 22073, 3, $tmp);
    }

    call $t9 := $CopyOrMoveRef($t51);
    call $tmp := $GetFieldFromReference($t9, $Libra_Preburn_to_burn);
    $t10 := $tmp;
    call $t51 := $WritebackToReference($t9, $t51);
    call $tmp := $GetFieldFromValue($t10, $Libra_Libra_value);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t12 := $tmp;
    $tmp := $Integer(0);
    $t13 := $tmp;
    call $tmp := $Gt($t12, $t13);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 22176, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t16 := $CopyOrMoveRef($t51);
    call $t50 := $WritebackToValue($t16, 50, $t50);
    $tmp := $Integer(7);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 22176, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L0:
    call $t18 := $CopyOrMoveRef($t51);
    call $t19 := $BorrowField($t18, $Libra_Preburn_to_burn);
    call $t50 := $WritebackToValue($t18, 50, $t50);
    call $tmp := $ReadRef($t19);
    $t55 := $tmp;
    call $t20, $t55 := $Libra_withdraw_all($tv0, $t55);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $WriteRef($t19, $t55);
    if (true)
    {
        assume $DebugTrackLocal(15, 21864, 4, $Dereference(info));
    }

    call $t50 := $WritebackToValue($t19, 50, $t50);
    call $t18 := $WritebackToReference($t19, $t18);
    call $t21 := $Libra_Libra_unpack($tv0, $t20);
    $t21 := $t21;
    call $tmp := $CopyOrMoveValue($t21);
    value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 22278, 7, $tmp);
    }

    call $t22 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t23 := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t22, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 22386, $abort_code);
        goto Abort;
    }

    call info := $CopyOrMoveRef($t23);
    if (true)
    {
        assume $DebugTrackLocal(15, 22379, 4, $Dereference(info));
    }

    call $t24 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t24, $Libra_CurrencyInfo_total_value);
    $t25 := $tmp;
    call info := $WritebackToReference($t24, info);
    call $tmp := $CopyOrMoveValue($t25);
    $t26 := $tmp;
    call $tmp := $CastU128(value);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 22515, $abort_code);
        goto Abort;
    }

    $t28 := $tmp;
    call $tmp := $Sub($t26, $t28);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 22513, $abort_code);
        goto Abort;
    }

    $t29 := $tmp;
    call $t30 := $CopyOrMoveRef(info);
    call $t31 := $BorrowField($t30, $Libra_CurrencyInfo_total_value);
    call info := $WritebackToReference($t30, info);
    call $t31 := $WriteRef($t31, $t29);
    if (true)
    {
        assume $DebugTrackLocal(15, 22477, 4, $Dereference(info));
    }

    call info := $WritebackToReference($t31, info);
    call $t30 := $WritebackToReference($t31, $t30);
    call $t32 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t32, $Libra_CurrencyInfo_preburn_value);
    $t33 := $tmp;
    call info := $WritebackToReference($t32, info);
    call $tmp := $CopyOrMoveValue($t33);
    $t34 := $tmp;
    call $tmp := $Sub($t34, value);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 22580, $abort_code);
        goto Abort;
    }

    $t36 := $tmp;
    call $t37 := $CopyOrMoveRef(info);
    call $t38 := $BorrowField($t37, $Libra_CurrencyInfo_preburn_value);
    call info := $WritebackToReference($t37, info);
    call $t38 := $WriteRef($t38, $t36);
    if (true)
    {
        assume $DebugTrackLocal(15, 22540, 4, $Dereference(info));
    }

    call info := $WritebackToReference($t38, info);
    call $t37 := $WritebackToReference($t38, $t37);
    call $t39 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t39, $Libra_CurrencyInfo_is_synthetic);
    $t40 := $tmp;
    call info := $WritebackToReference($t39, info);
    call $tmp := $CopyOrMoveValue($t40);
    $t41 := $tmp;
    call $tmp := $Not($t41);
    $t42 := $tmp;
    $tmp := $t42;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $t43 := $CopyOrMoveRef(info);
    call $t44 := $BorrowField($t43, $Libra_CurrencyInfo_burn_events);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t43);
    call $tmp := $Libra_BurnEvent_pack(0, 0, 0, value, currency_code, $t52);
    $t48 := $tmp;
    call $tmp := $ReadRef($t44);
    $t54 := $tmp;
    call $t54 := $Event_emit_event($Libra_BurnEvent_type_value(), $t54, $t48);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t44 := $WriteRef($t44, $t54);
    if (true)
    {
        assume $DebugTrackLocal(15, 21864, 4, $Dereference(info));
    }

    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t44);
    call $t43 := $WritebackToReference($t44, $t43);
    goto L5;

  L4:
    call $t49 := $CopyOrMoveRef(info);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t49);
    goto L5;

  L5:
    $ret0 := $t50;
    if (true)
    {
        assume $DebugTrackLocal(15, 22929, 56, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_burn_with_resource_cap_$direct_inter($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean($IsEqual($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) - i#$Integer($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value)))) < i#$Integer($Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) - i#$Integer($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value)))) < i#$Integer($Integer(0))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean($IsEqual($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) - i#$Integer($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value)))) < i#$Integer($Integer(0))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) - i#$Integer($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value)))) < i#$Integer($Integer(0)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) - i#$Integer(old($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value)))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))) - i#$Integer(old($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value)))))));



implementation {:inline 1} $Libra_burn_with_resource_cap_$direct_inter($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume $Libra_Preburn_is_well_formed(preburn);
    assume is#$Address(preburn_address);
    assume $Libra_BurnCapability_is_well_formed(_capability);
    call $ret0 := $Libra_burn_with_resource_cap_$def($tv0, preburn, preburn_address, _capability);
}



procedure {:inline 1} $Libra_burn_with_resource_cap_$direct_intra($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier445"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier446"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier447"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier448"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier449"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier450"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier451"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_burn_with_resource_cap_$direct_intra($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume $Libra_Preburn_is_well_formed(preburn);
    assume is#$Address(preburn_address);
    assume $Libra_BurnCapability_is_well_formed(_capability);
    call $ret0 := $Libra_burn_with_resource_cap_$def($tv0, preburn, preburn_address, _capability);
}



procedure {:inline 1} $Libra_burn_with_resource_cap($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_burn_with_resource_cap($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume $Libra_Preburn_is_well_formed(preburn);
    assume is#$Address(preburn_address);
    assume $Libra_BurnCapability_is_well_formed(_capability);
    call $ret0 := $Libra_burn_with_resource_cap_$def($tv0, preburn, preburn_address, _capability);
}



procedure {:inline 1} $Libra_cancel_burn_$def($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_cancel_burn_$def($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 13586, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 13586, 1, preburn_address);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_BurnCapability_$memory, $t4, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 13829, $abort_code);
        goto Abort;
    }

    $t5 := $tmp;
    call $t6 := $Libra_cancel_burn_with_capability($tv0, $t8, $t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t6;
    if (true)
    {
        assume $DebugTrackLocal(15, 13759, 9, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_cancel_burn_$direct_inter($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_cancel_burn_$direct_inter($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $ret0 := $Libra_cancel_burn_$def($tv0, account, preburn_address);
}



procedure {:inline 1} $Libra_cancel_burn_$direct_intra($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier452"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier453"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier454"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier455"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier456"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier457"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier458"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_cancel_burn_$direct_intra($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $ret0 := $Libra_cancel_burn_$def($tv0, account, preburn_address);
}



procedure {:inline 1} $Libra_cancel_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_cancel_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $ret0 := $Libra_cancel_burn_$def($tv0, account, preburn_address);
}



procedure {:inline 1} $Libra_cancel_burn_with_capability_$def($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_cancel_burn_with_capability_$def($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
  var amount: $Value;
  var coin: $Value;
  var currency_code: $Value;
  var info: $Mutation;
  var preburn: $Mutation;
  var $t7: $Value;
  var $t8: $Mutation;
  var $t9: $Mutation;
  var $t10: $Mutation;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Mutation;
  var $t23: $Mutation;
  var $t24: $Mutation;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Mutation;
  var $t29: $Mutation;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Mutation;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 24172, 0, preburn_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 24172, 1, _capability);
    }

    call $tmp := $CopyOrMoveValue(preburn_address);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue(_capability);
    $t37 := $tmp;
    call $t8 := $BorrowGlobal($Libra_Preburn_$memory, $t36, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 24429, $abort_code);
        goto Abort;
    }

    call preburn := $CopyOrMoveRef($t8);
    if (true)
    {
        assume $DebugTrackLocal(15, 24419, 6, $Dereference(preburn));
    }

    call $t9 := $CopyOrMoveRef(preburn);
    call $t10 := $BorrowField($t9, $Libra_Preburn_to_burn);
    call $Libra_Preburn_$memory := $WritebackToGlobal($Libra_Preburn_$memory, $t9);
    call $tmp := $ReadRef($t10);
    $t39 := $tmp;
    call $t11, $t39 := $Libra_withdraw_all($tv0, $t39);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t10 := $WriteRef($t10, $t39);
    if (true)
    {
        assume $DebugTrackLocal(15, 25275, 5, $Dereference(info));
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 25275, 6, $Dereference(preburn));
    }

    call $Libra_Preburn_$memory := $WritebackToGlobal($Libra_Preburn_$memory, $t10);
    call $t9 := $WritebackToReference($t10, $t9);
    call $tmp := $CopyOrMoveValue($t11);
    coin := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 24496, 3, $tmp);
    }

    call $t12 := $Libra_currency_code($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    currency_code := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 24594, 4, $tmp);
    }

    call $t13 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t14 := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t13, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 24656, $abort_code);
        goto Abort;
    }

    call info := $CopyOrMoveRef($t14);
    if (true)
    {
        assume $DebugTrackLocal(15, 24649, 5, $Dereference(info));
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t15 := $tmp;
    call $t16 := $Libra_value($tv0, $t15);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t16);
    amount := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 24751, 2, $tmp);
    }

    call $t17 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t17, $Libra_CurrencyInfo_preburn_value);
    $t18 := $tmp;
    call info := $WritebackToReference($t17, info);
    call $tmp := $CopyOrMoveValue($t18);
    $t19 := $tmp;
    call $tmp := $Sub($t19, amount);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 24822, $abort_code);
        goto Abort;
    }

    $t21 := $tmp;
    call $t22 := $CopyOrMoveRef(info);
    call $t23 := $BorrowField($t22, $Libra_CurrencyInfo_preburn_value);
    call info := $WritebackToReference($t22, info);
    call $t23 := $WriteRef($t23, $t21);
    if (true)
    {
        assume $DebugTrackLocal(15, 24782, 5, $Dereference(info));
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 24782, 6, $Dereference(preburn));
    }

    call info := $WritebackToReference($t23, info);
    call $t22 := $WritebackToReference($t23, $t22);
    call $t24 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t24, $Libra_CurrencyInfo_is_synthetic);
    $t25 := $tmp;
    call info := $WritebackToReference($t24, info);
    call $tmp := $CopyOrMoveValue($t25);
    $t26 := $tmp;
    call $tmp := $Not($t26);
    $t27 := $tmp;
    $tmp := $t27;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t28 := $CopyOrMoveRef(info);
    call $t29 := $BorrowField($t28, $Libra_CurrencyInfo_cancel_burn_events);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t28);
    call $tmp := $Libra_CancelBurnEvent_pack(0, 0, 0, amount, currency_code, $t36);
    $t33 := $tmp;
    call $tmp := $ReadRef($t29);
    $t38 := $tmp;
    call $t38 := $Event_emit_event($Libra_CancelBurnEvent_type_value(), $t38, $t33);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t29 := $WriteRef($t29, $t38);
    if (true)
    {
        assume $DebugTrackLocal(15, 24172, 5, $Dereference(info));
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 24172, 6, $Dereference(preburn));
    }

    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t29);
    call $t28 := $WritebackToReference($t29, $t28);
    goto L3;

  L2:
    call $t34 := $CopyOrMoveRef(info);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t34);
    goto L3;

  L3:
    $ret0 := coin;
    if (true)
    {
        assume $DebugTrackLocal(15, 25275, 40, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_cancel_burn_with_capability_$direct_inter($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_cancel_burn_with_capability_$direct_inter($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume is#$Address(preburn_address);
    assume $Libra_BurnCapability_is_well_formed(_capability);
    call $ret0 := $Libra_cancel_burn_with_capability_$def($tv0, preburn_address, _capability);
}



procedure {:inline 1} $Libra_cancel_burn_with_capability_$direct_intra($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier459"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier460"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier461"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier462"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier463"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier464"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier465"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_cancel_burn_with_capability_$direct_intra($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume is#$Address(preburn_address);
    assume $Libra_BurnCapability_is_well_formed(_capability);
    call $ret0 := $Libra_cancel_burn_with_capability_$def($tv0, preburn_address, _capability);
}



procedure {:inline 1} $Libra_cancel_burn_with_capability($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_cancel_burn_with_capability($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume is#$Address(preburn_address);
    assume $Libra_BurnCapability_is_well_formed(_capability);
    call $ret0 := $Libra_cancel_burn_with_capability_$def($tv0, preburn_address, _capability);
}



procedure {:inline 1} $Libra_create_preburn_$def($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_create_preburn_$def($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 18114, 0, tc_account);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    call $t4 := $Roles_has_treasury_compliance_role($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 18214, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 18214, i#$Integer($t6));
    }

    $abort_code := i#$Integer($t6);
    goto Abort;

  L0:
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t7 := $Libra_zero($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Libra_Preburn_pack(0, 0, 0, $tv0, $t7);
    $t8 := $tmp;
    $ret0 := $t8;
    if (true)
    {
        assume $DebugTrackLocal(15, 18345, 10, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_create_preburn_$direct_inter($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_create_preburn_$direct_inter($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(tc_account);
    call $ret0 := $Libra_create_preburn_$def($tv0, tc_account);
}



procedure {:inline 1} $Libra_create_preburn_$direct_intra($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier466"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier467"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier468"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier469"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier470"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier471"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier472"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_create_preburn_$direct_intra($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(tc_account);
    call $ret0 := $Libra_create_preburn_$def($tv0, tc_account);
}



procedure {:inline 1} $Libra_create_preburn($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_create_preburn($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(tc_account);
    call $ret0 := $Libra_create_preburn_$def($tv0, tc_account);
}



procedure {:inline 1} $Libra_deposit_$def($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_deposit_$def($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value)
{
  var value: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Mutation;
  var $t12: $Value;
  var $t13: $Mutation;
  var $t14: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 29066, 0, coin);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 29066, 1, check);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue(check);
    $t14 := $tmp;
    call $t13 := $BorrowLoc(12, $t12);
    call $t4 := $Libra_Libra_unpack($tv0, $t14);
    $t4 := $t4;
    call $tmp := $CopyOrMoveValue($t4);
    value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 29169, 2, $tmp);
    }

    call $t5 := $CopyOrMoveRef($t13);
    call $tmp := $GetFieldFromReference($t5, $Libra_Libra_value);
    $t6 := $tmp;
    call $t13 := $WritebackToReference($t5, $t13);
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    call $tmp := $AddU64($t7, value);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 29218, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $t10 := $CopyOrMoveRef($t13);
    call $t11 := $BorrowField($t10, $Libra_Libra_value);
    call $t12 := $WritebackToValue($t10, 12, $t12);
    call $t11 := $WriteRef($t11, $t9);
    call $t12 := $WritebackToValue($t11, 12, $t12);
    call $t10 := $WritebackToReference($t11, $t10);
    $ret0 := $t12;
    if (true)
    {
        assume $DebugTrackLocal(15, 29225, 15, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_deposit_$direct_inter($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_deposit_$direct_inter($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $Libra_Libra_is_well_formed(check);
    call $ret0 := $Libra_deposit_$def($tv0, coin, check);
}



procedure {:inline 1} $Libra_deposit_$direct_intra($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier473"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier474"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier475"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier476"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier477"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier478"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier479"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_deposit_$direct_intra($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $Libra_Libra_is_well_formed(check);
    call $ret0 := $Libra_deposit_$def($tv0, coin, check);
}



procedure {:inline 1} $Libra_deposit($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_deposit($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $Libra_Libra_is_well_formed(check);
    call $ret0 := $Libra_deposit_$def($tv0, coin, check);
}



procedure {:inline 1} $Libra_destroy_zero_$def($tv0: $TypeValue, coin: $Value);



implementation {:inline 1} $Libra_destroy_zero_$def($tv0: $TypeValue, coin: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var value: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 29471, 0, coin);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t11 := $tmp;
    call $t5 := $Libra_Libra_unpack($tv0, $t11);
    $t5 := $t5;
    call $tmp := $CopyOrMoveValue($t5);
    value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 29550, 3, $tmp);
    }

    $tmp := $Integer(0);
    $t7 := $tmp;
    $tmp := $Boolean($IsEqual(value, $t7));
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 29574, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(6);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 29574, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_destroy_zero_$direct_inter($tv0: $TypeValue, coin: $Value);
  ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0)))));



implementation {:inline 1} $Libra_destroy_zero_$direct_inter($tv0: $TypeValue, coin: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $Libra_destroy_zero_$def($tv0, coin);
}



procedure {:inline 1} $Libra_destroy_zero_$direct_intra($tv0: $TypeValue, coin: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier480"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier481"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier482"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier483"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier484"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier485"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier486"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_destroy_zero_$direct_intra($tv0: $TypeValue, coin: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $Libra_destroy_zero_$def($tv0, coin);
}



procedure {:inline 1} $Libra_destroy_zero($tv0: $TypeValue, coin: $Value);



implementation {:inline 1} $Libra_destroy_zero($tv0: $TypeValue, coin: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $Libra_destroy_zero_$def($tv0, coin);
}



procedure {:inline 1} $Libra_fractional_part_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_fractional_part_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 37362, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_fractional_part);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(15, 37362, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_fractional_part_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_fractional_part_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_fractional_part_$def($tv0);
}



procedure {:inline 1} $Libra_fractional_part_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier487"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier488"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier489"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier490"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier491"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier492"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier493"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_fractional_part_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_fractional_part_$def($tv0);
}



procedure {:inline 1} $Libra_fractional_part($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_fractional_part($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_fractional_part_$def($tv0);
}



procedure {:inline 1} $Libra_is_SCS_currency_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_is_SCS_currency_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var info: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t1 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_CurrencyInfo_$memory, $t1, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 36342, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    info := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 36335, 0, $tmp);
    }

    call $tmp := $CopyOrMoveValue(info);
    $t3 := $tmp;
    call $tmp := $GetFieldFromValue($t3, $Libra_CurrencyInfo_is_synthetic);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t5 := $tmp;
    call $tmp := $Not($t5);
    $t6 := $tmp;
    $ret0 := $t6;
    if (true)
    {
        assume $DebugTrackLocal(15, 36429, 7, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_is_SCS_currency_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_is_SCS_currency_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_SCS_currency_$def($tv0);
}



procedure {:inline 1} $Libra_is_SCS_currency_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier494"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier495"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier496"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier497"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier498"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier499"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier500"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_is_SCS_currency_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_SCS_currency_$def($tv0);
}



procedure {:inline 1} $Libra_is_SCS_currency($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_is_SCS_currency($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_SCS_currency_$def($tv0);
}



procedure {:inline 1} $Libra_is_currency_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_is_currency_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t0);
    $t1 := $tmp;
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(15, 36172, 2, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_is_currency_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_is_currency_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_currency_$def($tv0);
}



procedure {:inline 1} $Libra_is_currency_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier501"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier502"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier503"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier504"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier505"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier506"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier507"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_is_currency_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_currency_$def($tv0);
}



procedure {:inline 1} $Libra_is_currency($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_is_currency($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_currency_$def($tv0);
}



procedure {:inline 1} $Libra_is_synthetic_currency_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_is_synthetic_currency_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var addr: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t2 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t2);
    addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 36681, 0, $tmp);
    }

    $tmp := $ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);
    $t4 := $tmp;
    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $GetGlobal($Libra_CurrencyInfo_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 36788, $abort_code);
        goto Abort;
    }

    $t6 := $tmp;
    call $tmp := $GetFieldFromValue($t6, $Libra_CurrencyInfo_is_synthetic);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 36736, 1, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Boolean(false);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 36736, 1, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(15, 36736, 11, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_is_synthetic_currency_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_is_synthetic_currency_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_synthetic_currency_$def($tv0);
}



procedure {:inline 1} $Libra_is_synthetic_currency_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier508"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier509"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier510"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier511"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier512"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier513"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier514"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_is_synthetic_currency_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_synthetic_currency_$def($tv0);
}



procedure {:inline 1} $Libra_is_synthetic_currency($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_is_synthetic_currency($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_synthetic_currency_$def($tv0);
}



procedure {:inline 1} $Libra_join_$def($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_join_$def($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
{
  var $t2: $Mutation;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 28592, 0, coin1);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 28592, 1, coin2);
    }

    call $tmp := $CopyOrMoveValue(coin1);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue(coin2);
    $t6 := $tmp;
    call $t2 := $BorrowLoc(5, $t5);
    call $tmp := $ReadRef($t2);
    $t7 := $tmp;
    call $t7 := $Libra_deposit($tv0, $t7, $t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t2 := $WriteRef($t2, $t7);
    call $t5 := $WritebackToValue($t2, 5, $t5);
    $ret0 := $t5;
    if (true)
    {
        assume $DebugTrackLocal(15, 28730, 8, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_join_$direct_inter($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value))))));



implementation {:inline 1} $Libra_join_$direct_inter($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin1);
    assume $Libra_Libra_is_well_formed(coin2);
    call $ret0 := $Libra_join_$def($tv0, coin1, coin2);
}



procedure {:inline 1} $Libra_join_$direct_intra($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier515"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier516"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier517"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier518"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier519"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier520"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier521"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_join_$direct_intra($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin1);
    assume $Libra_Libra_is_well_formed(coin2);
    call $ret0 := $Libra_join_$def($tv0, coin1, coin2);
}



procedure {:inline 1} $Libra_join($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_join($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin1);
    assume $Libra_Libra_is_well_formed(coin2);
    call $ret0 := $Libra_join_$def($tv0, coin1, coin2);
}



procedure {:inline 1} $Libra_lbr_exchange_rate_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_lbr_exchange_rate_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 39390, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(15, 39388, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_lbr_exchange_rate_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_lbr_exchange_rate_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_lbr_exchange_rate_$def($tv0);
}



procedure {:inline 1} $Libra_lbr_exchange_rate_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier522"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier523"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier524"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier525"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier526"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier527"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier528"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_lbr_exchange_rate_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_lbr_exchange_rate_$def($tv0);
}



procedure {:inline 1} $Libra_lbr_exchange_rate($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_lbr_exchange_rate($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_lbr_exchange_rate_$def($tv0);
}



procedure {:inline 1} $Libra_market_cap_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_market_cap_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 34876, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_total_value);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(15, 34876, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_market_cap_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_market_cap_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_market_cap_$def($tv0);
}



procedure {:inline 1} $Libra_market_cap_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier529"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier530"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier531"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier532"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier533"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier534"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier535"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_market_cap_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_market_cap_$def($tv0);
}



procedure {:inline 1} $Libra_market_cap($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_market_cap($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_market_cap_$def($tv0);
}



procedure {:inline 1} $Libra_mint_$def($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_mint_$def($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 11998, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 11998, 1, value);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue(value);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_MintCapability_$memory, $t4, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 12176, $abort_code);
        goto Abort;
    }

    $t5 := $tmp;
    call $t6 := $Libra_mint_with_capability($tv0, $t8, $t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t6;
    if (true)
    {
        assume $DebugTrackLocal(15, 12123, 9, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_mint_$direct_inter($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(value)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), value)));



implementation {:inline 1} $Libra_mint_$direct_inter($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(value);
    call $ret0 := $Libra_mint_$def($tv0, account, value);
}



procedure {:inline 1} $Libra_mint_$direct_intra($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier536"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier537"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier538"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier539"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier540"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier541"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier542"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_mint_$direct_intra($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(value);
    call $ret0 := $Libra_mint_$def($tv0, account, value);
}



procedure {:inline 1} $Libra_mint($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_mint($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(value);
    call $ret0 := $Libra_mint_$def($tv0, account, value);
}



procedure {:inline 1} $Libra_mint_with_capability_$def($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_mint_with_capability_$def($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value)
{
  var currency_code: $Value;
  var info: $Mutation;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Mutation;
  var $t9: $Mutation;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Mutation;
  var $t14: $Value;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Mutation;
  var $t22: $Mutation;
  var $t23: $Mutation;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Mutation;
  var $t28: $Mutation;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Mutation;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 14171, 0, value);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 14171, 1, _capability);
    }

    call $tmp := $CopyOrMoveValue(value);
    $t35 := $tmp;
    call $tmp := $CopyOrMoveValue(_capability);
    $t36 := $tmp;
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t6 := $Libra_currency_code($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    currency_code := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 14380, 2, $tmp);
    }

    call $t7 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t8 := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t7, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 14499, $abort_code);
        goto Abort;
    }

    call info := $CopyOrMoveRef($t8);
    if (true)
    {
        assume $DebugTrackLocal(15, 14492, 3, $Dereference(info));
    }

    call $t9 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t9, $Libra_CurrencyInfo_can_mint);
    $t10 := $tmp;
    call info := $WritebackToReference($t9, info);
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 14590, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t13 := $CopyOrMoveRef(info);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t13);
    $tmp := $Integer(3);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 14590, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L0:
    call $t15 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t15, $Libra_CurrencyInfo_total_value);
    $t16 := $tmp;
    call info := $WritebackToReference($t15, info);
    call $tmp := $CopyOrMoveValue($t16);
    $t17 := $tmp;
    call $tmp := $CastU128($t35);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 14681, $abort_code);
        goto Abort;
    }

    $t19 := $tmp;
    call $tmp := $AddU128($t17, $t19);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 14679, $abort_code);
        goto Abort;
    }

    $t20 := $tmp;
    call $t21 := $CopyOrMoveRef(info);
    call $t22 := $BorrowField($t21, $Libra_CurrencyInfo_total_value);
    call info := $WritebackToReference($t21, info);
    call $t22 := $WriteRef($t22, $t20);
    if (true)
    {
        assume $DebugTrackLocal(15, 14643, 3, $Dereference(info));
    }

    call info := $WritebackToReference($t22, info);
    call $t21 := $WritebackToReference($t22, $t21);
    call $t23 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t23, $Libra_CurrencyInfo_is_synthetic);
    $t24 := $tmp;
    call info := $WritebackToReference($t23, info);
    call $tmp := $CopyOrMoveValue($t24);
    $t25 := $tmp;
    call $tmp := $Not($t25);
    $t26 := $tmp;
    $tmp := $t26;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $t27 := $CopyOrMoveRef(info);
    call $t28 := $BorrowField($t27, $Libra_CurrencyInfo_mint_events);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t27);
    call $tmp := $Libra_MintEvent_pack(0, 0, 0, $t35, currency_code);
    $t31 := $tmp;
    call $tmp := $ReadRef($t28);
    $t37 := $tmp;
    call $t37 := $Event_emit_event($Libra_MintEvent_type_value(), $t37, $t31);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t28 := $WriteRef($t28, $t37);
    if (true)
    {
        assume $DebugTrackLocal(15, 15011, 3, $Dereference(info));
    }

    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t28);
    call $t27 := $WritebackToReference($t28, $t27);
    goto L5;

  L4:
    call $t32 := $CopyOrMoveRef(info);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t32);
    goto L5;

  L5:
    call $tmp := $Libra_Libra_pack(0, 0, 0, $tv0, $t35);
    $t34 := $tmp;
    $ret0 := $t34;
    if (true)
    {
        assume $DebugTrackLocal(15, 15011, 38, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_mint_with_capability_$direct_inter($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(value)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), value)));



implementation {:inline 1} $Libra_mint_with_capability_$direct_inter($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(value);
    assume $Libra_MintCapability_is_well_formed(_capability);
    call $ret0 := $Libra_mint_with_capability_$def($tv0, value, _capability);
}



procedure {:inline 1} $Libra_mint_with_capability_$direct_intra($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier543"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier544"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier545"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier546"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier547"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier548"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier549"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_mint_with_capability_$direct_intra($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(value);
    assume $Libra_MintCapability_is_well_formed(_capability);
    call $ret0 := $Libra_mint_with_capability_$def($tv0, value, _capability);
}



procedure {:inline 1} $Libra_mint_with_capability($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_mint_with_capability($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(value);
    assume $Libra_MintCapability_is_well_formed(_capability);
    call $ret0 := $Libra_mint_with_capability_$def($tv0, value, _capability);
}



procedure {:inline 1} $Libra_preburn_to_$def($tv0: $TypeValue, account: $Value, coin: $Value);



implementation {:inline 1} $Libra_preburn_to_$def($tv0: $TypeValue, account: $Value, coin: $Value)
{
  var sender: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Mutation;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 19631, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 19631, 1, coin);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue(coin);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t4);
    sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 19771, 2, $tmp);
    }

    call $t7 := $BorrowGlobal($Libra_Preburn_$memory, sender, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 19845, $abort_code);
        goto Abort;
    }

    call $tmp := $ReadRef($t7);
    $t11 := $tmp;
    call $t11 := $Libra_preburn_with_resource($tv0, $t10, $t11, sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t7 := $WriteRef($t7, $t11);
    call $Libra_Preburn_$memory := $WritebackToGlobal($Libra_Preburn_$memory, $t7);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_preburn_to_$direct_inter($tv0: $TypeValue, account: $Value, coin: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) || b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))) + i#$Integer($SelectField(coin, $Libra_Libra_value))))));



implementation {:inline 1} $Libra_preburn_to_$direct_inter($tv0: $TypeValue, account: $Value, coin: $Value)
{
    assume is#$Address(account);
    assume $Libra_Libra_is_well_formed(coin);
    call $Libra_preburn_to_$def($tv0, account, coin);
}



procedure {:inline 1} $Libra_preburn_to_$direct_intra($tv0: $TypeValue, account: $Value, coin: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier550"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier551"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier552"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier553"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier554"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier555"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier556"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_preburn_to_$direct_intra($tv0: $TypeValue, account: $Value, coin: $Value)
{
    assume is#$Address(account);
    assume $Libra_Libra_is_well_formed(coin);
    call $Libra_preburn_to_$def($tv0, account, coin);
}



procedure {:inline 1} $Libra_preburn_to($tv0: $TypeValue, account: $Value, coin: $Value);



implementation {:inline 1} $Libra_preburn_to($tv0: $TypeValue, account: $Value, coin: $Value)
{
    assume is#$Address(account);
    assume $Libra_Libra_is_well_formed(coin);
    call $Libra_preburn_to_$def($tv0, account, coin);
}



procedure {:inline 1} $Libra_preburn_value_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_preburn_value_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 26022, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_preburn_value);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(15, 26022, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_preburn_value_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_preburn_value_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_preburn_value_$def($tv0);
}



procedure {:inline 1} $Libra_preburn_value_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier557"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier558"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier559"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier560"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier561"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier562"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier563"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_preburn_value_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_preburn_value_$def($tv0);
}



procedure {:inline 1} $Libra_preburn_value($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_preburn_value($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_preburn_value_$def($tv0);
}



procedure {:inline 1} $Libra_preburn_with_resource_$def($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_preburn_with_resource_$def($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
  var coin_value: $Value;
  var currency_code: $Value;
  var info: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Mutation;
  var $t19: $Mutation;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Mutation;
  var $t24: $Mutation;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Mutation;
  var $t30: $Mutation;
  var $t31: $Mutation;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Mutation;
  var $t36: $Mutation;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Mutation;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Mutation;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 16142, 0, coin);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 16142, 1, preburn);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 16142, 2, preburn_address);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t42 := $tmp;
    call $tmp := $CopyOrMoveValue(preburn);
    $t43 := $tmp;
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t45 := $tmp;
    call $t44 := $BorrowLoc(43, $t43);
    call $tmp := $CopyOrMoveValue($t42);
    $t8 := $tmp;
    call $t9 := $Libra_value($tv0, $t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    coin_value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 16334, 3, $tmp);
    }

    call $t10 := $CopyOrMoveRef($t44);
    call $tmp := $GetFieldFromReference($t10, $Libra_Preburn_to_burn);
    $t11 := $tmp;
    call $t44 := $WritebackToReference($t10, $t44);
    call $t12 := $Libra_value($tv0, $t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(0);
    $t13 := $tmp;
    $tmp := $Boolean($IsEqual($t12, $t13));
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 16406, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t16 := $CopyOrMoveRef($t44);
    call $t43 := $WritebackToValue($t16, 43, $t43);
    $tmp := $Integer(6);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 16406, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L0:
    call $t18 := $CopyOrMoveRef($t44);
    call $t19 := $BorrowField($t18, $Libra_Preburn_to_burn);
    call $t43 := $WritebackToValue($t18, 43, $t43);
    call $tmp := $ReadRef($t19);
    $t47 := $tmp;
    call $t47 := $Libra_deposit($tv0, $t47, $t42);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $WriteRef($t19, $t47);
    if (true)
    {
        assume $DebugTrackLocal(15, 16142, 5, $Dereference(info));
    }

    call $t43 := $WritebackToValue($t19, 43, $t43);
    call $t18 := $WritebackToReference($t19, $t18);
    call $t21 := $Libra_currency_code($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t21);
    currency_code := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 16504, 4, $tmp);
    }

    call $t22 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t23 := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t22, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 16566, $abort_code);
        goto Abort;
    }

    call info := $CopyOrMoveRef($t23);
    if (true)
    {
        assume $DebugTrackLocal(15, 16559, 5, $Dereference(info));
    }

    call $t24 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t24, $Libra_CurrencyInfo_preburn_value);
    $t25 := $tmp;
    call info := $WritebackToReference($t24, info);
    call $tmp := $CopyOrMoveValue($t25);
    $t26 := $tmp;
    call $tmp := $AddU64($t26, coin_value);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 16697, $abort_code);
        goto Abort;
    }

    $t28 := $tmp;
    call $t29 := $CopyOrMoveRef(info);
    call $t30 := $BorrowField($t29, $Libra_CurrencyInfo_preburn_value);
    call info := $WritebackToReference($t29, info);
    call $t30 := $WriteRef($t30, $t28);
    if (true)
    {
        assume $DebugTrackLocal(15, 16657, 5, $Dereference(info));
    }

    call info := $WritebackToReference($t30, info);
    call $t29 := $WritebackToReference($t30, $t29);
    call $t31 := $CopyOrMoveRef(info);
    call $tmp := $GetFieldFromReference($t31, $Libra_CurrencyInfo_is_synthetic);
    $t32 := $tmp;
    call info := $WritebackToReference($t31, info);
    call $tmp := $CopyOrMoveValue($t32);
    $t33 := $tmp;
    call $tmp := $Not($t33);
    $t34 := $tmp;
    $tmp := $t34;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $t35 := $CopyOrMoveRef(info);
    call $t36 := $BorrowField($t35, $Libra_CurrencyInfo_preburn_events);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t35);
    call $tmp := $Libra_PreburnEvent_pack(0, 0, 0, coin_value, currency_code, $t45);
    $t40 := $tmp;
    call $tmp := $ReadRef($t36);
    $t46 := $tmp;
    call $t46 := $Event_emit_event($Libra_PreburnEvent_type_value(), $t46, $t40);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t36 := $WriteRef($t36, $t46);
    if (true)
    {
        assume $DebugTrackLocal(15, 16142, 5, $Dereference(info));
    }

    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t36);
    call $t35 := $WritebackToReference($t36, $t35);
    goto L5;

  L4:
    call $t41 := $CopyOrMoveRef(info);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t41);
    goto L5;

  L5:
    $ret0 := $t43;
    if (true)
    {
        assume $DebugTrackLocal(15, 17064, 48, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_preburn_with_resource_$direct_inter($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) || b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))) + i#$Integer($SelectField(coin, $Libra_Libra_value))))));



implementation {:inline 1} $Libra_preburn_with_resource_$direct_inter($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $Libra_Preburn_is_well_formed(preburn);
    assume is#$Address(preburn_address);
    call $ret0 := $Libra_preburn_with_resource_$def($tv0, coin, preburn, preburn_address);
}



procedure {:inline 1} $Libra_preburn_with_resource_$direct_intra($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier564"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier565"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier566"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier567"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier568"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier569"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier570"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_preburn_with_resource_$direct_intra($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $Libra_Preburn_is_well_formed(preburn);
    assume is#$Address(preburn_address);
    call $ret0 := $Libra_preburn_with_resource_$def($tv0, coin, preburn, preburn_address);
}



procedure {:inline 1} $Libra_preburn_with_resource($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_preburn_with_resource($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $Libra_Preburn_is_well_formed(preburn);
    assume is#$Address(preburn_address);
    call $ret0 := $Libra_preburn_with_resource_$def($tv0, coin, preburn, preburn_address);
}



procedure {:inline 1} $Libra_publish_burn_capability_$def($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value);



implementation {:inline 1} $Libra_publish_burn_capability_$def($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 10801, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 10801, 1, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 10801, 2, tc_account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue(cap);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 10957, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t12);
    $t8 := $tmp;
    $tmp := $Integer(2);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 10957, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    $t10 := $tmp;
    call $Libra_BurnCapability_$memory := $MoveTo($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t13, $t10);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 11088, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_publish_burn_capability_$direct_inter($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(tc_account)))))) || b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account))));



implementation {:inline 1} $Libra_publish_burn_capability_$direct_inter($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value)
{
    assume is#$Address(account);
    assume $Libra_BurnCapability_is_well_formed(cap);
    assume is#$Address(tc_account);
    call $Libra_publish_burn_capability_$def($tv0, account, cap, tc_account);
}



procedure {:inline 1} $Libra_publish_burn_capability_$direct_intra($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier571"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier572"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier573"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier574"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier575"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier576"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier577"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_publish_burn_capability_$direct_intra($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value)
{
    assume is#$Address(account);
    assume $Libra_BurnCapability_is_well_formed(cap);
    assume is#$Address(tc_account);
    call $Libra_publish_burn_capability_$def($tv0, account, cap, tc_account);
}



procedure {:inline 1} $Libra_publish_burn_capability($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value);



implementation {:inline 1} $Libra_publish_burn_capability($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value)
{
    assume is#$Address(account);
    assume $Libra_BurnCapability_is_well_formed(cap);
    assume is#$Address(tc_account);
    call $Libra_publish_burn_capability_$def($tv0, account, cap, tc_account);
}



procedure {:inline 1} $Libra_publish_preburn_to_account_$def($tv0: $TypeValue, account: $Value, tc_account: $Value);



implementation {:inline 1} $Libra_publish_preburn_to_account_$def($tv0: $TypeValue, account: $Value, tc_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 18718, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 18718, 1, tc_account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t22 := $tmp;
    call $t6 := $Libra_is_synthetic_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t6);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 18859, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t22);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t10 := $tmp;
    $tmp := $Integer(4);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 18859, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t21);
    $t12 := $tmp;
    call $t13 := $Roles_has_designated_dealer_role($t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 18935, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t22);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t16 := $tmp;
    $tmp := $Integer(10);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 18935, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t21);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t19 := $tmp;
    call $t20 := $Libra_create_preburn($tv0, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $Libra_Preburn_$memory := $MoveTo($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t20, $t18);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 19019, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_publish_preburn_to_account_$direct_inter($tv0: $TypeValue, account: $Value, tc_account: $Value);



implementation {:inline 1} $Libra_publish_preburn_to_account_$direct_inter($tv0: $TypeValue, account: $Value, tc_account: $Value)
{
    assume is#$Address(account);
    assume is#$Address(tc_account);
    call $Libra_publish_preburn_to_account_$def($tv0, account, tc_account);
}



procedure {:inline 1} $Libra_publish_preburn_to_account_$direct_intra($tv0: $TypeValue, account: $Value, tc_account: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier578"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier579"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier580"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier581"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier582"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier583"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier584"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_publish_preburn_to_account_$direct_intra($tv0: $TypeValue, account: $Value, tc_account: $Value)
{
    assume is#$Address(account);
    assume is#$Address(tc_account);
    call $Libra_publish_preburn_to_account_$def($tv0, account, tc_account);
}



procedure {:inline 1} $Libra_publish_preburn_to_account($tv0: $TypeValue, account: $Value, tc_account: $Value);



implementation {:inline 1} $Libra_publish_preburn_to_account($tv0: $TypeValue, account: $Value, tc_account: $Value)
{
    assume is#$Address(account);
    assume is#$Address(tc_account);
    call $Libra_publish_preburn_to_account_$def($tv0, account, tc_account);
}



procedure {:inline 1} $Libra_register_SCS_currency_$def($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value);



implementation {:inline 1} $Libra_register_SCS_currency_$def($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value)
{
  var burn_cap: $Value;
  var mint_cap: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 33467, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 33467, 1, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 33467, 2, to_lbr_exchange_rate);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 33467, 3, scaling_factor);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 33467, 4, fractional_part);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 33467, 5, currency_code);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue(to_lbr_exchange_rate);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue(scaling_factor);
    $t32 := $tmp;
    call $tmp := $CopyOrMoveValue(fractional_part);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue(currency_code);
    $t34 := $tmp;
    call $tmp := $CopyOrMoveValue($t30);
    $t10 := $tmp;
    call $t11 := $Roles_has_treasury_compliance_role($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 33723, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t30);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t29);
    $t14 := $tmp;
    $tmp := $Integer(2);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 33723, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t29);
    $t16 := $tmp;
    $tmp := $Boolean(false);
    $t18 := $tmp;
    call $t22, $t23 := $Libra_register_currency($tv0, $t16, $t31, $t18, $t32, $t33, $t34);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t23);
    burn_cap := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 33829, 6, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t22);
    mint_cap := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 33819, 7, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t30);
    $t24 := $tmp;
    call $Libra_MintCapability_$memory := $MoveTo($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), mint_cap, $t24);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 34263, $abort_code);
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t30);
    $t26 := $tmp;
    call $tmp := $CopyOrMoveValue($t30);
    $t28 := $tmp;
    call $Libra_publish_burn_capability($tv0, $t26, burn_cap, $t28);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_register_SCS_currency_$direct_inter($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value);
  ensures b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))) ==> $abort_flag;
  ensures b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $RegisteredCurrencies_RegisteredCurrencies_type_value()], 1), $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))) || b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) || b#$Boolean(old($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))) || b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) || b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $RegisteredCurrencies_RegisteredCurrencies_type_value()], 1), $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code))) || b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(tc_account)))))) || b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account))));
  ensures !$abort_flag ==> b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, $tv0, $Signer_spec_address_of(tc_account)));



implementation {:inline 1} $Libra_register_SCS_currency_$direct_inter($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    assume $IsValidU64(scaling_factor);
    assume $IsValidU64(fractional_part);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier585"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    call $Libra_register_SCS_currency_$def($tv0, lr_account, tc_account, to_lbr_exchange_rate, scaling_factor, fractional_part, currency_code);
}



procedure {:inline 1} $Libra_register_SCS_currency_$direct_intra($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier586"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier587"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier588"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier589"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier590"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier591"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier592"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_register_SCS_currency_$direct_intra($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    assume $IsValidU64(scaling_factor);
    assume $IsValidU64(fractional_part);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier593"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    call $Libra_register_SCS_currency_$def($tv0, lr_account, tc_account, to_lbr_exchange_rate, scaling_factor, fractional_part, currency_code);
}



procedure {:inline 1} $Libra_register_SCS_currency($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value);



implementation {:inline 1} $Libra_register_SCS_currency($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    assume $IsValidU64(scaling_factor);
    assume $IsValidU64(fractional_part);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier594"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    call $Libra_register_SCS_currency_$def($tv0, lr_account, tc_account, to_lbr_exchange_rate, scaling_factor, fractional_part, currency_code);
}



procedure {:inline 1} $Libra_scaling_factor_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_scaling_factor_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 37040, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_scaling_factor);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(15, 37040, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_scaling_factor_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_scaling_factor_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_scaling_factor_$def($tv0);
}



procedure {:inline 1} $Libra_scaling_factor_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier595"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier596"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier597"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier598"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier599"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier600"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier601"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_scaling_factor_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_scaling_factor_$def($tv0);
}



procedure {:inline 1} $Libra_scaling_factor($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_scaling_factor($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_scaling_factor_$def($tv0);
}



procedure {:inline 1} $Libra_register_currency_$def($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Libra_register_currency_$def($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 30700, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 30700, 1, to_lbr_exchange_rate);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 30700, 2, is_synthetic);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 30700, 3, scaling_factor);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 30700, 4, fractional_part);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 30700, 5, currency_code);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t48 := $tmp;
    call $tmp := $CopyOrMoveValue(to_lbr_exchange_rate);
    $t49 := $tmp;
    call $tmp := $CopyOrMoveValue(is_synthetic);
    $t50 := $tmp;
    call $tmp := $CopyOrMoveValue(scaling_factor);
    $t51 := $tmp;
    call $tmp := $CopyOrMoveValue(fractional_part);
    $t52 := $tmp;
    call $tmp := $CopyOrMoveValue(currency_code);
    $t53 := $tmp;
    call $tmp := $CopyOrMoveValue($t48);
    $t10 := $tmp;
    call $t11 := $Roles_has_register_new_currency_privilege($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 31009, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t48);
    $t13 := $tmp;
    $tmp := $Integer(7);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 31009, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t48);
    $t15 := $tmp;
    call $t16 := $Signer_address_of($t15);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t17 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t16, $t17));
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 31203, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t48);
    $t20 := $tmp;
    $tmp := $Integer(1);
    $t21 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 31203, i#$Integer($t21));
    }

    $abort_code := i#$Integer($t21);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t48);
    $t22 := $tmp;
    $tmp := $Integer(0);
    $t23 := $tmp;
    $tmp := $Integer(0);
    $t24 := $tmp;
    $tmp := $Boolean(true);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue($t48);
    $t31 := $tmp;
    call $t32 := $Event_new_event_handle($Libra_MintEvent_type_value(), $t31);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t48);
    $t33 := $tmp;
    call $t34 := $Event_new_event_handle($Libra_BurnEvent_type_value(), $t33);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t48);
    $t35 := $tmp;
    call $t36 := $Event_new_event_handle($Libra_PreburnEvent_type_value(), $t35);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t48);
    $t37 := $tmp;
    call $t38 := $Event_new_event_handle($Libra_CancelBurnEvent_type_value(), $t37);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t48);
    $t39 := $tmp;
    call $t40 := $Event_new_event_handle($Libra_ToLBRExchangeRateUpdateEvent_type_value(), $t39);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Libra_CurrencyInfo_pack(0, 0, 0, $tv0, $t23, $t24, $t49, $t50, $t51, $t52, $t53, $t30, $t32, $t34, $t36, $t38, $t40);
    $t41 := $tmp;
    call $Libra_CurrencyInfo_$memory := $MoveTo($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t41, $t22);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 31356, $abort_code);
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t48);
    $t42 := $tmp;
    call $RegisteredCurrencies_add_currency_code($t42, $t53);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean(false);
    $t44 := $tmp;
    call $tmp := $Libra_MintCapability_pack(0, 0, 0, $tv0, $t44);
    $t45 := $tmp;
    $tmp := $Boolean(false);
    $t46 := $tmp;
    call $tmp := $Libra_BurnCapability_pack(0, 0, 0, $tv0, $t46);
    $t47 := $tmp;
    $ret0 := $t45;
    if (true)
    {
        assume $DebugTrackLocal(15, 32200, 54, $ret0);
    }

    $ret1 := $t47;
    if (true)
    {
        assume $DebugTrackLocal(15, 32200, 55, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $Libra_register_currency_$direct_inter($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))) ==> $abort_flag;
  ensures b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $RegisteredCurrencies_RegisteredCurrencies_type_value()], 1), $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) || b#$Boolean(old($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))) || b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) || b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $RegisteredCurrencies_RegisteredCurrencies_type_value()], 1), $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code)));
  ensures !$abort_flag ==> b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value), $Integer(0))));



implementation {:inline 1} $Libra_register_currency_$direct_inter($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume is#$Address(lr_account);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    assume is#$Boolean(is_synthetic);
    assume $IsValidU64(scaling_factor);
    assume $IsValidU64(fractional_part);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier602"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    call $ret0, $ret1 := $Libra_register_currency_$def($tv0, lr_account, to_lbr_exchange_rate, is_synthetic, scaling_factor, fractional_part, currency_code);
}



procedure {:inline 1} $Libra_register_currency_$direct_intra($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier603"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier604"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier605"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier606"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier607"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier608"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier609"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_register_currency_$direct_intra($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume is#$Address(lr_account);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    assume is#$Boolean(is_synthetic);
    assume $IsValidU64(scaling_factor);
    assume $IsValidU64(fractional_part);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier610"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    call $ret0, $ret1 := $Libra_register_currency_$def($tv0, lr_account, to_lbr_exchange_rate, is_synthetic, scaling_factor, fractional_part, currency_code);
}



procedure {:inline 1} $Libra_register_currency($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Libra_register_currency($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume is#$Address(lr_account);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    assume is#$Boolean(is_synthetic);
    assume $IsValidU64(scaling_factor);
    assume $IsValidU64(fractional_part);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier611"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    call $ret0, $ret1 := $Libra_register_currency_$def($tv0, lr_account, to_lbr_exchange_rate, is_synthetic, scaling_factor, fractional_part, currency_code);
}



procedure {:inline 1} $Libra_remove_burn_capability_$def($tv0: $TypeValue, account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_remove_burn_capability_$def($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 25509, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    call $t2 := $Signer_address_of($t1);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $Libra_BurnCapability_$memory, $tmp := $MoveFrom($Libra_BurnCapability_$memory, $t2, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 25635, $abort_code);
        goto Abort;
    }

    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(15, 25635, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_remove_burn_capability_$direct_inter($tv0: $TypeValue, account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_remove_burn_capability_$direct_inter($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Libra_remove_burn_capability_$def($tv0, account);
}



procedure {:inline 1} $Libra_remove_burn_capability_$direct_intra($tv0: $TypeValue, account: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier612"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier613"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier614"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier615"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier616"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier617"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier618"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_remove_burn_capability_$direct_intra($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Libra_remove_burn_capability_$def($tv0, account);
}



procedure {:inline 1} $Libra_remove_burn_capability($tv0: $TypeValue, account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Libra_remove_burn_capability($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $Libra_remove_burn_capability_$def($tv0, account);
}



procedure {:inline 1} $Libra_split_$def($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Libra_split_$def($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var other: $Value;
  var $t3: $Mutation;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 26904, 0, coin);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 26904, 1, amount);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t9 := $tmp;
    call $t3 := $BorrowLoc(8, $t8);
    call $tmp := $ReadRef($t3);
    $t10 := $tmp;
    call $t5, $t10 := $Libra_withdraw($tv0, $t10, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t3 := $WriteRef($t3, $t10);
    call $t8 := $WritebackToValue($t3, 8, $t8);
    call $tmp := $CopyOrMoveValue($t5);
    other := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 27017, 2, $tmp);
    }

    $ret0 := $t8;
    if (true)
    {
        assume $DebugTrackLocal(15, 27062, 11, $ret0);
    }

    $ret1 := other;
    if (true)
    {
        assume $DebugTrackLocal(15, 27062, 12, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $Libra_split_$direct_inter($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) - i#$Integer(amount)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), amount)));



implementation {:inline 1} $Libra_split_$direct_inter($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $IsValidU64(amount);
    call $ret0, $ret1 := $Libra_split_$def($tv0, coin, amount);
}



procedure {:inline 1} $Libra_split_$direct_intra($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier619"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier620"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier621"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier622"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier623"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier624"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier625"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_split_$direct_intra($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $IsValidU64(amount);
    call $ret0, $ret1 := $Libra_split_$def($tv0, coin, amount);
}



procedure {:inline 1} $Libra_split($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Libra_split($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $IsValidU64(amount);
    call $ret0, $ret1 := $Libra_split_$def($tv0, coin, amount);
}



procedure {:inline 1} $Libra_update_lbr_exchange_rate_$def($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value);



implementation {:inline 1} $Libra_update_lbr_exchange_rate_$def($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value)
{
  var currency_info: $Mutation;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Value;
  var $t12: $Mutation;
  var $t13: $Mutation;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Mutation;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 38233, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 38233, 1, lbr_exchange_rate);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t24 := $tmp;
    call $tmp := $CopyOrMoveValue(lbr_exchange_rate);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue($t24);
    $t5 := $tmp;
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 38391, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 38391, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t9 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t10 := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t9, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 38546, $abort_code);
        goto Abort;
    }

    call currency_info := $CopyOrMoveRef($t10);
    if (true)
    {
        assume $DebugTrackLocal(15, 38530, 2, $Dereference(currency_info));
    }

    call $t12 := $CopyOrMoveRef(currency_info);
    call $t13 := $BorrowField($t12, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    call currency_info := $WritebackToReference($t12, currency_info);
    call $t13 := $WriteRef($t13, $t25);
    if (true)
    {
        assume $DebugTrackLocal(15, 38641, 2, $Dereference(currency_info));
    }

    call currency_info := $WritebackToReference($t13, currency_info);
    call $t12 := $WritebackToReference($t13, $t12);
    call $t14 := $CopyOrMoveRef(currency_info);
    call $t15 := $BorrowField($t14, $Libra_CurrencyInfo_exchange_rate_update_events);
    call currency_info := $WritebackToReference($t14, currency_info);
    call $t16 := $CopyOrMoveRef(currency_info);
    call $tmp := $GetFieldFromReference($t16, $Libra_CurrencyInfo_currency_code);
    $t17 := $tmp;
    call currency_info := $WritebackToReference($t16, currency_info);
    call $tmp := $CopyOrMoveValue($t17);
    $t18 := $tmp;
    call $t19 := $CopyOrMoveRef(currency_info);
    call $tmp := $GetFieldFromReference($t19, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    $t20 := $tmp;
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t19);
    call $tmp := $CopyOrMoveValue($t20);
    $t21 := $tmp;
    call $t22 := $FixedPoint32_get_raw_value($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Libra_ToLBRExchangeRateUpdateEvent_pack(0, 0, 0, $t18, $t22);
    $t23 := $tmp;
    call $tmp := $ReadRef($t15);
    $t26 := $tmp;
    call $t26 := $Event_emit_event($Libra_ToLBRExchangeRateUpdateEvent_type_value(), $t26, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $WriteRef($t15, $t26);
    if (true)
    {
        assume $DebugTrackLocal(15, 38233, 2, $Dereference(currency_info));
    }

    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t15);
    call $t14 := $WritebackToReference($t15, $t14);
    call $t16 := $WritebackToReference($t15, $t16);
    call $t19 := $WritebackToReference($t15, $t19);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_update_lbr_exchange_rate_$direct_inter($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value);



implementation {:inline 1} $Libra_update_lbr_exchange_rate_$direct_inter($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value)
{
    assume is#$Address(tc_account);
    assume $FixedPoint32_FixedPoint32_is_well_formed(lbr_exchange_rate);
    call $Libra_update_lbr_exchange_rate_$def($tv0, tc_account, lbr_exchange_rate);
}



procedure {:inline 1} $Libra_update_lbr_exchange_rate_$direct_intra($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier626"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier627"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier628"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier629"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier630"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier631"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier632"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_update_lbr_exchange_rate_$direct_intra($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value)
{
    assume is#$Address(tc_account);
    assume $FixedPoint32_FixedPoint32_is_well_formed(lbr_exchange_rate);
    call $Libra_update_lbr_exchange_rate_$def($tv0, tc_account, lbr_exchange_rate);
}



procedure {:inline 1} $Libra_update_lbr_exchange_rate($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value);



implementation {:inline 1} $Libra_update_lbr_exchange_rate($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value)
{
    assume is#$Address(tc_account);
    assume $FixedPoint32_FixedPoint32_is_well_formed(lbr_exchange_rate);
    call $Libra_update_lbr_exchange_rate_$def($tv0, tc_account, lbr_exchange_rate);
}



procedure {:inline 1} $Libra_update_minting_ability_$def($tv0: $TypeValue, tc_account: $Value, can_mint: $Value);



implementation {:inline 1} $Libra_update_minting_ability_$def($tv0: $TypeValue, tc_account: $Value, can_mint: $Value)
{
  var currency_info: $Mutation;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Value;
  var $t12: $Mutation;
  var $t13: $Mutation;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 40024, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 40024, 1, can_mint);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue(can_mint);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 40168, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 40168, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t9 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t10 := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t9, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 40319, $abort_code);
        goto Abort;
    }

    call currency_info := $CopyOrMoveRef($t10);
    if (true)
    {
        assume $DebugTrackLocal(15, 40303, 2, $Dereference(currency_info));
    }

    call $t12 := $CopyOrMoveRef(currency_info);
    call $t13 := $BorrowField($t12, $Libra_CurrencyInfo_can_mint);
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t12);
    call $t13 := $WriteRef($t13, $t15);
    if (true)
    {
        assume $DebugTrackLocal(15, 40410, 2, $Dereference(currency_info));
    }

    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, $t13);
    call $t12 := $WritebackToReference($t13, $t12);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Libra_update_minting_ability_$direct_inter($tv0: $TypeValue, tc_account: $Value, can_mint: $Value);



implementation {:inline 1} $Libra_update_minting_ability_$direct_inter($tv0: $TypeValue, tc_account: $Value, can_mint: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Boolean(can_mint);
    call $Libra_update_minting_ability_$def($tv0, tc_account, can_mint);
}



procedure {:inline 1} $Libra_update_minting_ability_$direct_intra($tv0: $TypeValue, tc_account: $Value, can_mint: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier633"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier634"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier635"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier636"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier637"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier638"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier639"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_update_minting_ability_$direct_intra($tv0: $TypeValue, tc_account: $Value, can_mint: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Boolean(can_mint);
    call $Libra_update_minting_ability_$def($tv0, tc_account, can_mint);
}



procedure {:inline 1} $Libra_update_minting_ability($tv0: $TypeValue, tc_account: $Value, can_mint: $Value);



implementation {:inline 1} $Libra_update_minting_ability($tv0: $TypeValue, tc_account: $Value, can_mint: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Boolean(can_mint);
    call $Libra_update_minting_ability_$def($tv0, tc_account, can_mint);
}



procedure {:inline 1} $Libra_withdraw_$def($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Libra_withdraw_$def($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Mutation;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Value;
  var $t12: $Mutation;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Mutation;
  var $t23: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 27621, 0, coin);
    }

    if (true)
    {
        assume $DebugTrackLocal(15, 27621, 1, amount);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t23 := $tmp;
    call $t22 := $BorrowLoc(21, $t21);
    call $t4 := $CopyOrMoveRef($t22);
    call $tmp := $GetFieldFromReference($t4, $Libra_Libra_value);
    $t5 := $tmp;
    call $t22 := $WritebackToReference($t4, $t22);
    call $tmp := $CopyOrMoveValue($t5);
    $t6 := $tmp;
    call $tmp := $Ge($t6, $t23);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 27780, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t10 := $CopyOrMoveRef($t22);
    call $t21 := $WritebackToValue($t10, 21, $t21);
    $tmp := $Integer(5);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(15, 27780, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $t12 := $CopyOrMoveRef($t22);
    call $tmp := $GetFieldFromReference($t12, $Libra_Libra_value);
    $t13 := $tmp;
    call $t22 := $WritebackToReference($t12, $t22);
    call $tmp := $CopyOrMoveValue($t13);
    $t14 := $tmp;
    call $tmp := $Sub($t14, $t23);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(15, 27870, $abort_code);
        goto Abort;
    }

    $t16 := $tmp;
    call $t17 := $CopyOrMoveRef($t22);
    call $t18 := $BorrowField($t17, $Libra_Libra_value);
    call $t21 := $WritebackToValue($t17, 21, $t21);
    call $t18 := $WriteRef($t18, $t16);
    call $t21 := $WritebackToValue($t18, 21, $t21);
    call $t17 := $WritebackToReference($t18, $t17);
    call $tmp := $Libra_Libra_pack(0, 0, 0, $tv0, $t23);
    $t20 := $tmp;
    $ret0 := $t20;
    if (true)
    {
        assume $DebugTrackLocal(15, 27888, 24, $ret0);
    }

    $ret1 := $t21;
    if (true)
    {
        assume $DebugTrackLocal(15, 27888, 25, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $Libra_withdraw_$direct_inter($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(i#$Integer(old($SelectField(coin, $Libra_Libra_value))) - i#$Integer(amount)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), amount)));



implementation {:inline 1} $Libra_withdraw_$direct_inter($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $IsValidU64(amount);
    call $ret0, $ret1 := $Libra_withdraw_$def($tv0, coin, amount);
}



procedure {:inline 1} $Libra_withdraw_$direct_intra($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier640"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier641"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier642"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier643"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier644"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier645"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier646"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_withdraw_$direct_intra($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $IsValidU64(amount);
    call $ret0, $ret1 := $Libra_withdraw_$def($tv0, coin, amount);
}



procedure {:inline 1} $Libra_withdraw($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Libra_withdraw($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    assume $IsValidU64(amount);
    call $ret0, $ret1 := $Libra_withdraw_$def($tv0, coin, amount);
}



procedure {:inline 1} $Libra_withdraw_all_$def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Libra_withdraw_all_$def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var val: $Value;
  var $t2: $Mutation;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Mutation;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(15, 28219, 0, coin);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t8 := $tmp;
    call $t9 := $BorrowLoc(8, $t8);
    call $t2 := $CopyOrMoveRef($t9);
    call $tmp := $GetFieldFromReference($t2, $Libra_Libra_value);
    $t3 := $tmp;
    call $t9 := $WritebackToReference($t2, $t9);
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    val := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(15, 28312, 1, $tmp);
    }

    call $t5 := $CopyOrMoveRef($t9);
    call $tmp := $ReadRef($t5);
    $t10 := $tmp;
    call $t7, $t10 := $Libra_withdraw($tv0, $t10, val);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t5 := $WriteRef($t5, $t10);
    call $t8 := $WritebackToValue($t5, 8, $t8);
    $ret0 := $t7;
    if (true)
    {
        assume $DebugTrackLocal(15, 28338, 11, $ret0);
    }

    $ret1 := $t8;
    if (true)
    {
        assume $DebugTrackLocal(15, 28338, 12, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $Libra_withdraw_all_$direct_inter($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), old($SelectField(coin, $Libra_Libra_value)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(0))));



implementation {:inline 1} $Libra_withdraw_all_$direct_inter($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $ret0, $ret1 := $Libra_withdraw_all_$def($tv0, coin);
}



procedure {:inline 1} $Libra_withdraw_all_$direct_intra($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier647"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier648"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier649"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier650"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier651"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier652"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier653"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_withdraw_all_$direct_intra($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $ret0, $ret1 := $Libra_withdraw_all_$def($tv0, coin);
}



procedure {:inline 1} $Libra_withdraw_all($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Libra_withdraw_all($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $ret0, $ret1 := $Libra_withdraw_all_$def($tv0, coin);
}



procedure {:inline 1} $Libra_zero_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_zero_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(0);
    $t0 := $tmp;
    call $tmp := $Libra_Libra_pack(0, 0, 0, $tv0, $t0);
    $t1 := $tmp;
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(15, 26383, 2, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Libra_zero_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_zero_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_zero_$def($tv0);
}



procedure {:inline 1} $Libra_zero_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier654"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Boolean((exists addr3: $Value :: {:qid "quantifier655"} is#$Address(addr3) && b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier656"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) && b#$Boolean($Boolean((forall addr3: $Value :: {:qid "quantifier657"} is#$Address(addr3) ==> b#$Boolean($Boolean(!b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3))))))))))));
  requires b#$Boolean($Boolean((forall coin_type: $Value :: {:qid "quantifier658"} is#$Type(coin_type) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type))) ==> b#$Boolean($Boolean((forall addr1: $Value :: {:qid "quantifier659"} is#$Address(addr1) ==> b#$Boolean($Boolean((forall addr2: $Value :: {:qid "quantifier660"} is#$Address(addr2) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) && b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr2)))) ==> b#$Boolean($Boolean($IsEqual(addr1, addr2))))))))))))))));



implementation {:inline 1} $Libra_zero_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_zero_$def($tv0);
}



procedure {:inline 1} $Libra_zero($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Libra_zero($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_zero_$def($tv0);
}



const unique $Coin1_Coin1: $TypeName;

const $Coin1_Coin1_dummy_field: $FieldName;

axiom $Coin1_Coin1_dummy_field == 0;

function $Coin1_Coin1_type_value() : $TypeValue;

axiom $Coin1_Coin1_type_value(): $TypeValue == $StructType($Coin1_Coin1, $EmptyTypeValueArray);

var $Coin1_Coin1_$memory: $Memory;

var $Coin1_Coin1_$memory_$old: $Memory;

function {:inline} $Coin1_Coin1_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Coin1_Coin1_dummy_field))
}

function {:inline} $Coin1_Coin1_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Coin1_Coin1_dummy_field))
}

procedure {:inline 1} $Coin1_Coin1_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $Coin1_Coin1_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Coin1_Coin1_unpack($struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $Coin1_Coin1_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Coin1_Coin1_dummy_field);
    assume is#$Boolean(dummy_field);
}



procedure {:inline 1} $Coin1_initialize_$def(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $Coin1_initialize_$def(lr_account: $Value, tc_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(5, 132, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(5, 132, 1, tc_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    $tmp := $Integer(1);
    $t4 := $tmp;
    $tmp := $Integer(2);
    $t5 := $tmp;
    call $t6 := $FixedPoint32_create_from_rational($t4, $t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(1000000);
    $t7 := $tmp;
    $tmp := $Integer(100);
    $t8 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(67)][1 := $Integer(111)][2 := $Integer(105)][3 := $Integer(110)][4 := $Integer(49)], 5));
    $t9 := $tmp;
    call $Libra_register_SCS_currency($Coin1_Coin1_type_value(), $t2, $t3, $t6, $t7, $t8, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    $t10 := $tmp;
    call $AccountLimits_publish_unrestricted_limits($Coin1_Coin1_type_value(), $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Coin1_initialize_$direct_inter(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $Coin1_initialize_$direct_inter(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $Coin1_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $Coin1_initialize_$direct_intra(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $Coin1_initialize_$direct_intra(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $Coin1_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $Coin1_initialize(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $Coin1_initialize(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $Coin1_initialize_$def(lr_account, tc_account);
}



const unique $Coin2_Coin2: $TypeName;

const $Coin2_Coin2_dummy_field: $FieldName;

axiom $Coin2_Coin2_dummy_field == 0;

function $Coin2_Coin2_type_value() : $TypeValue;

axiom $Coin2_Coin2_type_value(): $TypeValue == $StructType($Coin2_Coin2, $EmptyTypeValueArray);

var $Coin2_Coin2_$memory: $Memory;

var $Coin2_Coin2_$memory_$old: $Memory;

function {:inline} $Coin2_Coin2_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Coin2_Coin2_dummy_field))
}

function {:inline} $Coin2_Coin2_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $Coin2_Coin2_dummy_field))
}

procedure {:inline 1} $Coin2_Coin2_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $Coin2_Coin2_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $Coin2_Coin2_unpack($struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $Coin2_Coin2_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Coin2_Coin2_dummy_field);
    assume is#$Boolean(dummy_field);
}



procedure {:inline 1} $Coin2_initialize_$def(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $Coin2_initialize_$def(lr_account: $Value, tc_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(6, 132, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(6, 132, 1, tc_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    $tmp := $Integer(1);
    $t4 := $tmp;
    $tmp := $Integer(2);
    $t5 := $tmp;
    call $t6 := $FixedPoint32_create_from_rational($t4, $t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(1000000);
    $t7 := $tmp;
    $tmp := $Integer(100);
    $t8 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(67)][1 := $Integer(111)][2 := $Integer(105)][3 := $Integer(110)][4 := $Integer(50)], 5));
    $t9 := $tmp;
    call $Libra_register_SCS_currency($Coin2_Coin2_type_value(), $t2, $t3, $t6, $t7, $t8, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    $t10 := $tmp;
    call $AccountLimits_publish_unrestricted_limits($Coin2_Coin2_type_value(), $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Coin2_initialize_$direct_inter(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $Coin2_initialize_$direct_inter(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $Coin2_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $Coin2_initialize_$direct_intra(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $Coin2_initialize_$direct_intra(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $Coin2_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $Coin2_initialize(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $Coin2_initialize(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $Coin2_initialize_$def(lr_account, tc_account);
}



function {:inline} $DesignatedDealer_spec_exists_at($DesignatedDealer_Dealer_$memory: $Memory, addr: $Value) : $Value
{
  $ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, addr)
}

function {:inline} $DesignatedDealer_SPEC_MAX_NUM_TIERS() : $Value
{
  $Integer(4)
}

function {:inline} $DesignatedDealer_spec_window_length() : $Value
{
  $Integer(86400000000)
}

function {:inline} $DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory: $Memory, $tv0: $TypeValue, dd_addr: $Value) : $Value
{
  $ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)
}

function {:inline} $DesignatedDealer_current_time$12($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $tv0: $TypeValue) : $Value
{
  $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)
}

const unique $DesignatedDealer_Dealer: $TypeName;

const $DesignatedDealer_Dealer_mint_event_handle: $FieldName;

axiom $DesignatedDealer_Dealer_mint_event_handle == 0;

function $DesignatedDealer_Dealer_type_value() : $TypeValue;

axiom $DesignatedDealer_Dealer_type_value(): $TypeValue == $StructType($DesignatedDealer_Dealer, $EmptyTypeValueArray);

var $DesignatedDealer_Dealer_$memory: $Memory;

var $DesignatedDealer_Dealer_$memory_$old: $Memory;

function {:inline} $DesignatedDealer_Dealer_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Event_EventHandle_is_well_formed_types($SelectField($this, $DesignatedDealer_Dealer_mint_event_handle))
}

function {:inline} $DesignatedDealer_Dealer_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Event_EventHandle_is_well_formed($SelectField($this, $DesignatedDealer_Dealer_mint_event_handle))
}

procedure {:inline 1} $DesignatedDealer_Dealer_pack($file_id: int, $byte_index: int, $var_idx: int, mint_event_handle: $Value) returns ($struct: $Value);



implementation {:inline 1} $DesignatedDealer_Dealer_pack($file_id: int, $byte_index: int, $var_idx: int, mint_event_handle: $Value) returns ($struct: $Value)
{
    assume $Event_EventHandle_is_well_formed(mint_event_handle);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := mint_event_handle], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $DesignatedDealer_Dealer_unpack($struct: $Value) returns (mint_event_handle: $Value);



implementation {:inline 1} $DesignatedDealer_Dealer_unpack($struct: $Value) returns (mint_event_handle: $Value)
{
    assume is#$Vector($struct);
    mint_event_handle := $SelectField($struct, $DesignatedDealer_Dealer_mint_event_handle);
    assume $Event_EventHandle_is_well_formed(mint_event_handle);
}



const unique $DesignatedDealer_ReceivedMintEvent: $TypeName;

const $DesignatedDealer_ReceivedMintEvent_currency_code: $FieldName;

axiom $DesignatedDealer_ReceivedMintEvent_currency_code == 0;

const $DesignatedDealer_ReceivedMintEvent_destination_address: $FieldName;

axiom $DesignatedDealer_ReceivedMintEvent_destination_address == 1;

const $DesignatedDealer_ReceivedMintEvent_amount: $FieldName;

axiom $DesignatedDealer_ReceivedMintEvent_amount == 2;

function $DesignatedDealer_ReceivedMintEvent_type_value() : $TypeValue;

axiom $DesignatedDealer_ReceivedMintEvent_type_value(): $TypeValue == $StructType($DesignatedDealer_ReceivedMintEvent, $EmptyTypeValueArray);

var $DesignatedDealer_ReceivedMintEvent_$memory: $Memory;

var $DesignatedDealer_ReceivedMintEvent_$memory_$old: $Memory;

function {:inline} $DesignatedDealer_ReceivedMintEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $Vector_is_well_formed($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier661"} { $select_vector($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code), $$0))) && is#$Address($SelectField($this, $DesignatedDealer_ReceivedMintEvent_destination_address)) && $IsValidU64($SelectField($this, $DesignatedDealer_ReceivedMintEvent_amount))
}

function {:inline} $DesignatedDealer_ReceivedMintEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $Vector_is_well_formed($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier662"} { $select_vector($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code), $$0))) && is#$Address($SelectField($this, $DesignatedDealer_ReceivedMintEvent_destination_address)) && $IsValidU64($SelectField($this, $DesignatedDealer_ReceivedMintEvent_amount))
}

procedure {:inline 1} $DesignatedDealer_ReceivedMintEvent_pack($file_id: int, $byte_index: int, $var_idx: int, currency_code: $Value, destination_address: $Value, amount: $Value) returns ($struct: $Value);



implementation {:inline 1} $DesignatedDealer_ReceivedMintEvent_pack($file_id: int, $byte_index: int, $var_idx: int, currency_code: $Value, destination_address: $Value, amount: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier663"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    assume is#$Address(destination_address);
    assume $IsValidU64(amount);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := currency_code][1 := destination_address][2 := amount], 3));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $DesignatedDealer_ReceivedMintEvent_unpack($struct: $Value) returns (currency_code: $Value, destination_address: $Value, amount: $Value);



implementation {:inline 1} $DesignatedDealer_ReceivedMintEvent_unpack($struct: $Value) returns (currency_code: $Value, destination_address: $Value, amount: $Value)
{
    assume is#$Vector($struct);
    currency_code := $SelectField($struct, $DesignatedDealer_ReceivedMintEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier664"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    destination_address := $SelectField($struct, $DesignatedDealer_ReceivedMintEvent_destination_address);
    assume is#$Address(destination_address);
    amount := $SelectField($struct, $DesignatedDealer_ReceivedMintEvent_amount);
    assume $IsValidU64(amount);
}



const unique $DesignatedDealer_TierInfo: $TypeName;

const $DesignatedDealer_TierInfo_window_start: $FieldName;

axiom $DesignatedDealer_TierInfo_window_start == 0;

const $DesignatedDealer_TierInfo_window_inflow: $FieldName;

axiom $DesignatedDealer_TierInfo_window_inflow == 1;

const $DesignatedDealer_TierInfo_tiers: $FieldName;

axiom $DesignatedDealer_TierInfo_tiers == 2;

function $DesignatedDealer_TierInfo_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier665"} { $DesignatedDealer_TierInfo_type_value($tv0): $TypeValue } $DesignatedDealer_TierInfo_type_value($tv0): $TypeValue == $StructType($DesignatedDealer_TierInfo, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $DesignatedDealer_TierInfo_$memory: $Memory;

var $DesignatedDealer_TierInfo_$memory_$old: $Memory;

function {:inline} $DesignatedDealer_TierInfo_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $DesignatedDealer_TierInfo_window_start)) && $IsValidU64($SelectField($this, $DesignatedDealer_TierInfo_window_inflow)) && $Vector_is_well_formed($SelectField($this, $DesignatedDealer_TierInfo_tiers)) && (forall $$0: int :: {:qid "quantifier666"} { $select_vector($SelectField($this, $DesignatedDealer_TierInfo_tiers), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DesignatedDealer_TierInfo_tiers)) ==> $IsValidU64($select_vector($SelectField($this, $DesignatedDealer_TierInfo_tiers), $$0)))
}

function {:inline} $DesignatedDealer_TierInfo_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $IsValidU64($SelectField($this, $DesignatedDealer_TierInfo_window_start)) && $IsValidU64($SelectField($this, $DesignatedDealer_TierInfo_window_inflow)) && $Vector_is_well_formed($SelectField($this, $DesignatedDealer_TierInfo_tiers)) && (forall $$0: int :: {:qid "quantifier667"} { $select_vector($SelectField($this, $DesignatedDealer_TierInfo_tiers), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DesignatedDealer_TierInfo_tiers)) ==> $IsValidU64($select_vector($SelectField($this, $DesignatedDealer_TierInfo_tiers), $$0))) && b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($this, $DesignatedDealer_TierInfo_tiers))) <= i#$Integer($DesignatedDealer_SPEC_MAX_NUM_TIERS()))) && b#$Boolean($Boolean((var $range_1 := $Range($Integer(0), $vlen_value($SelectField($this, $DesignatedDealer_TierInfo_tiers))); (forall $i_0: int :: {:qid "quantifier668"} $InRange($range_1, $i_0) ==> (var i := $Integer($i_0); b#$Boolean($Boolean((var $range_3 := $Range($Integer(0), $vlen_value($SelectField($this, $DesignatedDealer_TierInfo_tiers))); (forall $i_2: int :: {:qid "quantifier669"} $InRange($range_3, $i_2) ==> (var j := $Integer($i_2); b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer(i) < i#$Integer(j))) ==> b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($this, $DesignatedDealer_TierInfo_tiers), i)) < i#$Integer($select_vector_by_value($SelectField($this, $DesignatedDealer_TierInfo_tiers), j))))))))))))))))
}

procedure {:inline 1} $DesignatedDealer_TierInfo_before_update_inv($tv0: $TypeValue, $before: $Value);



implementation {:inline 1} $DesignatedDealer_TierInfo_before_update_inv($tv0: $TypeValue, $before: $Value)
{
    assume b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($before, $DesignatedDealer_TierInfo_tiers))) <= i#$Integer($DesignatedDealer_SPEC_MAX_NUM_TIERS())));
    assume b#$Boolean($Boolean((var $range_5 := $Range($Integer(0), $vlen_value($SelectField($before, $DesignatedDealer_TierInfo_tiers))); (forall $i_4: int :: {:qid "quantifier670"} $InRange($range_5, $i_4) ==> (var i := $Integer($i_4); b#$Boolean($Boolean((var $range_7 := $Range($Integer(0), $vlen_value($SelectField($before, $DesignatedDealer_TierInfo_tiers))); (forall $i_6: int :: {:qid "quantifier671"} $InRange($range_7, $i_6) ==> (var j := $Integer($i_6); b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer(i) < i#$Integer(j))) ==> b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($before, $DesignatedDealer_TierInfo_tiers), i)) < i#$Integer($select_vector_by_value($SelectField($before, $DesignatedDealer_TierInfo_tiers), j))))))))))))))));
}



procedure {:inline 1} $DesignatedDealer_TierInfo_after_update_inv($tv0: $TypeValue, $after: $Value);



implementation {:inline 1} $DesignatedDealer_TierInfo_after_update_inv($tv0: $TypeValue, $after: $Value)
{
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($after, $DesignatedDealer_TierInfo_tiers))) <= i#$Integer($DesignatedDealer_SPEC_MAX_NUM_TIERS())));
    assert b#$Boolean($Boolean((var $range_9 := $Range($Integer(0), $vlen_value($SelectField($after, $DesignatedDealer_TierInfo_tiers))); (forall $i_8: int :: {:qid "quantifier672"} $InRange($range_9, $i_8) ==> (var i := $Integer($i_8); b#$Boolean($Boolean((var $range_11 := $Range($Integer(0), $vlen_value($SelectField($after, $DesignatedDealer_TierInfo_tiers))); (forall $i_10: int :: {:qid "quantifier673"} $InRange($range_11, $i_10) ==> (var j := $Integer($i_10); b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer(i) < i#$Integer(j))) ==> b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($after, $DesignatedDealer_TierInfo_tiers), i)) < i#$Integer($select_vector_by_value($SelectField($after, $DesignatedDealer_TierInfo_tiers), j))))))))))))))));
}



procedure {:inline 1} $DesignatedDealer_TierInfo_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, window_start: $Value, window_inflow: $Value, tiers: $Value) returns ($struct: $Value);



implementation {:inline 1} $DesignatedDealer_TierInfo_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, window_start: $Value, window_inflow: $Value, tiers: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(window_start);
    assume $IsValidU64(window_inflow);
    assume $Vector_is_well_formed(tiers) && (forall $$0: int :: {:qid "quantifier674"} { $select_vector(tiers, $$0) } $$0 >= 0 && $$0 < $vlen(tiers) ==> $IsValidU64($select_vector(tiers, $$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := window_start][1 := window_inflow][2 := tiers], 3));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }

    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers))) <= i#$Integer($DesignatedDealer_SPEC_MAX_NUM_TIERS())));
    assert b#$Boolean($Boolean((var $range_1 := $Range($Integer(0), $vlen_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers))); (forall $i_0: int :: {:qid "quantifier675"} $InRange($range_1, $i_0) ==> (var i := $Integer($i_0); b#$Boolean($Boolean((var $range_3 := $Range($Integer(0), $vlen_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers))); (forall $i_2: int :: {:qid "quantifier676"} $InRange($range_3, $i_2) ==> (var j := $Integer($i_2); b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer(i) < i#$Integer(j))) ==> b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers), i)) < i#$Integer($select_vector_by_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers), j))))))))))))))));
}



procedure {:inline 1} $DesignatedDealer_TierInfo_unpack($tv0: $TypeValue, $struct: $Value) returns (window_start: $Value, window_inflow: $Value, tiers: $Value);



implementation {:inline 1} $DesignatedDealer_TierInfo_unpack($tv0: $TypeValue, $struct: $Value) returns (window_start: $Value, window_inflow: $Value, tiers: $Value)
{
    assume is#$Vector($struct);
    window_start := $SelectField($struct, $DesignatedDealer_TierInfo_window_start);
    assume $IsValidU64(window_start);
    window_inflow := $SelectField($struct, $DesignatedDealer_TierInfo_window_inflow);
    assume $IsValidU64(window_inflow);
    tiers := $SelectField($struct, $DesignatedDealer_TierInfo_tiers);
    assume $Vector_is_well_formed(tiers) && (forall $$0: int :: {:qid "quantifier677"} { $select_vector(tiers, $$0) } $$0 >= 0 && $$0 < $vlen(tiers) ==> $IsValidU64($select_vector(tiers, $$0)));
}



procedure {:inline 1} $DesignatedDealer_reset_window_$def($tv0: $TypeValue, dealer: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DesignatedDealer_reset_window_$def($tv0: $TypeValue, dealer: $Value) returns ($ret0: $Value)
{
  var current_time: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Mutation;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Mutation;
  var $t12: $Mutation;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Mutation;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(8, 10878, 0, dealer);
    }

    call $tmp := $CopyOrMoveValue(dealer);
    $t17 := $tmp;
    call $t18 := $BorrowLoc(17, $t17);
    call $t2 := $LibraTimestamp_now_microseconds();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t2);
    current_time := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 10952, 1, $tmp);
    }

    call $t4 := $CopyOrMoveRef($t18);
    call $tmp := $GetFieldFromReference($t4, $DesignatedDealer_TierInfo_window_start);
    $t5 := $tmp;
    call $t18 := $WritebackToReference($t4, $t18);
    call $tmp := $CopyOrMoveValue($t5);
    $t6 := $tmp;
    $tmp := $Integer(86400000000);
    $t7 := $tmp;
    call $tmp := $AddU64($t6, $t7);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 11050, $abort_code);
        goto Abort;
    }

    $t8 := $tmp;
    call $tmp := $Gt(current_time, $t8);
    $t9 := $tmp;
    $tmp := $t9;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t11 := $CopyOrMoveRef($t18);
    call $t12 := $BorrowField($t11, $DesignatedDealer_TierInfo_window_start);
    call $t18 := $WritebackToReference($t11, $t18);
    call $t12 := $WriteRef($t12, current_time);
    call $t18 := $WritebackToReference($t12, $t18);
    call $t11 := $WritebackToReference($t12, $t11);
    $tmp := $Integer(0);
    $t13 := $tmp;
    call $t14 := $CopyOrMoveRef($t18);
    call $t15 := $BorrowField($t14, $DesignatedDealer_TierInfo_window_inflow);
    call $t17 := $WritebackToValue($t14, 17, $t17);
    call $t15 := $WriteRef($t15, $t13);
    call $t17 := $WritebackToValue($t15, 17, $t17);
    call $t14 := $WritebackToReference($t15, $t14);
    goto L3;

  L2:
    call $t16 := $CopyOrMoveRef($t18);
    call $t17 := $WritebackToValue($t16, 17, $t17);
    goto L3;

  L3:
    $ret0 := $t17;
    if (true)
    {
        assume $DebugTrackLocal(8, 11011, 19, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DesignatedDealer_reset_window_$direct_intra($tv0: $TypeValue, dealer: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DesignatedDealer_reset_window_$direct_intra($tv0: $TypeValue, dealer: $Value) returns ($ret0: $Value)
{
    assume $DesignatedDealer_TierInfo_is_well_formed(dealer);
    call $ret0 := $DesignatedDealer_reset_window_$def($tv0, dealer);
}



procedure {:inline 1} $DesignatedDealer_reset_window($tv0: $TypeValue, dealer: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DesignatedDealer_reset_window($tv0: $TypeValue, dealer: $Value) returns ($ret0: $Value)
{
    assume $DesignatedDealer_TierInfo_is_well_formed(dealer);
    call $ret0 := $DesignatedDealer_reset_window_$def($tv0, dealer);
}



procedure {:inline 1} $DesignatedDealer_add_currency_$def($tv0: $TypeValue, dd: $Value, tc_account: $Value);



implementation {:inline 1} $DesignatedDealer_add_currency_$def($tv0: $TypeValue, dd: $Value, tc_account: $Value)
{
  var coin_scaling_factor: $Value;
  var dd_addr: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(8, 3974, 0, dd);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 3974, 1, tc_account);
    }

    call $tmp := $CopyOrMoveValue(dd);
    $t50 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t51 := $tmp;
    call $tmp := $CopyOrMoveValue($t50);
    $t8 := $tmp;
    call $t9 := $Signer_address_of($t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    dd_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 4078, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t51);
    $t10 := $tmp;
    call $t11 := $Roles_has_treasury_compliance_role($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 4120, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t51);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t50);
    $t14 := $tmp;
    $tmp := $Integer(0);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 4120, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L0:
    call $t17 := $DesignatedDealer_exists_at(dd_addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t17);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 4219, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t51);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue($t50);
    $t20 := $tmp;
    $tmp := $Integer(5);
    $t21 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 4219, i#$Integer($t21));
    }

    $abort_code := i#$Integer($t21);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t50);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t51);
    $t23 := $tmp;
    call $Libra_publish_preburn_to_account($tv0, $t22, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t50);
    $t24 := $tmp;
    call $t25 := $LibraTimestamp_now_microseconds();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(0);
    $t26 := $tmp;
    call $t27 := $Vector_empty($IntegerType());
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $DesignatedDealer_TierInfo_pack(0, 0, 0, $tv0, $t25, $t26, $t27);
    $t28 := $tmp;
    call $DesignatedDealer_TierInfo_$memory := $MoveTo($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t28, $t24);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 4335, $abort_code);
        goto Abort;
    }

    call $t29 := $Libra_scaling_factor($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t29);
    coin_scaling_factor := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 4574, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t51);
    $t30 := $tmp;
    $tmp := $Integer(500000);
    $t32 := $tmp;
    call $tmp := $MulU64($t32, coin_scaling_factor);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 4694, $abort_code);
        goto Abort;
    }

    $t34 := $tmp;
    call $DesignatedDealer_add_tier($tv0, $t30, dd_addr, $t34);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t51);
    $t35 := $tmp;
    $tmp := $Integer(5000000);
    $t37 := $tmp;
    call $tmp := $MulU64($t37, coin_scaling_factor);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 4781, $abort_code);
        goto Abort;
    }

    $t39 := $tmp;
    call $DesignatedDealer_add_tier($tv0, $t35, dd_addr, $t39);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t51);
    $t40 := $tmp;
    $tmp := $Integer(50000000);
    $t42 := $tmp;
    call $tmp := $MulU64($t42, coin_scaling_factor);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 4868, $abort_code);
        goto Abort;
    }

    $t44 := $tmp;
    call $DesignatedDealer_add_tier($tv0, $t40, dd_addr, $t44);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t51);
    $t45 := $tmp;
    $tmp := $Integer(500000000);
    $t47 := $tmp;
    call $tmp := $MulU64($t47, coin_scaling_factor);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 4955, $abort_code);
        goto Abort;
    }

    $t49 := $tmp;
    call $DesignatedDealer_add_tier($tv0, $t45, dd_addr, $t49);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DesignatedDealer_add_currency_$direct_inter($tv0: $TypeValue, dd: $Value, tc_account: $Value);



implementation {:inline 1} $DesignatedDealer_add_currency_$direct_inter($tv0: $TypeValue, dd: $Value, tc_account: $Value)
{
    assume is#$Address(dd);
    assume is#$Address(tc_account);
    call $DesignatedDealer_add_currency_$def($tv0, dd, tc_account);
}



procedure {:inline 1} $DesignatedDealer_add_currency_$direct_intra($tv0: $TypeValue, dd: $Value, tc_account: $Value);



implementation {:inline 1} $DesignatedDealer_add_currency_$direct_intra($tv0: $TypeValue, dd: $Value, tc_account: $Value)
{
    assume is#$Address(dd);
    assume is#$Address(tc_account);
    call $DesignatedDealer_add_currency_$def($tv0, dd, tc_account);
}



procedure {:inline 1} $DesignatedDealer_add_currency($tv0: $TypeValue, dd: $Value, tc_account: $Value);



implementation {:inline 1} $DesignatedDealer_add_currency($tv0: $TypeValue, dd: $Value, tc_account: $Value)
{
    assume is#$Address(dd);
    assume is#$Address(tc_account);
    call $DesignatedDealer_add_currency_$def($tv0, dd, tc_account);
}



procedure {:inline 1} $DesignatedDealer_add_tier_$def($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value);



implementation {:inline 1} $DesignatedDealer_add_tier_$def($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value)
{
  var last_tier: $Value;
  var number_of_tiers: $Value;
  var tiers: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Mutation;
  var $t20: $Mutation;
  var $t21: $Mutation;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Mutation;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Mutation;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Mutation;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Mutation;
  var $t49: $Value;
  var $t50: $Mutation;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(8, 5088, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 5088, 1, dd_addr);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 5088, 2, tier_upperbound);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t52 := $tmp;
    call $tmp := $CopyOrMoveValue(dd_addr);
    $t53 := $tmp;
    call $tmp := $CopyOrMoveValue(tier_upperbound);
    $t54 := $tmp;
    call $tmp := $CopyOrMoveValue($t52);
    $t14 := $tmp;
    call $t15 := $Roles_has_treasury_compliance_role($t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t15);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 5237, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(0);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 5237, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L0:
    call $t19 := $BorrowGlobal($DesignatedDealer_TierInfo_$memory, $t53, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 5353, $abort_code);
        goto Abort;
    }

    call $DesignatedDealer_TierInfo_before_update_inv($tv0, $Dereference($t19));
    call $t20 := $BorrowField($t19, $DesignatedDealer_TierInfo_tiers);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t19);
    call tiers := $CopyOrMoveRef($t20);
    if (true)
    {
        assume $DebugTrackLocal(8, 5340, 5, $Dereference(tiers));
    }

    call $t21 := $CopyOrMoveRef(tiers);
    call $tmp := $ReadRef($t21);
    $t22 := $tmp;
    call tiers := $WritebackToReference($t21, tiers);
    call $t23 := $Vector_length($IntegerType(), $t22);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t23);
    number_of_tiers := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 5419, 4, $tmp);
    }

    $tmp := $Integer(1);
    $t25 := $tmp;
    call $tmp := $AddU64(number_of_tiers, $t25);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 5491, $abort_code);
        goto Abort;
    }

    $t26 := $tmp;
    $tmp := $Integer(4);
    $t27 := $tmp;
    call $tmp := $Le($t26, $t27);
    $t28 := $tmp;
    call $tmp := $CopyOrMoveValue($t28);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 5468, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $t30 := $CopyOrMoveRef(tiers);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t30);
    call $t19 := $WritebackToReference($t30, $t19);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t19));
    $tmp := $Integer(1);
    $t31 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 5468, i#$Integer($t31));
    }

    $abort_code := i#$Integer($t31);
    goto Abort;

  L2:
    $tmp := $Integer(0);
    $t33 := $tmp;
    call $tmp := $Gt(number_of_tiers, $t33);
    $t34 := $tmp;
    $tmp := $t34;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    goto L6;

  L4:
    call $t35 := $CopyOrMoveRef(tiers);
    $tmp := $Integer(1);
    $t37 := $tmp;
    call $tmp := $Sub(number_of_tiers, $t37);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 5640, $abort_code);
        goto Abort;
    }

    $t38 := $tmp;
    call $tmp := $CopyOrMoveValue($t38);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 5616, 11, $tmp);
    }

    call $t10 := $CopyOrMoveRef($t35);
    if (true)
    {
        assume $DebugTrackLocal(8, 5616, 10, $Dereference($t10));
    }

    call $t39 := $CopyOrMoveRef($t10);
    call $tmp := $ReadRef($t39);
    $t40 := $tmp;
    call tiers := $WritebackToReference($t39, tiers);
    call $t42 := $Vector_borrow($IntegerType(), $t40, $t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t42);
    $t43 := $tmp;
    call $tmp := $CopyOrMoveValue($t43);
    last_tier := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 5589, 3, $tmp);
    }

    call $tmp := $Lt(last_tier, $t54);
    $t46 := $tmp;
    call $tmp := $CopyOrMoveValue($t46);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 5658, 12, $tmp);
    }

    $tmp := $t12;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    call $t48 := $CopyOrMoveRef(tiers);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t48);
    call $t19 := $WritebackToReference($t48, $t19);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t19));
    $tmp := $Integer(2);
    $t49 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 5658, i#$Integer($t49));
    }

    $abort_code := i#$Integer($t49);
    goto Abort;

  L6:
    call $t50 := $CopyOrMoveRef(tiers);
    call $tmp := $ReadRef($t50);
    $t55 := $tmp;
    call $t55 := $Vector_push_back($IntegerType(), $t55, $t54);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t50 := $WriteRef($t50, $t55);
    if (true)
    {
        assume $DebugTrackLocal(8, 5694, 5, $Dereference(tiers));
    }

    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t50);
    call $t19 := $WritebackToReference($t50, $t19);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t19));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DesignatedDealer_add_tier_$direct_inter($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($vlen_value($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers)), $Integer(i#$Integer($vlen_value($SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_tiers))) + i#$Integer($Integer(1))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($select_vector_by_value($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($vlen_value($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers))) - i#$Integer($Integer(1)))), tier_upperbound)));



implementation {:inline 1} $DesignatedDealer_add_tier_$direct_inter($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(dd_addr);
    assume $IsValidU64(tier_upperbound);
    call $DesignatedDealer_add_tier_$def($tv0, tc_account, dd_addr, tier_upperbound);
}



procedure {:inline 1} $DesignatedDealer_add_tier_$direct_intra($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value);



implementation {:inline 1} $DesignatedDealer_add_tier_$direct_intra($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(dd_addr);
    assume $IsValidU64(tier_upperbound);
    call $DesignatedDealer_add_tier_$def($tv0, tc_account, dd_addr, tier_upperbound);
}



procedure {:inline 1} $DesignatedDealer_add_tier($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value);



implementation {:inline 1} $DesignatedDealer_add_tier($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(dd_addr);
    assume $IsValidU64(tier_upperbound);
    call $DesignatedDealer_add_tier_$def($tv0, tc_account, dd_addr, tier_upperbound);
}



procedure {:inline 1} $DesignatedDealer_exists_at_$def(dd_addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DesignatedDealer_exists_at_$def(dd_addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(8, 9417, 0, dd_addr);
    }

    call $tmp := $CopyOrMoveValue(dd_addr);
    $t3 := $tmp;
    $tmp := $ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(8, 9472, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DesignatedDealer_exists_at_$direct_inter(dd_addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $DesignatedDealer_spec_exists_at($DesignatedDealer_Dealer_$memory, dd_addr))));



implementation {:inline 1} $DesignatedDealer_exists_at_$direct_inter(dd_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(dd_addr);
    call $ret0 := $DesignatedDealer_exists_at_$def(dd_addr);
}



procedure {:inline 1} $DesignatedDealer_exists_at_$direct_intra(dd_addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DesignatedDealer_exists_at_$direct_intra(dd_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(dd_addr);
    call $ret0 := $DesignatedDealer_exists_at_$def(dd_addr);
}



procedure {:inline 1} $DesignatedDealer_exists_at(dd_addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DesignatedDealer_exists_at(dd_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(dd_addr);
    call $ret0 := $DesignatedDealer_exists_at_$def(dd_addr);
}



procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_$def($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value);



implementation {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_$def($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(8, 2786, 0, dd);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 2786, 1, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 2786, 2, add_all_currencies);
    }

    call $tmp := $CopyOrMoveValue(dd);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t24 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    $t5 := $tmp;
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 2963, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t23);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t9 := $tmp;
    $tmp := $Integer(0);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 2963, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t22);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t12 := $tmp;
    call $t13 := $Event_new_event_handle($DesignatedDealer_ReceivedMintEvent_type_value(), $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $DesignatedDealer_Dealer_pack(0, 0, 0, $t13);
    $t14 := $tmp;
    call $DesignatedDealer_Dealer_$memory := $MoveTo($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $t14, $t11);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 3062, $abort_code);
        goto Abort;
    }

    $tmp := $t24;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $tmp := $CopyOrMoveValue($t22);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    $t17 := $tmp;
    call $DesignatedDealer_add_currency($Coin1_Coin1_type_value(), $t16, $t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t22);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    $t19 := $tmp;
    call $DesignatedDealer_add_currency($Coin2_Coin2_type_value(), $t18, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L5;

  L4:
    call $tmp := $CopyOrMoveValue($t22);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    $t21 := $tmp;
    call $DesignatedDealer_add_currency($tv0, $t20, $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L5;

  L5:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_$direct_inter($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value);



implementation {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_$direct_inter($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value)
{
    assume is#$Address(dd);
    assume is#$Address(tc_account);
    assume is#$Boolean(add_all_currencies);
    call $DesignatedDealer_publish_designated_dealer_credential_$def($tv0, dd, tc_account, add_all_currencies);
}



procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_$direct_intra($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value);



implementation {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_$direct_intra($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value)
{
    assume is#$Address(dd);
    assume is#$Address(tc_account);
    assume is#$Boolean(add_all_currencies);
    call $DesignatedDealer_publish_designated_dealer_credential_$def($tv0, dd, tc_account, add_all_currencies);
}



procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value);



implementation {:inline 1} $DesignatedDealer_publish_designated_dealer_credential($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value)
{
    assume is#$Address(dd);
    assume is#$Address(tc_account);
    assume is#$Boolean(add_all_currencies);
    call $DesignatedDealer_publish_designated_dealer_credential_$def($tv0, dd, tc_account, add_all_currencies);
}



procedure {:inline 1} $DesignatedDealer_tiered_mint_$def($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DesignatedDealer_tiered_mint_$def($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value)
{
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Mutation;
  var $t31: $Mutation;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(8, 7668, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 7668, 1, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 7668, 2, dd_addr);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 7668, 3, tier_index);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t39 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t40 := $tmp;
    call $tmp := $CopyOrMoveValue(dd_addr);
    $t41 := $tmp;
    call $tmp := $CopyOrMoveValue(tier_index);
    $t42 := $tmp;
    call $tmp := $CopyOrMoveValue($t39);
    $t10 := $tmp;
    call $t11 := $Roles_has_treasury_compliance_role($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 7862, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t39);
    $t13 := $tmp;
    $tmp := $Integer(0);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 7862, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L0:
    $tmp := $Integer(0);
    $t16 := $tmp;
    call $tmp := $Gt($t40, $t16);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 7961, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t39);
    $t19 := $tmp;
    $tmp := $Integer(4);
    $t20 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 7961, i#$Integer($t20));
    }

    $abort_code := i#$Integer($t20);
    goto Abort;

  L2:
    call $t22 := $DesignatedDealer_exists_at($t41);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t22);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 8011, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $tmp := $CopyOrMoveValue($t39);
    $t24 := $tmp;
    $tmp := $Integer(5);
    $t25 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 8011, i#$Integer($t25));
    }

    $abort_code := i#$Integer($t25);
    goto Abort;

  L4:
    call $DesignatedDealer_validate_and_record_mint($tv0, $t41, $t40, $t42);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t30 := $BorrowGlobal($DesignatedDealer_Dealer_$memory, $t41, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 8221, $abort_code);
        goto Abort;
    }

    call $t31 := $BorrowField($t30, $DesignatedDealer_Dealer_mint_event_handle);
    call $DesignatedDealer_Dealer_$memory := $WritebackToGlobal($DesignatedDealer_Dealer_$memory, $t30);
    call $t32 := $Libra_currency_code($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $DesignatedDealer_ReceivedMintEvent_pack(0, 0, 0, $t32, $t41, $t40);
    $t35 := $tmp;
    call $tmp := $ReadRef($t31);
    $t43 := $tmp;
    call $t43 := $Event_emit_event($DesignatedDealer_ReceivedMintEvent_type_value(), $t43, $t35);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t31 := $WriteRef($t31, $t43);
    call $DesignatedDealer_Dealer_$memory := $WritebackToGlobal($DesignatedDealer_Dealer_$memory, $t31);
    call $t30 := $WritebackToReference($t31, $t30);
    call $tmp := $CopyOrMoveValue($t39);
    $t36 := $tmp;
    call $t38 := $Libra_mint($tv0, $t36, $t40);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t38;
    if (true)
    {
        assume $DebugTrackLocal(8, 8484, 44, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DesignatedDealer_tiered_mint_$direct_inter($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean(i#$Integer(old($SelectField($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start))) <= i#$Integer($SelectField($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start), $DesignatedDealer_current_time$12($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)))) && b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow), amount))))) || b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual(old($SelectField($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)), $SelectField($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)))) && b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow), $Integer(i#$Integer(old($SelectField($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow))) + i#$Integer(amount)))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(i#$Integer(tier_index) < i#$Integer($vlen_value($SelectField(old($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)), $DesignatedDealer_TierInfo_tiers)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(i#$Integer($SelectField($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow)) <= i#$Integer($select_vector_by_value($SelectField(old($DesignatedDealer_dealer$11($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)), $DesignatedDealer_TierInfo_tiers), tier_index))));



implementation {:inline 1} $DesignatedDealer_tiered_mint_$direct_inter($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value)
{
    assume is#$Address(tc_account);
    assume $IsValidU64(amount);
    assume is#$Address(dd_addr);
    assume $IsValidU64(tier_index);
    call $ret0 := $DesignatedDealer_tiered_mint_$def($tv0, tc_account, amount, dd_addr, tier_index);
}



procedure {:inline 1} $DesignatedDealer_tiered_mint_$direct_intra($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DesignatedDealer_tiered_mint_$direct_intra($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value)
{
    assume is#$Address(tc_account);
    assume $IsValidU64(amount);
    assume is#$Address(dd_addr);
    assume $IsValidU64(tier_index);
    call $ret0 := $DesignatedDealer_tiered_mint_$def($tv0, tc_account, amount, dd_addr, tier_index);
}



procedure {:inline 1} $DesignatedDealer_tiered_mint($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DesignatedDealer_tiered_mint($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value)
{
    assume is#$Address(tc_account);
    assume $IsValidU64(amount);
    assume is#$Address(dd_addr);
    assume $IsValidU64(tier_index);
    call $ret0 := $DesignatedDealer_tiered_mint_$def($tv0, tc_account, amount, dd_addr, tier_index);
}



procedure {:inline 1} $DesignatedDealer_update_tier_$def($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value);



implementation {:inline 1} $DesignatedDealer_update_tier_$def($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value)
{
  var next_tier_index: $Value;
  var number_of_tiers: $Value;
  var prev_tier_index: $Value;
  var tier: $Value;
  var tiers: $Mutation;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Mutation;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Mutation;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Mutation;
  var $t30: $Mutation;
  var $t31: $Mutation;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Mutation;
  var $t39: $Value;
  var $t40: $Mutation;
  var $t41: $Value;
  var $t42: $Mutation;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Mutation;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $t56: $Value;
  var $t57: $Value;
  var $t58: $Value;
  var $t59: $Value;
  var $t60: $Value;
  var $t61: $Value;
  var $t62: $Mutation;
  var $t63: $Value;
  var $t64: $Value;
  var $t65: $Mutation;
  var $t66: $Value;
  var $t67: $Value;
  var $t68: $Value;
  var $t69: $Value;
  var $t70: $Value;
  var $t71: $Value;
  var $t72: $Mutation;
  var $t73: $Value;
  var $t74: $Value;
  var $t75: $Value;
  var $t76: $Value;
  var $t77: $Value;
  var $t78: $Value;
  var $t79: $Value;
  var $t80: $Value;
  var $t81: $Value;
  var $t82: $Value;
  var $t83: $Value;
  var $t84: $Value;
  var $t85: $Value;
  var $t86: $Value;
  var $t87: $Mutation;
  var $t88: $Value;
  var $t89: $Value;
  var $t90: $Mutation;
  var $t91: $Value;
  var $t92: $Value;
  var $t93: $Value;
  var $t94: $Value;
  var $t95: $Value;
  var $t96: $Value;
  var $t97: $Mutation;
  var $t98: $Value;
  var $t99: $Value;
  var $t100: $Mutation;
  var $t101: $Value;
  var $t102: $Mutation;
  var $t103: $Value;
  var $t104: $Value;
  var $t105: $Value;
  var $t106: $Value;
  var $t107: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(8, 6135, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 6135, 1, dd_addr);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 6135, 2, tier_index);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 6135, 3, new_upperbound);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t103 := $tmp;
    call $tmp := $CopyOrMoveValue(dd_addr);
    $t104 := $tmp;
    call $tmp := $CopyOrMoveValue(tier_index);
    $t105 := $tmp;
    call $tmp := $CopyOrMoveValue(new_upperbound);
    $t106 := $tmp;
    call $tmp := $CopyOrMoveValue($t103);
    $t24 := $tmp;
    call $t25 := $Roles_has_treasury_compliance_role($t24);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t25);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 6311, 9, $tmp);
    }

    $tmp := $t9;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(0);
    $t27 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 6311, i#$Integer($t27));
    }

    $abort_code := i#$Integer($t27);
    goto Abort;

  L0:
    call $t29 := $BorrowGlobal($DesignatedDealer_TierInfo_$memory, $t104, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 6427, $abort_code);
        goto Abort;
    }

    call $DesignatedDealer_TierInfo_before_update_inv($tv0, $Dereference($t29));
    call $t30 := $BorrowField($t29, $DesignatedDealer_TierInfo_tiers);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t29);
    call tiers := $CopyOrMoveRef($t30);
    if (true)
    {
        assume $DebugTrackLocal(8, 6414, 8, $Dereference(tiers));
    }

    call $t31 := $CopyOrMoveRef(tiers);
    call $tmp := $ReadRef($t31);
    $t32 := $tmp;
    call tiers := $WritebackToReference($t31, tiers);
    call $t33 := $Vector_length($IntegerType(), $t32);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t33);
    number_of_tiers := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 6493, 5, $tmp);
    }

    call $tmp := $Lt($t105, number_of_tiers);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue($t36);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 6542, 11, $tmp);
    }

    $tmp := $t11;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $t38 := $CopyOrMoveRef(tiers);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t38);
    call $t29 := $WritebackToReference($t38, $t29);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t29));
    $tmp := $Integer(3);
    $t39 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 6542, i#$Integer($t39));
    }

    $abort_code := i#$Integer($t39);
    goto Abort;

  L2:
    call $t40 := $CopyOrMoveRef(tiers);
    call $tmp := $CopyOrMoveValue($t105);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 6736, 14, $tmp);
    }

    call $t13 := $CopyOrMoveRef($t40);
    if (true)
    {
        assume $DebugTrackLocal(8, 6736, 13, $Dereference($t13));
    }

    call $t42 := $CopyOrMoveRef($t13);
    call $tmp := $ReadRef($t42);
    $t43 := $tmp;
    call tiers := $WritebackToReference($t42, tiers);
    call $t45 := $Vector_borrow($IntegerType(), $t43, $t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t45);
    tier := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 6715, 7, $tmp);
    }

    call $tmp := $CopyOrMoveValue(tier);
    $t46 := $tmp;
    call $tmp := $CopyOrMoveValue($t46);
    $t47 := $tmp;
    $tmp := $Boolean($IsEqual($t47, $t106));
    $t49 := $tmp;
    $tmp := $t49;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    goto L6;

  L4:
    call $t50 := $CopyOrMoveRef(tiers);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t50);
    call $t29 := $WritebackToReference($t50, $t29);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t29));
    call $tmp := $CopyOrMoveValue(tier);
    $t51 := $tmp;
    return;

  L6:
    call $tmp := $CopyOrMoveValue(tier);
    $t52 := $tmp;
    call $tmp := $CopyOrMoveValue($t52);
    $t53 := $tmp;
    call $tmp := $Lt($t53, $t106);
    $t55 := $tmp;
    $tmp := $t55;
    if (b#$Boolean($tmp))
    {
        goto L7;
    }
    else
    {
        goto L8;
    }

  L8:
    goto L9;

  L7:
    $tmp := $Integer(1);
    $t57 := $tmp;
    call $tmp := $AddU64($t105, $t57);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 6885, $abort_code);
        goto Abort;
    }

    $t58 := $tmp;
    call $tmp := $CopyOrMoveValue($t58);
    next_tier_index := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 6856, 4, $tmp);
    }

    call $tmp := $Lt(next_tier_index, number_of_tiers);
    $t61 := $tmp;
    $tmp := $t61;
    if (b#$Boolean($tmp))
    {
        goto L10;
    }
    else
    {
        goto L11;
    }

  L11:
    goto L9;

  L10:
    call $t62 := $CopyOrMoveRef(tiers);
    call $tmp := $CopyOrMoveValue(next_tier_index);
    $t18 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 6998, 18, $tmp);
    }

    call $t17 := $CopyOrMoveRef($t62);
    if (true)
    {
        assume $DebugTrackLocal(8, 6998, 17, $Dereference($t17));
    }

    call $t65 := $CopyOrMoveRef($t17);
    call $tmp := $ReadRef($t65);
    $t66 := $tmp;
    call tiers := $WritebackToReference($t65, tiers);
    call $t68 := $Vector_borrow($IntegerType(), $t66, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t68);
    $t69 := $tmp;
    call $tmp := $Lt($t106, $t69);
    $t70 := $tmp;
    call $tmp := $CopyOrMoveValue($t70);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 6959, 15, $tmp);
    }

    $tmp := $t15;
    if (b#$Boolean($tmp))
    {
        goto L9;
    }
    else
    {
        goto L12;
    }

  L12:
    call $t72 := $CopyOrMoveRef(tiers);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t72);
    call $t29 := $WritebackToReference($t72, $t29);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t29));
    call $tmp := $CopyOrMoveValue(tier);
    $t73 := $tmp;
    $tmp := $Integer(2);
    $t74 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 6959, i#$Integer($t74));
    }

    $abort_code := i#$Integer($t74);
    goto Abort;

  L9:
    call $tmp := $CopyOrMoveValue(tier);
    $t75 := $tmp;
    call $tmp := $CopyOrMoveValue($t75);
    $t76 := $tmp;
    call $tmp := $Gt($t76, $t106);
    $t78 := $tmp;
    $tmp := $t78;
    if (b#$Boolean($tmp))
    {
        goto L13;
    }
    else
    {
        goto L14;
    }

  L14:
    goto L15;

  L13:
    $tmp := $Integer(0);
    $t80 := $tmp;
    call $tmp := $Gt($t105, $t80);
    $t81 := $tmp;
    call $tmp := $CopyOrMoveValue($t81);
    $t19 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 7084, 19, $tmp);
    }

    goto L16;

  L15:
    $tmp := $Boolean(false);
    $t82 := $tmp;
    call $tmp := $CopyOrMoveValue($t82);
    $t19 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 7084, 19, $tmp);
    }

    goto L16;

  L16:
    $tmp := $t19;
    if (b#$Boolean($tmp))
    {
        goto L17;
    }
    else
    {
        goto L18;
    }

  L18:
    goto L19;

  L17:
    $tmp := $Integer(1);
    $t85 := $tmp;
    call $tmp := $Sub($t105, $t85);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 7173, $abort_code);
        goto Abort;
    }

    $t86 := $tmp;
    call $tmp := $CopyOrMoveValue($t86);
    prev_tier_index := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 7144, 6, $tmp);
    }

    call $t87 := $CopyOrMoveRef(tiers);
    call $tmp := $CopyOrMoveValue(prev_tier_index);
    $t23 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 7229, 23, $tmp);
    }

    call $t22 := $CopyOrMoveRef($t87);
    if (true)
    {
        assume $DebugTrackLocal(8, 7229, 22, $Dereference($t22));
    }

    call $t90 := $CopyOrMoveRef($t22);
    call $tmp := $ReadRef($t90);
    $t91 := $tmp;
    call tiers := $WritebackToReference($t90, tiers);
    call $t93 := $Vector_borrow($IntegerType(), $t91, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t93);
    $t94 := $tmp;
    call $tmp := $Gt($t106, $t94);
    $t95 := $tmp;
    call $tmp := $CopyOrMoveValue($t95);
    $t20 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 7190, 20, $tmp);
    }

    $tmp := $t20;
    if (b#$Boolean($tmp))
    {
        goto L19;
    }
    else
    {
        goto L20;
    }

  L20:
    call $t97 := $CopyOrMoveRef(tiers);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t97);
    call $t29 := $WritebackToReference($t97, $t29);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t29));
    $tmp := $Integer(2);
    $t98 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 7190, i#$Integer($t98));
    }

    $abort_code := i#$Integer($t98);
    goto Abort;

  L19:
    call $t100 := $CopyOrMoveRef(tiers);
    call $tmp := $ReadRef($t100);
    $t107 := $tmp;
    call $t102, $t107 := $Vector_borrow_mut($IntegerType(), $t107, $t105);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t100 := $WriteRef($t100, $t107);
    if (true)
    {
        assume $DebugTrackLocal(8, 7229, 8, $Dereference(tiers));
    }

    call $t102 := $Splice1(0, $t100, $t102);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t100);
    call $t29 := $WritebackToReference($t100, $t29);
    call $t102 := $WriteRef($t102, $t106);
    if (true)
    {
        assume $DebugTrackLocal(8, 7296, 8, $Dereference(tiers));
    }

    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t102);
    call $t100 := $WritebackToReference($t102, $t100);
    call $t29 := $WritebackToReference($t100, $t29);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t29));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DesignatedDealer_update_tier_$direct_inter($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($vlen_value($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers)), $vlen_value($SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_tiers)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($select_vector_by_value($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index), new_upperbound)));



implementation {:inline 1} $DesignatedDealer_update_tier_$direct_inter($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(dd_addr);
    assume $IsValidU64(tier_index);
    assume $IsValidU64(new_upperbound);
    call $DesignatedDealer_update_tier_$def($tv0, tc_account, dd_addr, tier_index, new_upperbound);
}



procedure {:inline 1} $DesignatedDealer_update_tier_$direct_intra($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value);



implementation {:inline 1} $DesignatedDealer_update_tier_$direct_intra($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(dd_addr);
    assume $IsValidU64(tier_index);
    assume $IsValidU64(new_upperbound);
    call $DesignatedDealer_update_tier_$def($tv0, tc_account, dd_addr, tier_index, new_upperbound);
}



procedure {:inline 1} $DesignatedDealer_update_tier($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value);



implementation {:inline 1} $DesignatedDealer_update_tier($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(dd_addr);
    assume $IsValidU64(tier_index);
    assume $IsValidU64(new_upperbound);
    call $DesignatedDealer_update_tier_$def($tv0, tc_account, dd_addr, tier_index, new_upperbound);
}



procedure {:inline 1} $DesignatedDealer_validate_and_record_mint_$def($tv0: $TypeValue, dd_addr: $Value, amount: $Value, tier_index: $Value);



implementation {:inline 1} $DesignatedDealer_validate_and_record_mint_$def($tv0: $TypeValue, dd_addr: $Value, amount: $Value, tier_index: $Value)
{
  var cur_inflow: $Value;
  var new_inflow: $Value;
  var number_of_tiers: $Value;
  var tier: $Mutation;
  var tier_upperbound: $Value;
  var tiers: $Mutation;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Mutation;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Mutation;
  var $t25: $Mutation;
  var $t26: $Mutation;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Mutation;
  var $t34: $Mutation;
  var $t35: $Value;
  var $t36: $Mutation;
  var $t37: $Value;
  var $t38: $Mutation;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Mutation;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Mutation;
  var $t51: $Mutation;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(8, 10068, 0, dd_addr);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 10068, 1, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 10068, 2, tier_index);
    }

    call $tmp := $CopyOrMoveValue(dd_addr);
    $t52 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t53 := $tmp;
    call $tmp := $CopyOrMoveValue(tier_index);
    $t54 := $tmp;
    call $t16 := $BorrowGlobal($DesignatedDealer_TierInfo_$memory, $t52, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 10198, $abort_code);
        goto Abort;
    }

    call $DesignatedDealer_TierInfo_before_update_inv($tv0, $Dereference($t16));
    call tier := $CopyOrMoveRef($t16);
    if (true)
    {
        assume $DebugTrackLocal(8, 10191, 6, $Dereference(tier));
    }

    call $t17 := $CopyOrMoveRef(tier);
    call $tmp := $ReadRef($t17);
    $t55 := $tmp;
    call $t55 := $DesignatedDealer_reset_window($tv0, $t55);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t17 := $WriteRef($t17, $t55);
    if (true)
    {
        assume $DebugTrackLocal(8, 10639, 6, $Dereference(tier));
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 10639, 8, $Dereference(tiers));
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 10639, 11, $Dereference($t11));
    }

    call tier := $WritebackToReference($t17, tier);
    call $t18 := $CopyOrMoveRef(tier);
    call $tmp := $GetFieldFromReference($t18, $DesignatedDealer_TierInfo_window_inflow);
    $t19 := $tmp;
    call tier := $WritebackToReference($t18, tier);
    call $tmp := $CopyOrMoveValue($t19);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    cur_inflow := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 10286, 3, $tmp);
    }

    call $tmp := $AddU64(cur_inflow, $t53);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(8, 10355, $abort_code);
        goto Abort;
    }

    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    new_inflow := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 10331, 4, $tmp);
    }

    call $t24 := $CopyOrMoveRef(tier);
    call $t25 := $BorrowField($t24, $DesignatedDealer_TierInfo_tiers);
    call tier := $WritebackToReference($t24, tier);
    call tiers := $CopyOrMoveRef($t25);
    if (true)
    {
        assume $DebugTrackLocal(8, 10377, 8, $Dereference(tiers));
    }

    call $t26 := $CopyOrMoveRef(tiers);
    call $tmp := $ReadRef($t26);
    $t27 := $tmp;
    call tiers := $WritebackToReference($t26, tiers);
    call $t28 := $Vector_length($IntegerType(), $t27);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t28);
    number_of_tiers := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 10414, 5, $tmp);
    }

    call $tmp := $Lt($t54, number_of_tiers);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 10463, 9, $tmp);
    }

    $tmp := $t9;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t33 := $CopyOrMoveRef(tiers);
    call tier := $WritebackToReference($t33, tier);
    call $t24 := $WritebackToReference($t33, $t24);
    call $t34 := $CopyOrMoveRef(tier);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t34);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t34));
    $tmp := $Integer(3);
    $t35 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 10463, i#$Integer($t35));
    }

    $abort_code := i#$Integer($t35);
    goto Abort;

  L0:
    call $t36 := $CopyOrMoveRef(tiers);
    call $tmp := $CopyOrMoveValue($t54);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 10572, 12, $tmp);
    }

    call $t11 := $CopyOrMoveRef($t36);
    if (true)
    {
        assume $DebugTrackLocal(8, 10572, 11, $Dereference($t11));
    }

    call $t38 := $CopyOrMoveRef($t11);
    call $tmp := $ReadRef($t38);
    $t39 := $tmp;
    call tier := $WritebackToReference($t38, tier);
    call $t24 := $WritebackToReference($t38, $t24);
    call $t41 := $Vector_borrow($IntegerType(), $t39, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t41);
    $t42 := $tmp;
    call $tmp := $CopyOrMoveValue($t42);
    tier_upperbound := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 10534, 7, $tmp);
    }

    call $tmp := $Le(new_inflow, tier_upperbound);
    $t45 := $tmp;
    call $tmp := $CopyOrMoveValue($t45);
    $t13 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(8, 10601, 13, $tmp);
    }

    $tmp := $t13;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $t47 := $CopyOrMoveRef(tier);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t47);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t47));
    $tmp := $Integer(6);
    $t48 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(8, 10601, i#$Integer($t48));
    }

    $abort_code := i#$Integer($t48);
    goto Abort;

  L2:
    call $t50 := $CopyOrMoveRef(tier);
    call $t51 := $BorrowField($t50, $DesignatedDealer_TierInfo_window_inflow);
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t50);
    call $t51 := $WriteRef($t51, new_inflow);
    if (true)
    {
        assume $DebugTrackLocal(8, 10674, 6, $Dereference(tier));
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 10674, 8, $Dereference(tiers));
    }

    if (true)
    {
        assume $DebugTrackLocal(8, 10674, 11, $Dereference($t11));
    }

    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t51);
    call $t50 := $WritebackToReference($t51, $t50);
    call $DesignatedDealer_TierInfo_after_update_inv($tv0, $Dereference($t50));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DesignatedDealer_validate_and_record_mint_$direct_intra($tv0: $TypeValue, dd_addr: $Value, amount: $Value, tier_index: $Value);



implementation {:inline 1} $DesignatedDealer_validate_and_record_mint_$direct_intra($tv0: $TypeValue, dd_addr: $Value, amount: $Value, tier_index: $Value)
{
    assume is#$Address(dd_addr);
    assume $IsValidU64(amount);
    assume $IsValidU64(tier_index);
    call $DesignatedDealer_validate_and_record_mint_$def($tv0, dd_addr, amount, tier_index);
}



procedure {:inline 1} $DesignatedDealer_validate_and_record_mint($tv0: $TypeValue, dd_addr: $Value, amount: $Value, tier_index: $Value);



implementation {:inline 1} $DesignatedDealer_validate_and_record_mint($tv0: $TypeValue, dd_addr: $Value, amount: $Value, tier_index: $Value)
{
    assume is#$Address(dd_addr);
    assume $IsValidU64(amount);
    assume $IsValidU64(tier_index);
    call $DesignatedDealer_validate_and_record_mint_$def($tv0, dd_addr, amount, tier_index);
}



function {:inline} $VASP_spec_has_account_limits($AccountLimits_Window_$memory: $Memory, $VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, $tv0: $TypeValue, addr: $Value) : $Value
{
  $AccountLimits_spec_has_window_published($AccountLimits_Window_$memory, $tv0, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))
}

function {:inline} $VASP_spec_parent_address($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, addr: $Value) : $Value
{
  (if b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, addr)) then addr else $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, addr), $VASP_ChildVASP_parent_vasp_addr))
}

function {:inline} $VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory: $Memory, addr: $Value) : $Value
{
  $ResourceExists($VASP_ParentVASP_$memory, $EmptyTypeValueArray, addr)
}

function {:inline} $VASP_spec_is_child_vasp($VASP_ChildVASP_$memory: $Memory, addr: $Value) : $Value
{
  $ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, addr)
}

function {:inline} $VASP_spec_is_vasp($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, addr: $Value) : $Value
{
  $Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, addr)) || b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, addr)))
}

function {:inline} $VASP_spec_is_same_vasp($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, addr1: $Value, addr2: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1)) && b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr2)))) && b#$Boolean($Boolean($IsEqual($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr2)))))
}

function {:inline} $VASP_spec_get_num_children($VASP_ParentVASP_$memory: $Memory, parent: $Value) : $Value
{
  $SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent), $VASP_ParentVASP_num_children)
}

const unique $VASP_ChildVASP: $TypeName;

const $VASP_ChildVASP_parent_vasp_addr: $FieldName;

axiom $VASP_ChildVASP_parent_vasp_addr == 0;

function $VASP_ChildVASP_type_value() : $TypeValue;

axiom $VASP_ChildVASP_type_value(): $TypeValue == $StructType($VASP_ChildVASP, $EmptyTypeValueArray);

var $VASP_ChildVASP_$memory: $Memory;

var $VASP_ChildVASP_$memory_$old: $Memory;

function {:inline} $VASP_ChildVASP_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Address($SelectField($this, $VASP_ChildVASP_parent_vasp_addr))
}

function {:inline} $VASP_ChildVASP_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Address($SelectField($this, $VASP_ChildVASP_parent_vasp_addr))
}

procedure {:inline 1} $VASP_ChildVASP_pack($file_id: int, $byte_index: int, $var_idx: int, parent_vasp_addr: $Value) returns ($struct: $Value);



implementation {:inline 1} $VASP_ChildVASP_pack($file_id: int, $byte_index: int, $var_idx: int, parent_vasp_addr: $Value) returns ($struct: $Value)
{
    assume is#$Address(parent_vasp_addr);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := parent_vasp_addr], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $VASP_ChildVASP_unpack($struct: $Value) returns (parent_vasp_addr: $Value);



implementation {:inline 1} $VASP_ChildVASP_unpack($struct: $Value) returns (parent_vasp_addr: $Value)
{
    assume is#$Vector($struct);
    parent_vasp_addr := $SelectField($struct, $VASP_ChildVASP_parent_vasp_addr);
    assume is#$Address(parent_vasp_addr);
}



const unique $VASP_ParentVASP: $TypeName;

const $VASP_ParentVASP_num_children: $FieldName;

axiom $VASP_ParentVASP_num_children == 0;

function $VASP_ParentVASP_type_value() : $TypeValue;

axiom $VASP_ParentVASP_type_value(): $TypeValue == $StructType($VASP_ParentVASP, $EmptyTypeValueArray);

var $VASP_ParentVASP_$memory: $Memory;

var $VASP_ParentVASP_$memory_$old: $Memory;

function {:inline} $VASP_ParentVASP_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $VASP_ParentVASP_num_children))
}

function {:inline} $VASP_ParentVASP_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $VASP_ParentVASP_num_children))
}

procedure {:inline 1} $VASP_ParentVASP_pack($file_id: int, $byte_index: int, $var_idx: int, num_children: $Value) returns ($struct: $Value);



implementation {:inline 1} $VASP_ParentVASP_pack($file_id: int, $byte_index: int, $var_idx: int, num_children: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(num_children);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := num_children], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $VASP_ParentVASP_unpack($struct: $Value) returns (num_children: $Value);



implementation {:inline 1} $VASP_ParentVASP_unpack($struct: $Value) returns (num_children: $Value)
{
    assume is#$Vector($struct);
    num_children := $SelectField($struct, $VASP_ParentVASP_num_children);
    assume $IsValidU64(num_children);
}



const unique $VASP_VASPOperationsResource: $TypeName;

const $VASP_VASPOperationsResource_limits_cap: $FieldName;

axiom $VASP_VASPOperationsResource_limits_cap == 0;

function $VASP_VASPOperationsResource_type_value() : $TypeValue;

axiom $VASP_VASPOperationsResource_type_value(): $TypeValue == $StructType($VASP_VASPOperationsResource, $EmptyTypeValueArray);

var $VASP_VASPOperationsResource_$memory: $Memory;

var $VASP_VASPOperationsResource_$memory_$old: $Memory;

function {:inline} $VASP_VASPOperationsResource_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $AccountLimits_AccountLimitMutationCapability_is_well_formed_types($SelectField($this, $VASP_VASPOperationsResource_limits_cap))
}

function {:inline} $VASP_VASPOperationsResource_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $AccountLimits_AccountLimitMutationCapability_is_well_formed($SelectField($this, $VASP_VASPOperationsResource_limits_cap))
}

procedure {:inline 1} $VASP_VASPOperationsResource_pack($file_id: int, $byte_index: int, $var_idx: int, limits_cap: $Value) returns ($struct: $Value);



implementation {:inline 1} $VASP_VASPOperationsResource_pack($file_id: int, $byte_index: int, $var_idx: int, limits_cap: $Value) returns ($struct: $Value)
{
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(limits_cap);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := limits_cap], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $VASP_VASPOperationsResource_unpack($struct: $Value) returns (limits_cap: $Value);



implementation {:inline 1} $VASP_VASPOperationsResource_unpack($struct: $Value) returns (limits_cap: $Value)
{
    assume is#$Vector($struct);
    limits_cap := $SelectField($struct, $VASP_VASPOperationsResource_limits_cap);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(limits_cap);
}



procedure {:inline 1} $VASP_initialize_$def(lr_account: $Value);



implementation {:inline 1} $VASP_initialize_$def(lr_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 1359, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t27 := $tmp;
    call $t7 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 1412, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t27);
    $t9 := $tmp;
    $tmp := $Integer(0);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 1412, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t27);
    $t11 := $tmp;
    call $t12 := $Roles_has_libra_root_role($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 1472, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t27);
    $t14 := $tmp;
    $tmp := $Integer(3);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 1472, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t27);
    $t16 := $tmp;
    call $t17 := $Signer_address_of($t16);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t18 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t17, $t18));
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue($t19);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 1545, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $tmp := $CopyOrMoveValue($t27);
    $t21 := $tmp;
    $tmp := $Integer(2);
    $t22 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 1545, i#$Integer($t22));
    }

    $abort_code := i#$Integer($t22);
    goto Abort;

  L4:
    call $tmp := $CopyOrMoveValue($t27);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t27);
    $t24 := $tmp;
    call $t25 := $AccountLimits_grant_mutation_capability($t24);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $VASP_VASPOperationsResource_pack(0, 0, 0, $t25);
    $t26 := $tmp;
    call $VASP_VASPOperationsResource_$memory := $MoveTo($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $t26, $t23);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(27, 1660, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $VASP_initialize_$direct_inter(lr_account: $Value);



implementation {:inline 1} $VASP_initialize_$direct_inter(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $VASP_initialize_$def(lr_account);
}



procedure {:inline 1} $VASP_initialize_$direct_intra(lr_account: $Value);



implementation {:inline 1} $VASP_initialize_$direct_intra(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $VASP_initialize_$def(lr_account);
}



procedure {:inline 1} $VASP_initialize(lr_account: $Value);



implementation {:inline 1} $VASP_initialize(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $VASP_initialize_$def(lr_account);
}



procedure {:inline 1} $VASP_add_account_limits_$def($tv0: $TypeValue, account: $Value);



implementation {:inline 1} $VASP_add_account_limits_$def($tv0: $TypeValue, account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 5686, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    call $t4 := $Roles_has_parent_VASP_role($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 5786, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t13);
    $t6 := $tmp;
    $tmp := $Integer(4);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 5786, i#$Integer($t7));
    }

    $abort_code := i#$Integer($t7);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t13);
    $t8 := $tmp;
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($VASP_VASPOperationsResource_$memory, $t9, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(27, 5936, $abort_code);
        goto Abort;
    }

    $t10 := $tmp;
    call $tmp := $GetFieldFromValue($t10, $VASP_VASPOperationsResource_limits_cap);
    $t11 := $tmp;
    call $t12 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $AccountLimits_publish_window($tv0, $t8, $t11, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $VASP_add_account_limits_$direct_inter($tv0: $TypeValue, account: $Value);



implementation {:inline 1} $VASP_add_account_limits_$direct_inter($tv0: $TypeValue, account: $Value)
{
    assume is#$Address(account);
    call $VASP_add_account_limits_$def($tv0, account);
}



procedure {:inline 1} $VASP_add_account_limits_$direct_intra($tv0: $TypeValue, account: $Value);



implementation {:inline 1} $VASP_add_account_limits_$direct_intra($tv0: $TypeValue, account: $Value)
{
    assume is#$Address(account);
    call $VASP_add_account_limits_$def($tv0, account);
}



procedure {:inline 1} $VASP_add_account_limits($tv0: $TypeValue, account: $Value);



implementation {:inline 1} $VASP_add_account_limits($tv0: $TypeValue, account: $Value)
{
    assume is#$Address(account);
    call $VASP_add_account_limits_$def($tv0, account);
}



procedure {:inline 1} $VASP_has_account_limits_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_has_account_limits_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 5013, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t4 := $tmp;
    call $t2 := $VASP_parent_address($t4);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t3 := $AccountLimits_has_window_published($tv0, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(27, 5103, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $VASP_has_account_limits_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_has_account_limits($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, addr))));



implementation {:inline 1} $VASP_has_account_limits_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $VASP_has_account_limits_$def($tv0, addr);
}



procedure {:inline 1} $VASP_has_account_limits_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_has_account_limits_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $VASP_has_account_limits_$def($tv0, addr);
}



procedure {:inline 1} $VASP_has_account_limits($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_has_account_limits($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $VASP_has_account_limits_$def($tv0, addr);
}



procedure {:inline 1} $VASP_is_child_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_is_child_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 7609, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;
    $tmp := $ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(27, 7660, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $VASP_is_child_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_child_$direct_intra(addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, addr))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall a: $Value :: {:qid "quantifier678"} is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall parent: $Value :: {:qid "quantifier679"} is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual(old($VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)), $VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)))))))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_child(addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_parent_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_is_parent_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 7183, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;
    $tmp := $ResourceExists($VASP_ParentVASP_$memory, $EmptyTypeValueArray, $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(27, 7235, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $VASP_is_parent_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_parent_$direct_intra(addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, addr))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall a: $Value :: {:qid "quantifier680"} is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall parent: $Value :: {:qid "quantifier681"} is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual(old($VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)), $VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)))))))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_parent(addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_same_vasp_$def(addr1: $Value, addr2: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_is_same_vasp_$def(addr1: $Value, addr2: $Value) returns ($ret0: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 8503, 0, addr1);
    }

    if (true)
    {
        assume $DebugTrackLocal(27, 8503, 1, addr2);
    }

    call $tmp := $CopyOrMoveValue(addr1);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(addr2);
    $t18 := $tmp;
    call $t5 := $VASP_is_vasp($t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t7 := $VASP_is_vasp($t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 8594, 2, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Boolean(false);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 8594, 2, $tmp);
    }

    goto L3;

  L3:
    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    goto L6;

  L4:
    call $t11 := $VASP_parent_address($t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t13 := $VASP_parent_address($t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t11, $t13));
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 8594, 3, $tmp);
    }

    goto L7;

  L6:
    $tmp := $Boolean(false);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 8594, 3, $tmp);
    }

    goto L7;

  L7:
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(27, 8594, 19, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $VASP_is_same_vasp_$direct_inter(addr1: $Value, addr2: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1, addr2))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_same_vasp_$direct_intra(addr1: $Value, addr2: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1, addr2))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall a: $Value :: {:qid "quantifier682"} is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall parent: $Value :: {:qid "quantifier683"} is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual(old($VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)), $VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)))))))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_same_vasp(addr1: $Value, addr2: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1, addr2))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_vasp_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_is_vasp_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 8019, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t8 := $tmp;
    call $t3 := $VASP_is_parent($t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $Boolean(true);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 8069, 1, $tmp);
    }

    goto L3;

  L2:
    call $t6 := $VASP_is_child($t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 8069, 1, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(27, 8069, 9, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $VASP_is_vasp_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_vasp_$direct_intra(addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall a: $Value :: {:qid "quantifier684"} is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall parent: $Value :: {:qid "quantifier685"} is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual(old($VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)), $VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)))))))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_is_vasp(addr: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $VASP_num_children_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_num_children_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 9281, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t6 := $tmp;
    call $t2 := $VASP_parent_address($t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($VASP_ParentVASP_$memory, $t2, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(27, 9369, $abort_code);
        goto Abort;
    }

    $t3 := $tmp;
    call $tmp := $GetFieldFromValue($t3, $VASP_ParentVASP_num_children);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t5 := $tmp;
    $ret0 := $t5;
    if (true)
    {
        assume $DebugTrackLocal(27, 9367, 7, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $VASP_num_children_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))))) || b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))))));



implementation {:inline 1} $VASP_num_children_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $VASP_num_children_$def(addr);
}



procedure {:inline 1} $VASP_num_children_$direct_intra(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_num_children_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $VASP_num_children_$def(addr);
}



procedure {:inline 1} $VASP_num_children(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_num_children(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $VASP_num_children_$def(addr);
}



procedure {:inline 1} $VASP_parent_address_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $VASP_parent_address_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 6405, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t15 := $tmp;
    call $t4 := $VASP_is_parent($t15);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $CopyOrMoveValue($t15);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 6484, 2, $tmp);
    }

    goto L3;

  L2:
    call $t7 := $VASP_is_child($t15);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    $tmp := $Integer(88);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 6679, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L4:
    call $tmp := $GetGlobal($VASP_ChildVASP_$memory, $t15, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(27, 6573, $abort_code);
        goto Abort;
    }

    $t10 := $tmp;
    call $tmp := $GetFieldFromValue($t10, $VASP_ChildVASP_parent_vasp_addr);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 6539, 1, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t1);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 6484, 2, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(27, 6484, 16, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $VASP_parent_address_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))));
  ensures is#$Address($ret0);



procedure {:inline 1} $VASP_parent_address_$direct_intra(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall a: $Value :: {:qid "quantifier686"} is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall parent: $Value :: {:qid "quantifier687"} is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual(old($VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)), $VASP_spec_get_num_children($VASP_ParentVASP_$memory, parent)))))))));
  ensures is#$Address($ret0);



procedure {:inline 1} $VASP_parent_address(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))));
  ensures is#$Address($ret0);



procedure {:inline 1} $VASP_publish_child_vasp_credential_$def(parent: $Value, child: $Value);



implementation {:inline 1} $VASP_publish_child_vasp_credential_$def(parent: $Value, child: $Value)
{
  var child_vasp_addr: $Value;
  var num_children: $Mutation;
  var parent_vasp_addr: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Mutation;
  var $t37: $Mutation;
  var $t38: $Mutation;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Mutation;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Mutation;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Mutation;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 2971, 0, parent);
    }

    if (true)
    {
        assume $DebugTrackLocal(27, 2971, 1, child);
    }

    call $tmp := $CopyOrMoveValue(parent);
    $t54 := $tmp;
    call $tmp := $CopyOrMoveValue(child);
    $t55 := $tmp;
    call $tmp := $CopyOrMoveValue($t54);
    $t13 := $tmp;
    call $t14 := $Roles_has_parent_VASP_role($t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 3441, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t54);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t55);
    $t17 := $tmp;
    $tmp := $Integer(4);
    $t18 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 3441, i#$Integer($t18));
    }

    $abort_code := i#$Integer($t18);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t55);
    $t19 := $tmp;
    call $t20 := $Signer_address_of($t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t20);
    child_vasp_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 3518, 2, $tmp);
    }

    call $t22 := $VASP_is_vasp(child_vasp_addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t22);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 3571, 7, $tmp);
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t54);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue($t55);
    $t26 := $tmp;
    $tmp := $Integer(7);
    $t27 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 3571, i#$Integer($t27));
    }

    $abort_code := i#$Integer($t27);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t54);
    $t28 := $tmp;
    call $t29 := $Signer_address_of($t28);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t29);
    parent_vasp_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 3635, 4, $tmp);
    }

    call $t31 := $VASP_is_parent(parent_vasp_addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t31);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 3690, 9, $tmp);
    }

    $tmp := $t9;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $tmp := $CopyOrMoveValue($t55);
    $t33 := $tmp;
    $tmp := $Integer(4);
    $t34 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 3690, i#$Integer($t34));
    }

    $abort_code := i#$Integer($t34);
    goto Abort;

  L4:
    call $t36 := $BorrowGlobal($VASP_ParentVASP_$memory, parent_vasp_addr, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(27, 3779, $abort_code);
        goto Abort;
    }

    call $t37 := $BorrowField($t36, $VASP_ParentVASP_num_children);
    call $VASP_ParentVASP_$memory := $WritebackToGlobal($VASP_ParentVASP_$memory, $t36);
    assert b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier688"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assert b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier689"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier690"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call num_children := $CopyOrMoveRef($t37);
    if (true)
    {
        assume $DebugTrackLocal(27, 3759, 3, $Dereference(num_children));
    }

    call $t38 := $CopyOrMoveRef(num_children);
    call $tmp := $ReadRef($t38);
    $t39 := $tmp;
    call num_children := $WritebackToReference($t38, num_children);
    $tmp := $Integer(256);
    $t40 := $tmp;
    call $tmp := $Lt($t39, $t40);
    $t41 := $tmp;
    call $tmp := $CopyOrMoveValue($t41);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 3938, 11, $tmp);
    }

    $tmp := $t11;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    call $t43 := $CopyOrMoveRef(num_children);
    call $VASP_ParentVASP_$memory := $WritebackToGlobal($VASP_ParentVASP_$memory, $t43);
    assert b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier691"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assert b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier692"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier693"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $t36 := $WritebackToReference($t43, $t36);
    call $tmp := $CopyOrMoveValue($t55);
    $t44 := $tmp;
    $tmp := $Integer(8);
    $t45 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 3938, i#$Integer($t45));
    }

    $abort_code := i#$Integer($t45);
    goto Abort;

  L6:
    call $t46 := $CopyOrMoveRef(num_children);
    call $tmp := $ReadRef($t46);
    $t47 := $tmp;
    call num_children := $WritebackToReference($t46, num_children);
    $tmp := $Integer(1);
    $t48 := $tmp;
    call $tmp := $AddU64($t47, $t48);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(27, 4040, $abort_code);
        goto Abort;
    }

    $t49 := $tmp;
    call $t50 := $CopyOrMoveRef(num_children);
    call $t50 := $WriteRef($t50, $t49);
    if (true)
    {
        assume $DebugTrackLocal(27, 4010, 3, $Dereference(num_children));
    }

    call $VASP_ParentVASP_$memory := $WritebackToGlobal($VASP_ParentVASP_$memory, $t50);
    assert b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier694"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assert b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier695"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier696"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $t36 := $WritebackToReference($t50, $t36);
    call $tmp := $CopyOrMoveValue($t55);
    $t51 := $tmp;
    call $tmp := $VASP_ChildVASP_pack(0, 0, 0, parent_vasp_addr);
    $t53 := $tmp;
    call $VASP_ChildVASP_$memory := $MoveTo($VASP_ChildVASP_$memory, $EmptyTypeValueArray, $t53, $t51);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(27, 4053, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier697"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier698"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $VASP_publish_child_vasp_credential_$direct_inter(parent: $Value, child: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(parent)))))) ==> $abort_flag;
  ensures b#$Boolean(old($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $Signer_spec_address_of(child)))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $Signer_spec_address_of(parent)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($VASP_spec_get_num_children($VASP_ParentVASP_$memory, $Signer_spec_address_of(parent))) + i#$Integer($Integer(1)))) > i#$Integer($Integer(256))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(parent)))))) || b#$Boolean(old($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $Signer_spec_address_of(child)))) || b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $Signer_spec_address_of(parent)))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($VASP_spec_get_num_children($VASP_ParentVASP_$memory, $Signer_spec_address_of(parent))) + i#$Integer($Integer(1)))) > i#$Integer($Integer(256)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($VASP_spec_get_num_children($VASP_ParentVASP_$memory, $Signer_spec_address_of(parent)), $Integer(i#$Integer(old($VASP_spec_get_num_children($VASP_ParentVASP_$memory, $Signer_spec_address_of(parent)))) + i#$Integer($Integer(1))))));
  ensures !$abort_flag ==> b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, $Signer_spec_address_of(child)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $Signer_spec_address_of(child)), $Signer_spec_address_of(parent))));



implementation {:inline 1} $VASP_publish_child_vasp_credential_$direct_inter(parent: $Value, child: $Value)
{
    assume is#$Address(parent);
    assume is#$Address(child);
    call $VASP_publish_child_vasp_credential_$def(parent, child);
}



procedure {:inline 1} $VASP_publish_child_vasp_credential_$direct_intra(parent: $Value, child: $Value);



implementation {:inline 1} $VASP_publish_child_vasp_credential_$direct_intra(parent: $Value, child: $Value)
{
    assume is#$Address(parent);
    assume is#$Address(child);
    call $VASP_publish_child_vasp_credential_$def(parent, child);
}



procedure {:inline 1} $VASP_publish_child_vasp_credential(parent: $Value, child: $Value);



implementation {:inline 1} $VASP_publish_child_vasp_credential(parent: $Value, child: $Value)
{
    assume is#$Address(parent);
    assume is#$Address(child);
    call $VASP_publish_child_vasp_credential_$def(parent, child);
}



procedure {:inline 1} $VASP_publish_parent_vasp_credential_$def(vasp: $Value, lr_account: $Value);



implementation {:inline 1} $VASP_publish_parent_vasp_credential_$def(vasp: $Value, lr_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var vasp_addr: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(27, 2199, 0, vasp);
    }

    if (true)
    {
        assume $DebugTrackLocal(27, 2199, 1, lr_account);
    }

    call $tmp := $CopyOrMoveValue(vasp);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue(lr_account);
    $t24 := $tmp;
    call $tmp := $CopyOrMoveValue($t24);
    $t7 := $tmp;
    call $t8 := $Roles_has_libra_root_role($t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 2287, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t23);
    $t10 := $tmp;
    $tmp := $Integer(3);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 2287, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t23);
    $t12 := $tmp;
    call $t13 := $Signer_address_of($t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    vasp_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 2364, 6, $tmp);
    }

    call $t15 := $VASP_is_vasp(vasp_addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t15);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(27, 2410, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t23);
    $t18 := $tmp;
    $tmp := $Integer(5);
    $t19 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(27, 2410, i#$Integer($t19));
    }

    $abort_code := i#$Integer($t19);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t23);
    $t20 := $tmp;
    $tmp := $Integer(0);
    $t21 := $tmp;
    call $tmp := $VASP_ParentVASP_pack(0, 0, 0, $t21);
    $t22 := $tmp;
    call $VASP_ParentVASP_$memory := $MoveTo($VASP_ParentVASP_$memory, $EmptyTypeValueArray, $t22, $t20);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(27, 2460, $abort_code);
        goto Abort;
    }

    assert b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier699"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assert b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier700"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assert b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier701"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $VASP_publish_parent_vasp_credential_$direct_inter(vasp: $Value, lr_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $Signer_spec_address_of(vasp)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $Signer_spec_address_of(vasp))));
  ensures !$abort_flag ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $Signer_spec_address_of(vasp)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($VASP_spec_get_num_children($VASP_ParentVASP_$memory, $Signer_spec_address_of(vasp)), $Integer(0))));



implementation {:inline 1} $VASP_publish_parent_vasp_credential_$direct_inter(vasp: $Value, lr_account: $Value)
{
    assume is#$Address(vasp);
    assume is#$Address(lr_account);
    call $VASP_publish_parent_vasp_credential_$def(vasp, lr_account);
}



procedure {:inline 1} $VASP_publish_parent_vasp_credential_$direct_intra(vasp: $Value, lr_account: $Value);



implementation {:inline 1} $VASP_publish_parent_vasp_credential_$direct_intra(vasp: $Value, lr_account: $Value)
{
    assume is#$Address(vasp);
    assume is#$Address(lr_account);
    call $VASP_publish_parent_vasp_credential_$def(vasp, lr_account);
}



procedure {:inline 1} $VASP_publish_parent_vasp_credential(vasp: $Value, lr_account: $Value);



implementation {:inline 1} $VASP_publish_parent_vasp_credential(vasp: $Value, lr_account: $Value)
{
    assume is#$Address(vasp);
    assume is#$Address(lr_account);
    call $VASP_publish_parent_vasp_credential_$def(vasp, lr_account);
}



function {:inline} $LBR_spec_is_initialized($LBR_Reserve_$memory: $Memory) : $Value
{
  $ResourceExists($LBR_Reserve_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS())
}

function {:inline} $LBR_spec_is_lbr($tv0: $TypeValue) : $Value
{
  $Boolean($IsEqual($Type($tv0), $Type($LBR_LBR_type_value())))
}

const unique $LBR_LBR: $TypeName;

const $LBR_LBR_dummy_field: $FieldName;

axiom $LBR_LBR_dummy_field == 0;

function $LBR_LBR_type_value() : $TypeValue;

axiom $LBR_LBR_type_value(): $TypeValue == $StructType($LBR_LBR, $EmptyTypeValueArray);

var $LBR_LBR_$memory: $Memory;

var $LBR_LBR_$memory_$old: $Memory;

function {:inline} $LBR_LBR_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $LBR_LBR_dummy_field))
}

function {:inline} $LBR_LBR_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $LBR_LBR_dummy_field))
}

procedure {:inline 1} $LBR_LBR_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $LBR_LBR_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LBR_LBR_unpack($struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $LBR_LBR_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LBR_LBR_dummy_field);
    assume is#$Boolean(dummy_field);
}



const unique $LBR_Reserve: $TypeName;

const $LBR_Reserve_mint_cap: $FieldName;

axiom $LBR_Reserve_mint_cap == 0;

const $LBR_Reserve_burn_cap: $FieldName;

axiom $LBR_Reserve_burn_cap == 1;

const $LBR_Reserve_preburn_cap: $FieldName;

axiom $LBR_Reserve_preburn_cap == 2;

const $LBR_Reserve_coin1: $FieldName;

axiom $LBR_Reserve_coin1 == 3;

const $LBR_Reserve_coin2: $FieldName;

axiom $LBR_Reserve_coin2 == 4;

function $LBR_Reserve_type_value() : $TypeValue;

axiom $LBR_Reserve_type_value(): $TypeValue == $StructType($LBR_Reserve, $EmptyTypeValueArray);

var $LBR_Reserve_$memory: $Memory;

var $LBR_Reserve_$memory_$old: $Memory;

function {:inline} $LBR_Reserve_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 5 && $Libra_MintCapability_is_well_formed_types($SelectField($this, $LBR_Reserve_mint_cap)) && $Libra_BurnCapability_is_well_formed_types($SelectField($this, $LBR_Reserve_burn_cap)) && $Libra_Preburn_is_well_formed_types($SelectField($this, $LBR_Reserve_preburn_cap)) && $LBR_ReserveComponent_is_well_formed_types($SelectField($this, $LBR_Reserve_coin1)) && $LBR_ReserveComponent_is_well_formed_types($SelectField($this, $LBR_Reserve_coin2))
}

function {:inline} $LBR_Reserve_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 5 && $Libra_MintCapability_is_well_formed($SelectField($this, $LBR_Reserve_mint_cap)) && $Libra_BurnCapability_is_well_formed($SelectField($this, $LBR_Reserve_burn_cap)) && $Libra_Preburn_is_well_formed($SelectField($this, $LBR_Reserve_preburn_cap)) && $LBR_ReserveComponent_is_well_formed($SelectField($this, $LBR_Reserve_coin1)) && $LBR_ReserveComponent_is_well_formed($SelectField($this, $LBR_Reserve_coin2))
}

procedure {:inline 1} $LBR_Reserve_pack($file_id: int, $byte_index: int, $var_idx: int, mint_cap: $Value, burn_cap: $Value, preburn_cap: $Value, coin1: $Value, coin2: $Value) returns ($struct: $Value);



implementation {:inline 1} $LBR_Reserve_pack($file_id: int, $byte_index: int, $var_idx: int, mint_cap: $Value, burn_cap: $Value, preburn_cap: $Value, coin1: $Value, coin2: $Value) returns ($struct: $Value)
{
    assume $Libra_MintCapability_is_well_formed(mint_cap);
    assume $Libra_BurnCapability_is_well_formed(burn_cap);
    assume $Libra_Preburn_is_well_formed(preburn_cap);
    assume $LBR_ReserveComponent_is_well_formed(coin1);
    assume $LBR_ReserveComponent_is_well_formed(coin2);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := mint_cap][1 := burn_cap][2 := preburn_cap][3 := coin1][4 := coin2], 5));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LBR_Reserve_unpack($struct: $Value) returns (mint_cap: $Value, burn_cap: $Value, preburn_cap: $Value, coin1: $Value, coin2: $Value);



implementation {:inline 1} $LBR_Reserve_unpack($struct: $Value) returns (mint_cap: $Value, burn_cap: $Value, preburn_cap: $Value, coin1: $Value, coin2: $Value)
{
    assume is#$Vector($struct);
    mint_cap := $SelectField($struct, $LBR_Reserve_mint_cap);
    assume $Libra_MintCapability_is_well_formed(mint_cap);
    burn_cap := $SelectField($struct, $LBR_Reserve_burn_cap);
    assume $Libra_BurnCapability_is_well_formed(burn_cap);
    preburn_cap := $SelectField($struct, $LBR_Reserve_preburn_cap);
    assume $Libra_Preburn_is_well_formed(preburn_cap);
    coin1 := $SelectField($struct, $LBR_Reserve_coin1);
    assume $LBR_ReserveComponent_is_well_formed(coin1);
    coin2 := $SelectField($struct, $LBR_Reserve_coin2);
    assume $LBR_ReserveComponent_is_well_formed(coin2);
}



const unique $LBR_ReserveComponent: $TypeName;

const $LBR_ReserveComponent_ratio: $FieldName;

axiom $LBR_ReserveComponent_ratio == 0;

const $LBR_ReserveComponent_backing: $FieldName;

axiom $LBR_ReserveComponent_backing == 1;

function $LBR_ReserveComponent_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier702"} { $LBR_ReserveComponent_type_value($tv0): $TypeValue } $LBR_ReserveComponent_type_value($tv0): $TypeValue == $StructType($LBR_ReserveComponent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $LBR_ReserveComponent_$memory: $Memory;

var $LBR_ReserveComponent_$memory_$old: $Memory;

function {:inline} $LBR_ReserveComponent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $FixedPoint32_FixedPoint32_is_well_formed_types($SelectField($this, $LBR_ReserveComponent_ratio)) && $Libra_Libra_is_well_formed_types($SelectField($this, $LBR_ReserveComponent_backing))
}

function {:inline} $LBR_ReserveComponent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $FixedPoint32_FixedPoint32_is_well_formed($SelectField($this, $LBR_ReserveComponent_ratio)) && $Libra_Libra_is_well_formed($SelectField($this, $LBR_ReserveComponent_backing))
}

procedure {:inline 1} $LBR_ReserveComponent_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, ratio: $Value, backing: $Value) returns ($struct: $Value);



implementation {:inline 1} $LBR_ReserveComponent_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, ratio: $Value, backing: $Value) returns ($struct: $Value)
{
    assume $FixedPoint32_FixedPoint32_is_well_formed(ratio);
    assume $Libra_Libra_is_well_formed(backing);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := ratio][1 := backing], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LBR_ReserveComponent_unpack($tv0: $TypeValue, $struct: $Value) returns (ratio: $Value, backing: $Value);



implementation {:inline 1} $LBR_ReserveComponent_unpack($tv0: $TypeValue, $struct: $Value) returns (ratio: $Value, backing: $Value)
{
    assume is#$Vector($struct);
    ratio := $SelectField($struct, $LBR_ReserveComponent_ratio);
    assume $FixedPoint32_FixedPoint32_is_well_formed(ratio);
    backing := $SelectField($struct, $LBR_ReserveComponent_backing);
    assume $Libra_Libra_is_well_formed(backing);
}



procedure {:inline 1} $LBR_initialize_$def(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $LBR_initialize_$def(lr_account: $Value, tc_account: $Value)
{
  var burn_cap: $Value;
  var coin1: $Value;
  var coin2: $Value;
  var mint_cap: $Value;
  var preburn_cap: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(13, 3899, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(13, 3899, 1, tc_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t47 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t48 := $tmp;
    call $tmp := $CopyOrMoveValue($t47);
    $t9 := $tmp;
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $LBR_reserve_address();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 4030, 7, $tmp);
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t48);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t47);
    $t15 := $tmp;
    $tmp := $Integer(0);
    $t16 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(13, 4030, i#$Integer($t16));
    }

    $abort_code := i#$Integer($t16);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t47);
    $t17 := $tmp;
    $tmp := $Integer(1);
    $t18 := $tmp;
    $tmp := $Integer(1);
    $t19 := $tmp;
    call $t20 := $FixedPoint32_create_from_rational($t18, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean(true);
    $t21 := $tmp;
    $tmp := $Integer(1000000);
    $t22 := $tmp;
    $tmp := $Integer(1000);
    $t23 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(76)][1 := $Integer(66)][2 := $Integer(82)], 3));
    $t24 := $tmp;
    call $t25, $t26 := $Libra_register_currency($LBR_LBR_type_value(), $t17, $t20, $t21, $t22, $t23, $t24);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t26);
    burn_cap := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 4182, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t25);
    mint_cap := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 4172, 5, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t47);
    $t27 := $tmp;
    call $AccountLimits_publish_unrestricted_limits($LBR_LBR_type_value(), $t27);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t48);
    $t28 := $tmp;
    call $t29 := $Libra_create_preburn($LBR_LBR_type_value(), $t28);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t29);
    preburn_cap := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 4568, 6, $tmp);
    }

    $tmp := $Integer(1);
    $t30 := $tmp;
    $tmp := $Integer(2);
    $t31 := $tmp;
    call $t32 := $FixedPoint32_create_from_rational($t30, $t31);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t33 := $Libra_zero($Coin1_Coin1_type_value());
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LBR_ReserveComponent_pack(0, 0, 0, $Coin1_Coin1_type_value(), $t32, $t33);
    $t34 := $tmp;
    call $tmp := $CopyOrMoveValue($t34);
    coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 4634, 3, $tmp);
    }

    $tmp := $Integer(1);
    $t35 := $tmp;
    $tmp := $Integer(2);
    $t36 := $tmp;
    call $t37 := $FixedPoint32_create_from_rational($t35, $t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t38 := $Libra_zero($Coin2_Coin2_type_value());
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LBR_ReserveComponent_pack(0, 0, 0, $Coin2_Coin2_type_value(), $t37, $t38);
    $t39 := $tmp;
    call $tmp := $CopyOrMoveValue($t39);
    coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 4795, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t47);
    $t40 := $tmp;
    call $tmp := $LBR_Reserve_pack(0, 0, 0, mint_cap, burn_cap, preburn_cap, coin1, coin2);
    $t46 := $tmp;
    call $LBR_Reserve_$memory := $MoveTo($LBR_Reserve_$memory, $EmptyTypeValueArray, $t46, $t40);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(13, 4952, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LBR_initialize_$direct_inter(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $LBR_initialize_$direct_inter(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $LBR_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $LBR_initialize_$direct_intra(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $LBR_initialize_$direct_intra(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $LBR_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $LBR_initialize(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $LBR_initialize(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $LBR_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $LBR_create_$def(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LBR_create_$def(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
{
  var num_coin1: $Value;
  var num_coin2: $Value;
  var reserve: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Mutation;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Mutation;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Mutation;
  var $t35: $Value;
  var $t36: $Mutation;
  var $t37: $Mutation;
  var $t38: $Mutation;
  var $t39: $Value;
  var $t40: $Mutation;
  var $t41: $Mutation;
  var $t42: $Mutation;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Mutation;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Value;
  var $t52: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(13, 7118, 0, amount_lbr);
    }

    if (true)
    {
        assume $DebugTrackLocal(13, 7118, 1, coin1);
    }

    if (true)
    {
        assume $DebugTrackLocal(13, 7118, 2, coin2);
    }

    call $tmp := $CopyOrMoveValue(amount_lbr);
    $t48 := $tmp;
    call $tmp := $CopyOrMoveValue(coin1);
    $t49 := $tmp;
    call $tmp := $CopyOrMoveValue(coin2);
    $t50 := $tmp;
    $tmp := $Integer(0);
    $t13 := $tmp;
    call $tmp := $Gt($t48, $t13);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 7268, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(1);
    $t16 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(13, 7268, i#$Integer($t16));
    }

    $abort_code := i#$Integer($t16);
    goto Abort;

  L0:
    call $t18, $t19 := $LBR_calculate_component_amounts_for_lbr($t48);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t19);
    num_coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 7344, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t18);
    num_coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 7333, 3, $tmp);
    }

    call $t20 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t21 := $BorrowGlobal($LBR_Reserve_$memory, $t20, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(13, 7428, $abort_code);
        goto Abort;
    }

    call reserve := $CopyOrMoveRef($t21);
    if (true)
    {
        assume $DebugTrackLocal(13, 7418, 5, $Dereference(reserve));
    }

    call $tmp := $CopyOrMoveValue($t49);
    $t23 := $tmp;
    call $t24 := $Libra_value($Coin1_Coin1_type_value(), $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual(num_coin1, $t24));
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue($t25);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 7501, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $t27 := $CopyOrMoveRef(reserve);
    call $LBR_Reserve_$memory := $WritebackToGlobal($LBR_Reserve_$memory, $t27);
    $tmp := $Integer(2);
    $t28 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(13, 7501, i#$Integer($t28));
    }

    $abort_code := i#$Integer($t28);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t50);
    $t30 := $tmp;
    call $t31 := $Libra_value($Coin2_Coin2_type_value(), $t30);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual(num_coin2, $t31));
    $t32 := $tmp;
    call $tmp := $CopyOrMoveValue($t32);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 7575, 10, $tmp);
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $t34 := $CopyOrMoveRef(reserve);
    call $LBR_Reserve_$memory := $WritebackToGlobal($LBR_Reserve_$memory, $t34);
    $tmp := $Integer(3);
    $t35 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(13, 7575, i#$Integer($t35));
    }

    $abort_code := i#$Integer($t35);
    goto Abort;

  L4:
    call $t36 := $CopyOrMoveRef(reserve);
    call $t37 := $BorrowField($t36, $LBR_Reserve_coin1);
    call reserve := $WritebackToReference($t36, reserve);
    call $t38 := $BorrowField($t37, $LBR_ReserveComponent_backing);
    call reserve := $WritebackToReference($t37, reserve);
    call $t36 := $WritebackToReference($t37, $t36);
    call $tmp := $ReadRef($t38);
    $t51 := $tmp;
    call $t51 := $Libra_deposit($Coin1_Coin1_type_value(), $t51, $t49);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t38 := $WriteRef($t38, $t51);
    if (true)
    {
        assume $DebugTrackLocal(13, 7762, 5, $Dereference(reserve));
    }

    call reserve := $WritebackToReference($t38, reserve);
    call $t37 := $WritebackToReference($t38, $t37);
    call $t36 := $WritebackToReference($t37, $t36);
    call $t40 := $CopyOrMoveRef(reserve);
    call $t41 := $BorrowField($t40, $LBR_Reserve_coin2);
    call reserve := $WritebackToReference($t40, reserve);
    call $t42 := $BorrowField($t41, $LBR_ReserveComponent_backing);
    call reserve := $WritebackToReference($t41, reserve);
    call $t40 := $WritebackToReference($t41, $t40);
    call $tmp := $ReadRef($t42);
    $t52 := $tmp;
    call $t52 := $Libra_deposit($Coin2_Coin2_type_value(), $t52, $t50);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t42 := $WriteRef($t42, $t52);
    if (true)
    {
        assume $DebugTrackLocal(13, 7942, 5, $Dereference(reserve));
    }

    call reserve := $WritebackToReference($t42, reserve);
    call $t41 := $WritebackToReference($t42, $t41);
    call $t40 := $WritebackToReference($t41, $t40);
    call $t45 := $CopyOrMoveRef(reserve);
    call $tmp := $GetFieldFromReference($t45, $LBR_Reserve_mint_cap);
    $t46 := $tmp;
    call $LBR_Reserve_$memory := $WritebackToGlobal($LBR_Reserve_$memory, $t45);
    call $t47 := $Libra_mint_with_capability($LBR_LBR_type_value(), $t48, $t46);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t47;
    if (true)
    {
        assume $DebugTrackLocal(13, 7896, 53, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LBR_create_$direct_inter(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LBR_create_$direct_inter(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(amount_lbr);
    assume $Libra_Libra_is_well_formed(coin1);
    assume $Libra_Libra_is_well_formed(coin2);
    call $ret0 := $LBR_create_$def(amount_lbr, coin1, coin2);
}



procedure {:inline 1} $LBR_create_$direct_intra(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LBR_create_$direct_intra(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(amount_lbr);
    assume $Libra_Libra_is_well_formed(coin1);
    assume $Libra_Libra_is_well_formed(coin2);
    call $ret0 := $LBR_create_$def(amount_lbr, coin1, coin2);
}



procedure {:inline 1} $LBR_create(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LBR_create(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(amount_lbr);
    assume $Libra_Libra_is_well_formed(coin1);
    assume $Libra_Libra_is_well_formed(coin2);
    call $ret0 := $LBR_create_$def(amount_lbr, coin1, coin2);
}



procedure {:inline 1} $LBR_calculate_component_amounts_for_lbr_$def(amount_lbr: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $LBR_calculate_component_amounts_for_lbr_$def(amount_lbr: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var num_coin1: $Value;
  var num_coin2: $Value;
  var reserve: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(13, 6162, 0, amount_lbr);
    }

    call $tmp := $CopyOrMoveValue(amount_lbr);
    $t24 := $tmp;
    call $t4 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($LBR_Reserve_$memory, $t4, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(13, 6283, $abort_code);
        goto Abort;
    }

    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    reserve := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 6273, 3, $tmp);
    }

    $tmp := $Integer(1);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue(reserve);
    $t8 := $tmp;
    call $tmp := $GetFieldFromValue($t8, $LBR_Reserve_coin1);
    $t9 := $tmp;
    call $tmp := $GetFieldFromValue($t9, $LBR_ReserveComponent_ratio);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;
    call $t12 := $FixedPoint32_multiply_u64($t24, $t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $AddU64($t6, $t12);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(13, 6370, $abort_code);
        goto Abort;
    }

    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    num_coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 6356, 1, $tmp);
    }

    $tmp := $Integer(1);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue(reserve);
    $t16 := $tmp;
    call $tmp := $GetFieldFromValue($t16, $LBR_Reserve_coin2);
    $t17 := $tmp;
    call $tmp := $GetFieldFromValue($t17, $LBR_ReserveComponent_ratio);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    $t19 := $tmp;
    call $t20 := $FixedPoint32_multiply_u64($t24, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $AddU64($t14, $t20);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(13, 6461, $abort_code);
        goto Abort;
    }

    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    num_coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 6447, 2, $tmp);
    }

    $ret0 := num_coin1;
    if (true)
    {
        assume $DebugTrackLocal(13, 6534, 25, $ret0);
    }

    $ret1 := num_coin2;
    if (true)
    {
        assume $DebugTrackLocal(13, 6534, 26, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $LBR_calculate_component_amounts_for_lbr_$direct_inter(amount_lbr: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $LBR_calculate_component_amounts_for_lbr_$direct_inter(amount_lbr: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $IsValidU64(amount_lbr);
    call $ret0, $ret1 := $LBR_calculate_component_amounts_for_lbr_$def(amount_lbr);
}



procedure {:inline 1} $LBR_calculate_component_amounts_for_lbr_$direct_intra(amount_lbr: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $LBR_calculate_component_amounts_for_lbr_$direct_intra(amount_lbr: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $IsValidU64(amount_lbr);
    call $ret0, $ret1 := $LBR_calculate_component_amounts_for_lbr_$def(amount_lbr);
}



procedure {:inline 1} $LBR_calculate_component_amounts_for_lbr(amount_lbr: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $LBR_calculate_component_amounts_for_lbr(amount_lbr: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $IsValidU64(amount_lbr);
    call $ret0, $ret1 := $LBR_calculate_component_amounts_for_lbr_$def(amount_lbr);
}



procedure {:inline 1} $LBR_is_lbr_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $LBR_is_lbr_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t1 := $Libra_is_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t2 := $Libra_currency_code($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t3 := $Libra_currency_code($LBR_LBR_type_value());
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t2, $t3));
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t0 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 5353, 0, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Boolean(false);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t0 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 5353, 0, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t0;
    if (true)
    {
        assume $DebugTrackLocal(13, 5353, 7, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LBR_is_lbr_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $LBR_spec_is_lbr($tv0))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $LBR_is_lbr_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $LBR_spec_is_lbr($tv0))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $LBR_is_lbr($tv0: $TypeValue) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $LBR_spec_is_lbr($tv0))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $LBR_reserve_address_$def() returns ($ret0: $Value);



implementation {:inline 1} $LBR_reserve_address_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t0;
    if (true)
    {
        assume $DebugTrackLocal(13, 9761, 1, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LBR_reserve_address_$direct_inter() returns ($ret0: $Value);



implementation {:inline 1} $LBR_reserve_address_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $LBR_reserve_address_$def();
}



procedure {:inline 1} $LBR_reserve_address_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $LBR_reserve_address_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $LBR_reserve_address_$def();
}



procedure {:inline 1} $LBR_reserve_address() returns ($ret0: $Value);



implementation {:inline 1} $LBR_reserve_address() returns ($ret0: $Value)
{
    call $ret0 := $LBR_reserve_address_$def();
}



procedure {:inline 1} $LBR_unpack_$def(coin: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $LBR_unpack_$def(coin: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var coin1: $Value;
  var coin1_amount: $Value;
  var coin2: $Value;
  var coin2_amount: $Value;
  var ratio_multiplier: $Value;
  var reserve: $Mutation;
  var sender: $Value;
  var $t8: $Value;
  var $t9: $Mutation;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $t19: $Value;
  var $t20: $Mutation;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Mutation;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Mutation;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Mutation;
  var $t35: $Mutation;
  var $t36: $Mutation;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Mutation;
  var $t40: $Mutation;
  var $t41: $Mutation;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(13, 8572, 0, coin);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t46 := $tmp;
    call $t8 := $LBR_reserve_address();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t9 := $BorrowGlobal($LBR_Reserve_$memory, $t8, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(13, 8683, $abort_code);
        goto Abort;
    }

    call reserve := $CopyOrMoveRef($t9);
    if (true)
    {
        assume $DebugTrackLocal(13, 8673, 6, $Dereference(reserve));
    }

    call $tmp := $CopyOrMoveValue($t46);
    $t10 := $tmp;
    call $t11 := $Libra_value($LBR_LBR_type_value(), $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    ratio_multiplier := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 8742, 5, $tmp);
    }

    call $t12 := $LBR_reserve_address();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 8794, 7, $tmp);
    }

    call $t14 := $CopyOrMoveRef(reserve);
    call $t15 := $BorrowField($t14, $LBR_Reserve_preburn_cap);
    call reserve := $WritebackToReference($t14, reserve);
    call $tmp := $ReadRef($t15);
    $t49 := $tmp;
    call $t49 := $Libra_preburn_with_resource($LBR_LBR_type_value(), $t46, $t49, sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $WriteRef($t15, $t49);
    if (true)
    {
        assume $DebugTrackLocal(13, 9299, 6, $Dereference(reserve));
    }

    call reserve := $WritebackToReference($t15, reserve);
    call $t14 := $WritebackToReference($t15, $t14);
    call $t17 := $CopyOrMoveRef(reserve);
    call $t18 := $BorrowField($t17, $LBR_Reserve_preburn_cap);
    call reserve := $WritebackToReference($t17, reserve);
    call $t20 := $CopyOrMoveRef(reserve);
    call $tmp := $GetFieldFromReference($t20, $LBR_Reserve_burn_cap);
    $t21 := $tmp;
    call reserve := $WritebackToReference($t20, reserve);
    call $tmp := $ReadRef($t18);
    $t49 := $tmp;
    call $t49 := $Libra_burn_with_resource_cap($LBR_LBR_type_value(), $t49, sender, $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t18 := $WriteRef($t18, $t49);
    if (true)
    {
        assume $DebugTrackLocal(13, 9290, 6, $Dereference(reserve));
    }

    call reserve := $WritebackToReference($t18, reserve);
    call $t17 := $WritebackToReference($t18, $t17);
    call $t20 := $WritebackToReference($t18, $t20);
    call $t23 := $CopyOrMoveRef(reserve);
    call $tmp := $GetFieldFromReference($t23, $LBR_Reserve_coin1);
    $t24 := $tmp;
    call reserve := $WritebackToReference($t23, reserve);
    call $tmp := $GetFieldFromValue($t24, $LBR_ReserveComponent_ratio);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue($t25);
    $t26 := $tmp;
    call $t27 := $FixedPoint32_multiply_u64(ratio_multiplier, $t26);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t27);
    coin1_amount := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 9004, 2, $tmp);
    }

    call $t29 := $CopyOrMoveRef(reserve);
    call $tmp := $GetFieldFromReference($t29, $LBR_Reserve_coin2);
    $t30 := $tmp;
    call reserve := $WritebackToReference($t29, reserve);
    call $tmp := $GetFieldFromValue($t30, $LBR_ReserveComponent_ratio);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t32 := $tmp;
    call $t33 := $FixedPoint32_multiply_u64(ratio_multiplier, $t32);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t33);
    coin2_amount := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 9100, 4, $tmp);
    }

    call $t34 := $CopyOrMoveRef(reserve);
    call $t35 := $BorrowField($t34, $LBR_Reserve_coin1);
    call reserve := $WritebackToReference($t34, reserve);
    call $t36 := $BorrowField($t35, $LBR_ReserveComponent_backing);
    call reserve := $WritebackToReference($t35, reserve);
    call $t34 := $WritebackToReference($t35, $t34);
    call $tmp := $ReadRef($t36);
    $t47 := $tmp;
    call $t38, $t47 := $Libra_withdraw($Coin1_Coin1_type_value(), $t47, coin1_amount);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t36 := $WriteRef($t36, $t47);
    if (true)
    {
        assume $DebugTrackLocal(13, 9351, 6, $Dereference(reserve));
    }

    call reserve := $WritebackToReference($t36, reserve);
    call $t35 := $WritebackToReference($t36, $t35);
    call $t34 := $WritebackToReference($t35, $t34);
    call $tmp := $CopyOrMoveValue($t38);
    coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 9196, 1, $tmp);
    }

    call $t39 := $CopyOrMoveRef(reserve);
    call $t40 := $BorrowField($t39, $LBR_Reserve_coin2);
    call $LBR_Reserve_$memory := $WritebackToGlobal($LBR_Reserve_$memory, $t39);
    call $t41 := $BorrowField($t40, $LBR_ReserveComponent_backing);
    call $LBR_Reserve_$memory := $WritebackToGlobal($LBR_Reserve_$memory, $t40);
    call $t39 := $WritebackToReference($t40, $t39);
    call $tmp := $ReadRef($t41);
    $t48 := $tmp;
    call $t43, $t48 := $Libra_withdraw($Coin2_Coin2_type_value(), $t48, coin2_amount);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t41 := $WriteRef($t41, $t48);
    if (true)
    {
        assume $DebugTrackLocal(13, 9350, 6, $Dereference(reserve));
    }

    call $LBR_Reserve_$memory := $WritebackToGlobal($LBR_Reserve_$memory, $t41);
    call $t40 := $WritebackToReference($t41, $t40);
    call $t39 := $WritebackToReference($t40, $t39);
    call $tmp := $CopyOrMoveValue($t43);
    coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(13, 9275, 3, $tmp);
    }

    $ret0 := coin1;
    if (true)
    {
        assume $DebugTrackLocal(13, 9350, 50, $ret0);
    }

    $ret1 := coin2;
    if (true)
    {
        assume $DebugTrackLocal(13, 9350, 51, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $LBR_unpack_$direct_inter(coin: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()), $Integer(i#$Integer(old($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))) - i#$Integer($SelectField(coin, $Libra_Libra_value))))));
  ensures $Libra_Libra_is_well_formed($ret0);
  ensures $Libra_Libra_is_well_formed($ret1);



procedure {:inline 1} $LBR_unpack_$direct_intra(coin: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()), $Integer(i#$Integer(old($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))) - i#$Integer($SelectField(coin, $Libra_Libra_value))))));
  ensures $Libra_Libra_is_well_formed($ret0);
  ensures $Libra_Libra_is_well_formed($ret1);



procedure {:inline 1} $LBR_unpack(coin: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()), $Integer(i#$Integer(old($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))) - i#$Integer($SelectField(coin, $Libra_Libra_value))))));
  ensures $Libra_Libra_is_well_formed($ret0);
  ensures $Libra_Libra_is_well_formed($ret1);



function {:inline} $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory: $Memory, addr: $Value) : $Value
{
  $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_compliance_public_key)
}

function {:inline} $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, addr: $Value) : $Value
{
  (if b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, addr)) then $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr) else addr)
}

function {:inline} $DualAttestation_spec_is_inter_vasp($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, payer: $Value, payee: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)) && b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))) && b#$Boolean($Boolean(!$IsEqual($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))
}

function {:inline} $DualAttestation_spec_is_inter_dd($DesignatedDealer_Dealer_$memory: $Memory, payer: $Value, payee: $Value) : $Value
{
  $Boolean(b#$Boolean($DesignatedDealer_spec_exists_at($DesignatedDealer_Dealer_$memory, payer)) && b#$Boolean($DesignatedDealer_spec_exists_at($DesignatedDealer_Dealer_$memory, payee)))
}

function {:inline} $DualAttestation_spec_is_vasp_to_dd($DesignatedDealer_Dealer_$memory: $Memory, $VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, payer: $Value, payee: $Value) : $Value
{
  $Boolean(b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)) && b#$Boolean($DesignatedDealer_spec_exists_at($DesignatedDealer_Dealer_$memory, payee)))
}

function {:inline} $DualAttestation_spec_is_dd_to_vasp($DesignatedDealer_Dealer_$memory: $Memory, $VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, payer: $Value, payee: $Value) : $Value
{
  $Boolean(b#$Boolean($DesignatedDealer_spec_exists_at($DesignatedDealer_Dealer_$memory, payer)) && b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))
}

function {:inline} $DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory: $Memory, $DesignatedDealer_Dealer_$memory: $Memory, $VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, $DualAttestation_Limit_$memory: $Memory, $tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($Libra_spec_approx_lbr_for_value($Libra_CurrencyInfo_$memory, $tv0, deposit_value)) >= i#$Integer($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory)))) && b#$Boolean($Boolean(!$IsEqual(payer, payee))))) && b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($DualAttestation_spec_is_inter_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee)) || b#$Boolean($DualAttestation_spec_is_inter_dd($DesignatedDealer_Dealer_$memory, payer, payee)))) || b#$Boolean($DualAttestation_spec_is_vasp_to_dd($DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee)))) || b#$Boolean($DualAttestation_spec_is_dd_to_vasp($DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee)))))
}

function {:inline} $DualAttestation_spec_dual_attestation_message(payer: $Value, metadata: $Value, deposit_value: $Value) : $Value;

axiom (forall payer: $Value, metadata: $Value, deposit_value: $Value :: {:qid "quantifier703"} $Vector_is_well_formed($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)) && (forall $$0: int :: {:qid "quantifier704"} { $select_vector($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value), $$0) } $$0 >= 0 && $$0 < $vlen($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)) ==> $IsValidU8($select_vector($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value), $$0))));

function {:inline} $DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, $DualAttestation_Credential_$memory: $Memory, payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(64)))) && b#$Boolean($Signature_spec_ed25519_verify(metadata_signature, $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value))))
}

function {:inline} $DualAttestation_spec_is_published($DualAttestation_Limit_$memory: $Memory) : $Value
{
  $ResourceExists($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}

function {:inline} $DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory: $Memory) : $Value
{
  $SelectField($ResourceValue($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()), $DualAttestation_Limit_micro_lbr_limit)
}

const unique $DualAttestation_Credential: $TypeName;

const $DualAttestation_Credential_human_name: $FieldName;

axiom $DualAttestation_Credential_human_name == 0;

const $DualAttestation_Credential_base_url: $FieldName;

axiom $DualAttestation_Credential_base_url == 1;

const $DualAttestation_Credential_compliance_public_key: $FieldName;

axiom $DualAttestation_Credential_compliance_public_key == 2;

const $DualAttestation_Credential_expiration_date: $FieldName;

axiom $DualAttestation_Credential_expiration_date == 3;

function $DualAttestation_Credential_type_value() : $TypeValue;

axiom $DualAttestation_Credential_type_value(): $TypeValue == $StructType($DualAttestation_Credential, $EmptyTypeValueArray);

var $DualAttestation_Credential_$memory: $Memory;

var $DualAttestation_Credential_$memory_$old: $Memory;

function {:inline} $DualAttestation_Credential_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 4 && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_human_name)) && (forall $$0: int :: {:qid "quantifier705"} { $select_vector($SelectField($this, $DualAttestation_Credential_human_name), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_human_name), $$0))) && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_base_url)) && (forall $$0: int :: {:qid "quantifier706"} { $select_vector($SelectField($this, $DualAttestation_Credential_base_url), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_base_url)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_base_url), $$0))) && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_compliance_public_key)) && (forall $$0: int :: {:qid "quantifier707"} { $select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_compliance_public_key)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key), $$0))) && $IsValidU64($SelectField($this, $DualAttestation_Credential_expiration_date))
}

function {:inline} $DualAttestation_Credential_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 4 && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_human_name)) && (forall $$0: int :: {:qid "quantifier708"} { $select_vector($SelectField($this, $DualAttestation_Credential_human_name), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_human_name), $$0))) && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_base_url)) && (forall $$0: int :: {:qid "quantifier709"} { $select_vector($SelectField($this, $DualAttestation_Credential_base_url), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_base_url)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_base_url), $$0))) && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_compliance_public_key)) && (forall $$0: int :: {:qid "quantifier710"} { $select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_compliance_public_key)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key), $$0))) && $IsValidU64($SelectField($this, $DualAttestation_Credential_expiration_date))
}

procedure {:inline 1} $DualAttestation_Credential_pack($file_id: int, $byte_index: int, $var_idx: int, human_name: $Value, base_url: $Value, compliance_public_key: $Value, expiration_date: $Value) returns ($struct: $Value);



implementation {:inline 1} $DualAttestation_Credential_pack($file_id: int, $byte_index: int, $var_idx: int, human_name: $Value, base_url: $Value, compliance_public_key: $Value, expiration_date: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier711"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier712"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier713"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    assume $IsValidU64(expiration_date);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := human_name][1 := base_url][2 := compliance_public_key][3 := expiration_date], 4));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $DualAttestation_Credential_unpack($struct: $Value) returns (human_name: $Value, base_url: $Value, compliance_public_key: $Value, expiration_date: $Value);



implementation {:inline 1} $DualAttestation_Credential_unpack($struct: $Value) returns (human_name: $Value, base_url: $Value, compliance_public_key: $Value, expiration_date: $Value)
{
    assume is#$Vector($struct);
    human_name := $SelectField($struct, $DualAttestation_Credential_human_name);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier714"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    base_url := $SelectField($struct, $DualAttestation_Credential_base_url);
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier715"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    compliance_public_key := $SelectField($struct, $DualAttestation_Credential_compliance_public_key);
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier716"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    expiration_date := $SelectField($struct, $DualAttestation_Credential_expiration_date);
    assume $IsValidU64(expiration_date);
}



const unique $DualAttestation_Limit: $TypeName;

const $DualAttestation_Limit_micro_lbr_limit: $FieldName;

axiom $DualAttestation_Limit_micro_lbr_limit == 0;

function $DualAttestation_Limit_type_value() : $TypeValue;

axiom $DualAttestation_Limit_type_value(): $TypeValue == $StructType($DualAttestation_Limit, $EmptyTypeValueArray);

var $DualAttestation_Limit_$memory: $Memory;

var $DualAttestation_Limit_$memory_$old: $Memory;

function {:inline} $DualAttestation_Limit_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $DualAttestation_Limit_micro_lbr_limit))
}

function {:inline} $DualAttestation_Limit_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $DualAttestation_Limit_micro_lbr_limit))
}

procedure {:inline 1} $DualAttestation_Limit_pack($file_id: int, $byte_index: int, $var_idx: int, micro_lbr_limit: $Value) returns ($struct: $Value);



implementation {:inline 1} $DualAttestation_Limit_pack($file_id: int, $byte_index: int, $var_idx: int, micro_lbr_limit: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(micro_lbr_limit);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := micro_lbr_limit], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $DualAttestation_Limit_unpack($struct: $Value) returns (micro_lbr_limit: $Value);



implementation {:inline 1} $DualAttestation_Limit_unpack($struct: $Value) returns (micro_lbr_limit: $Value)
{
    assume is#$Vector($struct);
    micro_lbr_limit := $SelectField($struct, $DualAttestation_Limit_micro_lbr_limit);
    assume $IsValidU64(micro_lbr_limit);
}



procedure {:inline 1} $DualAttestation_initialize_$def(lr_account: $Value);



implementation {:inline 1} $DualAttestation_initialize_$def(lr_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 16189, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t21 := $tmp;
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 16242, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t21);
    $t7 := $tmp;
    $tmp := $Integer(0);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 16242, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t21);
    $t9 := $tmp;
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 16302, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t21);
    $t14 := $tmp;
    $tmp := $Integer(1);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 16302, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t21);
    $t16 := $tmp;
    $tmp := $Integer(1000);
    $t17 := $tmp;
    call $t18 := $Libra_scaling_factor($LBR_LBR_type_value());
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $MulU64($t17, $t18);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 16565, $abort_code);
        goto Abort;
    }

    $t19 := $tmp;
    call $tmp := $DualAttestation_Limit_pack(0, 0, 0, $t19);
    $t20 := $tmp;
    call $DualAttestation_Limit_$memory := $MoveTo($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $t20, $t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 16448, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DualAttestation_initialize_$direct_inter(lr_account: $Value);



implementation {:inline 1} $DualAttestation_initialize_$direct_inter(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $DualAttestation_initialize_$def(lr_account);
}



procedure {:inline 1} $DualAttestation_initialize_$direct_intra(lr_account: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_initialize_$direct_intra(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $DualAttestation_initialize_$def(lr_account);
}



procedure {:inline 1} $DualAttestation_initialize(lr_account: $Value);



implementation {:inline 1} $DualAttestation_initialize(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $DualAttestation_initialize_$def(lr_account);
}



procedure {:inline 1} $DualAttestation_assert_payment_ok_$def($tv0: $TypeValue, payer: $Value, payee: $Value, value: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $DualAttestation_assert_payment_ok_$def($tv0: $TypeValue, payer: $Value, payee: $Value, value: $Value, metadata: $Value, metadata_signature: $Value)
{
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 15058, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 15058, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 15058, 2, value);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 15058, 3, metadata);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 15058, 4, metadata_signature);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(value);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t18 := $tmp;
    call $t8 := $DualAttestation_dual_attestation_required($tv0, $t14, $t15, $t16);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $DualAttestation_assert_signature_is_valid($t14, $t15, $t18, $t17, $t16);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L2;

  L2:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DualAttestation_assert_payment_ok_$direct_inter($tv0: $TypeValue, payer: $Value, payee: $Value, value: $Value, metadata: $Value, metadata_signature: $Value);
  ensures b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value))))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value)))))));



procedure {:inline 1} $DualAttestation_assert_payment_ok_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, value: $Value, metadata: $Value, metadata_signature: $Value);
  ensures b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value))))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value)))))));



procedure {:inline 1} $DualAttestation_assert_payment_ok($tv0: $TypeValue, payer: $Value, payee: $Value, value: $Value, metadata: $Value, metadata_signature: $Value);
  ensures b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value))))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value)))))));



procedure {:inline 1} $DualAttestation_assert_signature_is_valid_$def(payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value);



implementation {:inline 1} $DualAttestation_assert_signature_is_valid_$def(payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value)
{
  var message: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 12555, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 12555, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 12555, 2, metadata_signature);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 12555, 3, metadata);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 12555, 4, deposit_value);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t28 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue(deposit_value);
    $t32 := $tmp;
    call $tmp := $CopyOrMoveValue($t30);
    $t10 := $tmp;
    call $t11 := $Vector_length($IntegerType(), $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(64);
    $t12 := $tmp;
    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 12813, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(6);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 12813, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L0:
    call $t19 := $DualAttestation_dual_attestation_message($t28, $t31, $t32);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t19);
    message := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 12960, 5, $tmp);
    }

    call $t22 := $DualAttestation_credential_address($t29);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t23 := $DualAttestation_compliance_public_key($t22);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t25 := $Signature_ed25519_verify($t30, $t23, message);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t25);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 13036, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(7);
    $t27 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 13036, i#$Integer($t27));
    }

    $abort_code := i#$Integer($t27);
    goto Abort;

  L2:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DualAttestation_assert_signature_is_valid_$direct_intra(payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) || b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



procedure {:inline 1} $DualAttestation_assert_signature_is_valid(payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) || b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value)))));



procedure {:inline 1} $DualAttestation_base_url_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_base_url_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 6023, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($DualAttestation_Credential_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 6102, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $DualAttestation_Credential_base_url);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(9, 6100, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DualAttestation_base_url_$direct_inter(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_base_url_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_base_url_$def(addr);
}



procedure {:inline 1} $DualAttestation_base_url_$direct_intra(addr: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_base_url_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_base_url_$def(addr);
}



procedure {:inline 1} $DualAttestation_base_url(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_base_url(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_base_url_$def(addr);
}



procedure {:inline 1} $DualAttestation_compliance_public_key_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_compliance_public_key_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 6271, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($DualAttestation_Credential_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 6363, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $DualAttestation_Credential_compliance_public_key);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(9, 6361, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DualAttestation_compliance_public_key_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, addr))));



implementation {:inline 1} $DualAttestation_compliance_public_key_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_compliance_public_key_$def(addr);
}



procedure {:inline 1} $DualAttestation_compliance_public_key_$direct_intra(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_compliance_public_key_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_compliance_public_key_$def(addr);
}



procedure {:inline 1} $DualAttestation_compliance_public_key(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_compliance_public_key(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_compliance_public_key_$def(addr);
}



procedure {:inline 1} $DualAttestation_credential_address_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_credential_address_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 7325, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t8 := $tmp;
    call $t3 := $VASP_is_child($t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t5 := $VASP_parent_address($t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 7382, 1, $tmp);
    }

    goto L3;

  L2:
    call $tmp := $CopyOrMoveValue($t8);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 7382, 1, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(9, 7382, 9, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DualAttestation_credential_address_$direct_intra(addr: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_credential_address_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_credential_address_$def(addr);
}



procedure {:inline 1} $DualAttestation_credential_address(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_credential_address(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_credential_address_$def(addr);
}



procedure {:inline 1} $DualAttestation_dual_attestation_message_$def(payer: $Value, metadata: $Value, deposit_value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_dual_attestation_message_$def(payer: $Value, metadata: $Value, deposit_value: $Value) returns ($ret0: $Value)
{
  var message: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Mutation;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Mutation;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 11317, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 11317, 1, metadata);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 11317, 2, deposit_value);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(deposit_value);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    message := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 11444, 3, $tmp);
    }

    call $t5 := $BorrowLoc(3, message);
    call $tmp := $CopyOrMoveValue($t14);
    $t6 := $tmp;
    call $t7 := $LCS_to_bytes($AddressType(), $t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $ReadRef($t5);
    $t17 := $tmp;
    call $t17 := $Vector_append($IntegerType(), $t17, $t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t5 := $WriteRef($t5, $t17);
    call message := $WritebackToValue($t5, 3, message);
    call $t8 := $BorrowLoc(3, message);
    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;
    call $t10 := $LCS_to_bytes($IntegerType(), $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $ReadRef($t8);
    $t17 := $tmp;
    call $t17 := $Vector_append($IntegerType(), $t17, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t8 := $WriteRef($t8, $t17);
    call message := $WritebackToValue($t8, 3, message);
    call $t11 := $BorrowLoc(3, message);
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(64)][1 := $Integer(64)][2 := $Integer(36)][3 := $Integer(36)][4 := $Integer(76)][5 := $Integer(73)][6 := $Integer(66)][7 := $Integer(82)][8 := $Integer(65)][9 := $Integer(95)][10 := $Integer(65)][11 := $Integer(84)][12 := $Integer(84)][13 := $Integer(69)][14 := $Integer(83)][15 := $Integer(84)][16 := $Integer(36)][17 := $Integer(36)][18 := $Integer(64)][19 := $Integer(64)], 20));
    $t12 := $tmp;
    call $tmp := $ReadRef($t11);
    $t17 := $tmp;
    call $t17 := $Vector_append($IntegerType(), $t17, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $WriteRef($t11, $t17);
    call message := $WritebackToValue($t11, 3, message);
    $ret0 := message;
    if (true)
    {
        assume $DebugTrackLocal(9, 11658, 18, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DualAttestation_dual_attestation_message_$direct_intra(payer: $Value, metadata: $Value, deposit_value: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier717"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $DualAttestation_dual_attestation_message(payer: $Value, metadata: $Value, deposit_value: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier718"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $DualAttestation_dual_attestation_required_$def($tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_dual_attestation_required_$def($tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) returns ($ret0: $Value)
{
  var above_limit: $Value;
  var approx_lbr_microlibra_value: $Value;
  var is_inter_vasp: $Value;
  var is_payee_dd: $Value;
  var is_payee_vasp: $Value;
  var is_payer_dd: $Value;
  var is_payer_vasp: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var travel_rule_limit_microlibra: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $t56: $Value;
  var $t57: $Value;
  var $t58: $Value;
  var $t59: $Value;
  var $t60: $Value;
  var $t61: $Value;
  var $t62: $Value;
  var $t63: $Value;
  var $t64: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 7910, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 7910, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 7910, 2, deposit_value);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t62 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t63 := $tmp;
    call $tmp := $CopyOrMoveValue(deposit_value);
    $t64 := $tmp;
    call $t15 := $DualAttestation_get_cur_microlibra_limit();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t15);
    travel_rule_limit_microlibra := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 8105, 14, $tmp);
    }

    call $t17 := $Libra_approx_lbr_for_value($tv0, $t64);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t17);
    approx_lbr_microlibra_value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 8176, 4, $tmp);
    }

    call $tmp := $Ge(approx_lbr_microlibra_value, travel_rule_limit_microlibra);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    above_limit := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 8269, 3, $tmp);
    }

    call $tmp := $Not(above_limit);
    $t22 := $tmp;
    $tmp := $t22;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $Boolean(false);
    $t23 := $tmp;
    $ret0 := $t23;
    if (true)
    {
        assume $DebugTrackLocal(9, 8384, 65, $ret0);
    }

    return;

  L2:
    $tmp := $Boolean($IsEqual($t62, $t63));
    $t26 := $tmp;
    $tmp := $t26;
    if (b#$Boolean($tmp))
    {
        goto L3;
    }
    else
    {
        goto L4;
    }

  L4:
    goto L5;

  L3:
    $tmp := $Boolean(false);
    $t27 := $tmp;
    $ret0 := $t27;
    if (true)
    {
        assume $DebugTrackLocal(9, 8506, 65, $ret0);
    }

    return;

  L5:
    call $t29 := $VASP_is_vasp($t62);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t29);
    is_payer_vasp := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 8862, 9, $tmp);
    }

    call $t31 := $VASP_is_vasp($t63);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t31);
    is_payee_vasp := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 8912, 7, $tmp);
    }

    call $t33 := $DesignatedDealer_exists_at($t62);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t33);
    is_payer_dd := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 8962, 8, $tmp);
    }

    call $t35 := $DesignatedDealer_exists_at($t63);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t35);
    is_payee_dd := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9024, 6, $tmp);
    }

    call $tmp := $And(is_payer_vasp, is_payee_vasp);
    $t38 := $tmp;
    $tmp := $t38;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    call $t40 := $VASP_parent_address($t62);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t42 := $VASP_parent_address($t63);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean(!$IsEqual($t40, $t42));
    $t43 := $tmp;
    call $tmp := $CopyOrMoveValue($t43);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9114, 10, $tmp);
    }

    goto L9;

  L8:
    $tmp := $Boolean(false);
    $t44 := $tmp;
    call $tmp := $CopyOrMoveValue($t44);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9114, 10, $tmp);
    }

    goto L9;

  L9:
    call $tmp := $CopyOrMoveValue($t10);
    is_inter_vasp := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9086, 5, $tmp);
    }

    $tmp := is_inter_vasp;
    if (b#$Boolean($tmp))
    {
        goto L10;
    }
    else
    {
        goto L11;
    }

  L11:
    goto L12;

  L10:
    $tmp := $Boolean(true);
    $t47 := $tmp;
    call $tmp := $CopyOrMoveValue($t47);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9228, 11, $tmp);
    }

    goto L13;

  L12:
    call $tmp := $And(is_payer_dd, is_payee_dd);
    $t50 := $tmp;
    call $tmp := $CopyOrMoveValue($t50);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9228, 11, $tmp);
    }

    goto L13;

  L13:
    $tmp := $t11;
    if (b#$Boolean($tmp))
    {
        goto L14;
    }
    else
    {
        goto L15;
    }

  L15:
    goto L16;

  L14:
    $tmp := $Boolean(true);
    $t52 := $tmp;
    call $tmp := $CopyOrMoveValue($t52);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9228, 12, $tmp);
    }

    goto L17;

  L16:
    call $tmp := $And(is_payer_vasp, is_payee_dd);
    $t55 := $tmp;
    call $tmp := $CopyOrMoveValue($t55);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9228, 12, $tmp);
    }

    goto L17;

  L17:
    $tmp := $t12;
    if (b#$Boolean($tmp))
    {
        goto L18;
    }
    else
    {
        goto L19;
    }

  L19:
    goto L20;

  L18:
    $tmp := $Boolean(true);
    $t57 := $tmp;
    call $tmp := $CopyOrMoveValue($t57);
    $t13 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9228, 13, $tmp);
    }

    goto L21;

  L20:
    call $tmp := $And(is_payer_dd, is_payee_vasp);
    $t60 := $tmp;
    call $tmp := $CopyOrMoveValue($t60);
    $t13 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 9228, 13, $tmp);
    }

    goto L21;

  L21:
    $ret0 := $t13;
    if (true)
    {
        assume $DebugTrackLocal(9, 9228, 65, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DualAttestation_dual_attestation_required_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, deposit_value))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $DualAttestation_dual_attestation_required($tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, deposit_value))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $DualAttestation_expiration_date_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_expiration_date_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 6904, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($DualAttestation_Credential_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 6984, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $DualAttestation_Credential_expiration_date);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(9, 6982, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DualAttestation_expiration_date_$direct_inter(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_expiration_date_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_expiration_date_$def(addr);
}



procedure {:inline 1} $DualAttestation_expiration_date_$direct_intra(addr: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_expiration_date_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_expiration_date_$def(addr);
}



procedure {:inline 1} $DualAttestation_expiration_date(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_expiration_date(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_expiration_date_$def(addr);
}



procedure {:inline 1} $DualAttestation_get_cur_microlibra_limit_$def() returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_get_cur_microlibra_limit_$def() returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($DualAttestation_Limit_$memory, $t0, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 16763, $abort_code);
        goto Abort;
    }

    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $DualAttestation_Limit_micro_lbr_limit);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(9, 16763, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DualAttestation_get_cur_microlibra_limit_$direct_inter() returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_get_cur_microlibra_limit_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $DualAttestation_get_cur_microlibra_limit_$def();
}



procedure {:inline 1} $DualAttestation_get_cur_microlibra_limit_$direct_intra() returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_get_cur_microlibra_limit_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $DualAttestation_get_cur_microlibra_limit_$def();
}



procedure {:inline 1} $DualAttestation_get_cur_microlibra_limit() returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_get_cur_microlibra_limit() returns ($ret0: $Value)
{
    call $ret0 := $DualAttestation_get_cur_microlibra_limit_$def();
}



procedure {:inline 1} $DualAttestation_human_name_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_human_name_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 5784, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($DualAttestation_Credential_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 5865, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $DualAttestation_Credential_human_name);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(9, 5863, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $DualAttestation_human_name_$direct_inter(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_human_name_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_human_name_$def(addr);
}



procedure {:inline 1} $DualAttestation_human_name_$direct_intra(addr: $Value) returns ($ret0: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_human_name_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_human_name_$def(addr);
}



procedure {:inline 1} $DualAttestation_human_name(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $DualAttestation_human_name(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $DualAttestation_human_name_$def(addr);
}



procedure {:inline 1} $DualAttestation_publish_credential_$def(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value);



implementation {:inline 1} $DualAttestation_publish_credential_$def(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value)
{
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 3005, 0, created);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 3005, 1, creator);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 3005, 2, human_name);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 3005, 3, base_url);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 3005, 4, compliance_public_key);
    }

    call $tmp := $CopyOrMoveValue(created);
    $t44 := $tmp;
    call $tmp := $CopyOrMoveValue(creator);
    $t45 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t46 := $tmp;
    call $tmp := $CopyOrMoveValue(base_url);
    $t47 := $tmp;
    call $tmp := $CopyOrMoveValue(compliance_public_key);
    $t48 := $tmp;
    call $tmp := $CopyOrMoveValue($t44);
    $t13 := $tmp;
    call $t14 := $Roles_has_parent_VASP_role($t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t14;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $Boolean(true);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 3229, 7, $tmp);
    }

    goto L3;

  L2:
    call $tmp := $CopyOrMoveValue($t44);
    $t16 := $tmp;
    call $t17 := $Roles_has_designated_dealer_role($t16);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t17);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 3229, 7, $tmp);
    }

    goto L3;

  L3:
    call $tmp := $CopyOrMoveValue($t7);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 3209, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $tmp := $CopyOrMoveValue($t45);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t44);
    $t21 := $tmp;
    $tmp := $Integer(2);
    $t22 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 3209, i#$Integer($t22));
    }

    $abort_code := i#$Integer($t22);
    goto Abort;

  L4:
    call $tmp := $CopyOrMoveValue($t45);
    $t23 := $tmp;
    call $t24 := $Roles_has_libra_root_role($t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t24;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    call $tmp := $CopyOrMoveValue($t45);
    $t25 := $tmp;
    $tmp := $Boolean(true);
    $t26 := $tmp;
    call $tmp := $CopyOrMoveValue($t26);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 3387, 10, $tmp);
    }

    goto L9;

  L8:
    call $tmp := $CopyOrMoveValue($t45);
    $t27 := $tmp;
    call $t28 := $Roles_has_treasury_compliance_role($t27);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t28);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 3387, 10, $tmp);
    }

    goto L9;

  L9:
    call $tmp := $CopyOrMoveValue($t10);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 3367, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L10;
    }
    else
    {
        goto L11;
    }

  L11:
    call $tmp := $CopyOrMoveValue($t44);
    $t31 := $tmp;
    $tmp := $Integer(3);
    $t32 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 3367, i#$Integer($t32));
    }

    $abort_code := i#$Integer($t32);
    goto Abort;

  L10:
    call $t34 := $Signature_ed25519_validate_pubkey($t48);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t34);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 3542, 11, $tmp);
    }

    $tmp := $t11;
    if (b#$Boolean($tmp))
    {
        goto L12;
    }
    else
    {
        goto L13;
    }

  L13:
    call $tmp := $CopyOrMoveValue($t44);
    $t36 := $tmp;
    $tmp := $Integer(5);
    $t37 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 3542, i#$Integer($t37));
    }

    $abort_code := i#$Integer($t37);
    goto Abort;

  L12:
    call $tmp := $CopyOrMoveValue($t44);
    $t38 := $tmp;
    $tmp := $Integer(18446744073709551615);
    $t42 := $tmp;
    call $tmp := $DualAttestation_Credential_pack(0, 0, 0, $t46, $t47, $t48, $t42);
    $t43 := $tmp;
    call $DualAttestation_Credential_$memory := $MoveTo($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $t43, $t38);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 3643, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DualAttestation_publish_credential_$direct_inter(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value);
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(created))))) && b#$Boolean($Boolean(!b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(created)))))))) ==> $abort_flag;



implementation {:inline 1} $DualAttestation_publish_credential_$direct_inter(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value)
{
    assume is#$Address(created);
    assume is#$Address(creator);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier719"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier720"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier721"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    call $DualAttestation_publish_credential_$def(created, creator, human_name, base_url, compliance_public_key);
}



procedure {:inline 1} $DualAttestation_publish_credential_$direct_intra(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_publish_credential_$direct_intra(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value)
{
    assume is#$Address(created);
    assume is#$Address(creator);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier722"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier723"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier724"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    call $DualAttestation_publish_credential_$def(created, creator, human_name, base_url, compliance_public_key);
}



procedure {:inline 1} $DualAttestation_publish_credential(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value);



implementation {:inline 1} $DualAttestation_publish_credential(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value)
{
    assume is#$Address(created);
    assume is#$Address(creator);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier725"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier726"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier727"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    call $DualAttestation_publish_credential_$def(created, creator, human_name, base_url, compliance_public_key);
}



procedure {:inline 1} $DualAttestation_rotate_base_url_$def(account: $Value, new_url: $Value);



implementation {:inline 1} $DualAttestation_rotate_base_url_$def(account: $Value, new_url: $Value)
{
  var addr: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Mutation;
  var $t14: $Mutation;
  var $t15: $Value;
  var $t16: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 4382, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 4382, 1, new_url);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(new_url);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    $t5 := $tmp;
    call $t6 := $Signer_address_of($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 4482, 2, $tmp);
    }

    $tmp := $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 4526, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 4526, i#$Integer($t10));
    }

    $abort_code := i#$Integer($t10);
    goto Abort;

  L0:
    call $t13 := $BorrowGlobal($DualAttestation_Credential_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 4592, $abort_code);
        goto Abort;
    }

    call $t14 := $BorrowField($t13, $DualAttestation_Credential_base_url);
    call $DualAttestation_Credential_$memory := $WritebackToGlobal($DualAttestation_Credential_$memory, $t13);
    call $t14 := $WriteRef($t14, $t16);
    call $DualAttestation_Credential_$memory := $WritebackToGlobal($DualAttestation_Credential_$memory, $t14);
    call $t13 := $WritebackToReference($t14, $t13);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DualAttestation_rotate_base_url_$direct_inter(account: $Value, new_url: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)), $DualAttestation_Credential_base_url), new_url)));



implementation {:inline 1} $DualAttestation_rotate_base_url_$direct_inter(account: $Value, new_url: $Value)
{
    assume is#$Address(account);
    assume $Vector_is_well_formed(new_url) && (forall $$0: int :: {:qid "quantifier728"} { $select_vector(new_url, $$0) } $$0 >= 0 && $$0 < $vlen(new_url) ==> $IsValidU8($select_vector(new_url, $$0)));
    call $DualAttestation_rotate_base_url_$def(account, new_url);
}



procedure {:inline 1} $DualAttestation_rotate_base_url_$direct_intra(account: $Value, new_url: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_rotate_base_url_$direct_intra(account: $Value, new_url: $Value)
{
    assume is#$Address(account);
    assume $Vector_is_well_formed(new_url) && (forall $$0: int :: {:qid "quantifier729"} { $select_vector(new_url, $$0) } $$0 >= 0 && $$0 < $vlen(new_url) ==> $IsValidU8($select_vector(new_url, $$0)));
    call $DualAttestation_rotate_base_url_$def(account, new_url);
}



procedure {:inline 1} $DualAttestation_rotate_base_url(account: $Value, new_url: $Value);



implementation {:inline 1} $DualAttestation_rotate_base_url(account: $Value, new_url: $Value)
{
    assume is#$Address(account);
    assume $Vector_is_well_formed(new_url) && (forall $$0: int :: {:qid "quantifier730"} { $select_vector(new_url, $$0) } $$0 >= 0 && $$0 < $vlen(new_url) ==> $IsValidU8($select_vector(new_url, $$0)));
    call $DualAttestation_rotate_base_url_$def(account, new_url);
}



procedure {:inline 1} $DualAttestation_rotate_compliance_public_key_$def(account: $Value, new_key: $Value);



implementation {:inline 1} $DualAttestation_rotate_compliance_public_key_$def(account: $Value, new_key: $Value)
{
  var addr: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Mutation;
  var $t20: $Mutation;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 4939, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 4939, 1, new_key);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(new_key);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t7 := $tmp;
    call $t8 := $Signer_address_of($t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 5075, 2, $tmp);
    }

    $tmp := $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 5119, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 5119, i#$Integer($t12));
    }

    $abort_code := i#$Integer($t12);
    goto Abort;

  L0:
    call $t14 := $Signature_ed25519_validate_pubkey($t22);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 5185, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(5);
    $t16 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 5185, i#$Integer($t16));
    }

    $abort_code := i#$Integer($t16);
    goto Abort;

  L2:
    call $t19 := $BorrowGlobal($DualAttestation_Credential_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 5272, $abort_code);
        goto Abort;
    }

    call $t20 := $BorrowField($t19, $DualAttestation_Credential_compliance_public_key);
    call $DualAttestation_Credential_$memory := $WritebackToGlobal($DualAttestation_Credential_$memory, $t19);
    call $t20 := $WriteRef($t20, $t22);
    call $DualAttestation_Credential_$memory := $WritebackToGlobal($DualAttestation_Credential_$memory, $t20);
    call $t19 := $WritebackToReference($t20, $t19);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DualAttestation_rotate_compliance_public_key_$direct_inter(account: $Value, new_key: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Signature_spec_ed25519_validate_pubkey(new_key))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) || b#$Boolean(old($Boolean(!b#$Boolean($Signature_spec_ed25519_validate_pubkey(new_key)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)), $DualAttestation_Credential_compliance_public_key), new_key)));



implementation {:inline 1} $DualAttestation_rotate_compliance_public_key_$direct_inter(account: $Value, new_key: $Value)
{
    assume is#$Address(account);
    assume $Vector_is_well_formed(new_key) && (forall $$0: int :: {:qid "quantifier731"} { $select_vector(new_key, $$0) } $$0 >= 0 && $$0 < $vlen(new_key) ==> $IsValidU8($select_vector(new_key, $$0)));
    call $DualAttestation_rotate_compliance_public_key_$def(account, new_key);
}



procedure {:inline 1} $DualAttestation_rotate_compliance_public_key_$direct_intra(account: $Value, new_key: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_rotate_compliance_public_key_$direct_intra(account: $Value, new_key: $Value)
{
    assume is#$Address(account);
    assume $Vector_is_well_formed(new_key) && (forall $$0: int :: {:qid "quantifier732"} { $select_vector(new_key, $$0) } $$0 >= 0 && $$0 < $vlen(new_key) ==> $IsValidU8($select_vector(new_key, $$0)));
    call $DualAttestation_rotate_compliance_public_key_$def(account, new_key);
}



procedure {:inline 1} $DualAttestation_rotate_compliance_public_key(account: $Value, new_key: $Value);



implementation {:inline 1} $DualAttestation_rotate_compliance_public_key(account: $Value, new_key: $Value)
{
    assume is#$Address(account);
    assume $Vector_is_well_formed(new_key) && (forall $$0: int :: {:qid "quantifier733"} { $select_vector(new_key, $$0) } $$0 >= 0 && $$0 < $vlen(new_key) ==> $IsValidU8($select_vector(new_key, $$0)));
    call $DualAttestation_rotate_compliance_public_key_$def(account, new_key);
}



procedure {:inline 1} $DualAttestation_set_microlibra_limit_$def(tc_account: $Value, micro_lbr_limit: $Value);



implementation {:inline 1} $DualAttestation_set_microlibra_limit_$def(tc_account: $Value, micro_lbr_limit: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Mutation;
  var $t12: $Value;
  var $t13: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(9, 17165, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(9, 17165, 1, micro_lbr_limit);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue(micro_lbr_limit);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t4 := $tmp;
    call $t5 := $Roles_has_update_dual_attestation_limit_privilege($t4);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(9, 17265, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(4);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(9, 17265, i#$Integer($t7));
    }

    $abort_code := i#$Integer($t7);
    goto Abort;

  L0:
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t10 := $BorrowGlobal($DualAttestation_Limit_$memory, $t9, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(9, 17401, $abort_code);
        goto Abort;
    }

    call $t11 := $BorrowField($t10, $DualAttestation_Limit_micro_lbr_limit);
    call $DualAttestation_Limit_$memory := $WritebackToGlobal($DualAttestation_Limit_$memory, $t10);
    call $t11 := $WriteRef($t11, $t13);
    call $DualAttestation_Limit_$memory := $WritebackToGlobal($DualAttestation_Limit_$memory, $t11);
    call $t10 := $WritebackToReference($t11, $t10);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $DualAttestation_set_microlibra_limit_$direct_inter(tc_account: $Value, micro_lbr_limit: $Value);



implementation {:inline 1} $DualAttestation_set_microlibra_limit_$direct_inter(tc_account: $Value, micro_lbr_limit: $Value)
{
    assume is#$Address(tc_account);
    assume $IsValidU64(micro_lbr_limit);
    call $DualAttestation_set_microlibra_limit_$def(tc_account, micro_lbr_limit);
}



procedure {:inline 1} $DualAttestation_set_microlibra_limit_$direct_intra(tc_account: $Value, micro_lbr_limit: $Value);
  requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory)))) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));



implementation {:inline 1} $DualAttestation_set_microlibra_limit_$direct_intra(tc_account: $Value, micro_lbr_limit: $Value)
{
    assume is#$Address(tc_account);
    assume $IsValidU64(micro_lbr_limit);
    call $DualAttestation_set_microlibra_limit_$def(tc_account, micro_lbr_limit);
}



procedure {:inline 1} $DualAttestation_set_microlibra_limit(tc_account: $Value, micro_lbr_limit: $Value);



implementation {:inline 1} $DualAttestation_set_microlibra_limit(tc_account: $Value, micro_lbr_limit: $Value)
{
    assume is#$Address(tc_account);
    assume $IsValidU64(micro_lbr_limit);
    call $DualAttestation_set_microlibra_limit_$def(tc_account, micro_lbr_limit);
}



function {:inline} $ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory: $Memory, addr: $Value) : $Value
{
  $ResourceExists($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $EmptyTypeValueArray, addr)
}

function {:inline} $ValidatorOperatorConfig_spec_get_human_name($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory: $Memory, addr: $Value) : $Value
{
  $SelectField($ResourceValue($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name)
}

const unique $ValidatorOperatorConfig_ValidatorOperatorConfig: $TypeName;

const $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name: $FieldName;

axiom $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name == 0;

function $ValidatorOperatorConfig_ValidatorOperatorConfig_type_value() : $TypeValue;

axiom $ValidatorOperatorConfig_ValidatorOperatorConfig_type_value(): $TypeValue == $StructType($ValidatorOperatorConfig_ValidatorOperatorConfig, $EmptyTypeValueArray);

var $ValidatorOperatorConfig_ValidatorOperatorConfig_$memory: $Memory;

var $ValidatorOperatorConfig_ValidatorOperatorConfig_$memory_$old: $Memory;

function {:inline} $ValidatorOperatorConfig_ValidatorOperatorConfig_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Vector_is_well_formed($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name)) && (forall $$0: int :: {:qid "quantifier734"} { $select_vector($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name), $$0)))
}

function {:inline} $ValidatorOperatorConfig_ValidatorOperatorConfig_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Vector_is_well_formed($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name)) && (forall $$0: int :: {:qid "quantifier735"} { $select_vector($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name), $$0)))
}

procedure {:inline 1} $ValidatorOperatorConfig_ValidatorOperatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, human_name: $Value) returns ($struct: $Value);



implementation {:inline 1} $ValidatorOperatorConfig_ValidatorOperatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, human_name: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier736"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := human_name], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $ValidatorOperatorConfig_ValidatorOperatorConfig_unpack($struct: $Value) returns (human_name: $Value);



implementation {:inline 1} $ValidatorOperatorConfig_ValidatorOperatorConfig_unpack($struct: $Value) returns (human_name: $Value)
{
    assume is#$Vector($struct);
    human_name := $SelectField($struct, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier737"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
}



procedure {:inline 1} $ValidatorOperatorConfig_get_human_name_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorOperatorConfig_get_human_name_$def(addr: $Value) returns ($ret0: $Value)
{
  var t_ref: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(29, 1418, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t13 := $tmp;
    $tmp := $ResourceExists($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $EmptyTypeValueArray, $t13);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(29, 1514, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(1);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(29, 1514, i#$Integer($t7));
    }

    $abort_code := i#$Integer($t7);
    goto Abort;

  L0:
    call $tmp := $GetGlobal($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $t13, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(29, 1626, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    t_ref := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(29, 1618, 1, $tmp);
    }

    call $tmp := $CopyOrMoveValue(t_ref);
    $t10 := $tmp;
    call $tmp := $GetFieldFromValue($t10, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t12 := $tmp;
    $ret0 := $t12;
    if (true)
    {
        assume $DebugTrackLocal(29, 1680, 14, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $ValidatorOperatorConfig_get_human_name_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorOperatorConfig_spec_get_human_name($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier738"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $ValidatorOperatorConfig_get_human_name_$direct_intra(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorOperatorConfig_spec_get_human_name($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier739"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $ValidatorOperatorConfig_get_human_name(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorOperatorConfig_spec_get_human_name($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier740"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $ValidatorOperatorConfig_publish_$def(account: $Value, lr_account: $Value, human_name: $Value);



implementation {:inline 1} $ValidatorOperatorConfig_publish_$def(account: $Value, lr_account: $Value, human_name: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(29, 343, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(29, 343, 1, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(29, 343, 2, human_name);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue(lr_account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    call $t6 := $Roles_has_libra_root_role($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(29, 470, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t13);
    $t8 := $tmp;
    $tmp := $Integer(0);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(29, 470, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t13);
    $t10 := $tmp;
    call $tmp := $ValidatorOperatorConfig_ValidatorOperatorConfig_pack(0, 0, 0, $t15);
    $t12 := $tmp;
    call $ValidatorOperatorConfig_ValidatorOperatorConfig_$memory := $MoveTo($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $EmptyTypeValueArray, $t12, $t10);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(29, 543, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $ValidatorOperatorConfig_publish_$direct_inter(account: $Value, lr_account: $Value, human_name: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $Signer_spec_address_of(account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $Signer_spec_address_of(account))));
  ensures !$abort_flag ==> b#$Boolean($ValidatorOperatorConfig_spec_exists_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $Signer_spec_address_of(account)));



implementation {:inline 1} $ValidatorOperatorConfig_publish_$direct_inter(account: $Value, lr_account: $Value, human_name: $Value)
{
    assume is#$Address(account);
    assume is#$Address(lr_account);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier741"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $ValidatorOperatorConfig_publish_$def(account, lr_account, human_name);
}



procedure {:inline 1} $ValidatorOperatorConfig_publish_$direct_intra(account: $Value, lr_account: $Value, human_name: $Value);



implementation {:inline 1} $ValidatorOperatorConfig_publish_$direct_intra(account: $Value, lr_account: $Value, human_name: $Value)
{
    assume is#$Address(account);
    assume is#$Address(lr_account);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier742"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $ValidatorOperatorConfig_publish_$def(account, lr_account, human_name);
}



procedure {:inline 1} $ValidatorOperatorConfig_publish(account: $Value, lr_account: $Value, human_name: $Value);



implementation {:inline 1} $ValidatorOperatorConfig_publish(account: $Value, lr_account: $Value, human_name: $Value)
{
    assume is#$Address(account);
    assume is#$Address(lr_account);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier743"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $ValidatorOperatorConfig_publish_$def(account, lr_account, human_name);
}



function {:inline} $Option_spec_none($tv0: $TypeValue) : $Value
{
  $Vector($ExtendValueArray($EmptyValueArray(), $mk_vector()))
}

function {:inline} $Option_spec_some($tv0: $TypeValue, e: $Value) : $Value
{
  $Vector($ExtendValueArray($EmptyValueArray(), $Vector_spec_singleton($tv0, e)))
}

function {:inline} $Option_spec_is_none($tv0: $TypeValue, t: $Value) : $Value
{
  $Boolean($IsEqual($vlen_value($SelectField(t, $Option_Option_vec)), $Integer(0)))
}

function {:inline} $Option_spec_is_some($tv0: $TypeValue, t: $Value) : $Value
{
  $Boolean(!b#$Boolean($Option_spec_is_none($tv0, t)))
}

function {:inline} $Option_spec_contains($tv0: $TypeValue, t: $Value, e: $Value) : $Value
{
  $Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) && b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, t), e))))
}

function {:inline} $Option_spec_get($tv0: $TypeValue, t: $Value) : $Value
{
  $select_vector_by_value($SelectField(t, $Option_Option_vec), $Integer(0))
}

const unique $Option_Option: $TypeName;

const $Option_Option_vec: $FieldName;

axiom $Option_Option_vec == 0;

function $Option_Option_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier744"} { $Option_Option_type_value($tv0): $TypeValue } $Option_Option_type_value($tv0): $TypeValue == $StructType($Option_Option, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $Option_Option_$memory: $Memory;

var $Option_Option_$memory_$old: $Memory;

function {:inline} $Option_Option_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Vector_is_well_formed($SelectField($this, $Option_Option_vec))
}

function {:inline} $Option_Option_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Vector_is_well_formed($SelectField($this, $Option_Option_vec)) && b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($this, $Option_Option_vec))) <= i#$Integer($Integer(1))))
}

procedure {:inline 1} $Option_Option_before_update_inv($tv0: $TypeValue, $before: $Value);



implementation {:inline 1} $Option_Option_before_update_inv($tv0: $TypeValue, $before: $Value)
{
    assume b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($before, $Option_Option_vec))) <= i#$Integer($Integer(1))));
}



procedure {:inline 1} $Option_Option_after_update_inv($tv0: $TypeValue, $after: $Value);



implementation {:inline 1} $Option_Option_after_update_inv($tv0: $TypeValue, $after: $Value)
{
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($after, $Option_Option_vec))) <= i#$Integer($Integer(1))));
}



procedure {:inline 1} $Option_Option_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, vec: $Value) returns ($struct: $Value);



implementation {:inline 1} $Option_Option_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, vec: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(vec);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := vec], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }

    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($struct, $Option_Option_vec))) <= i#$Integer($Integer(1))));
}



procedure {:inline 1} $Option_Option_unpack($tv0: $TypeValue, $struct: $Value) returns (vec: $Value);



implementation {:inline 1} $Option_Option_unpack($tv0: $TypeValue, $struct: $Value) returns (vec: $Value)
{
    assume is#$Vector($struct);
    vec := $SelectField($struct, $Option_Option_vec);
    assume $Vector_is_well_formed(vec);
}



procedure {:inline 1} $Option_borrow_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_borrow_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 2943, 0, t);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Option_Option_vec);
    $t2 := $tmp;
    $tmp := $Integer(0);
    $t3 := $tmp;
    call $t4 := $Vector_borrow($tv0, $t2, $t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(20, 3011, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_borrow_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t))));



procedure {:inline 1} $Option_borrow_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t))));



procedure {:inline 1} $Option_borrow($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t))));



procedure {:inline 1} $Option_borrow_mut_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Mutation, $ret1: $Value);



implementation {:inline 1} $Option_borrow_mut_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Mutation, $ret1: $Value)
{
  var $t1: $Mutation;
  var $t2: $Mutation;
  var $t3: $Value;
  var $t4: $Mutation;
  var $t5: $Value;
  var $t6: $Mutation;
  var $t7: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 5423, 0, t);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t5 := $tmp;
    call $t6 := $BorrowLoc(5, $t5);
    call $t1 := $CopyOrMoveRef($t6);
    call $t2 := $BorrowField($t1, $Option_Option_vec);
    call $t5 := $WritebackToValue($t1, 5, $t5);
    $tmp := $Integer(0);
    $t3 := $tmp;
    call $tmp := $ReadRef($t2);
    $t7 := $tmp;
    call $t4, $t7 := $Vector_borrow_mut($tv0, $t7, $t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t2 := $WriteRef($t2, $t7);
    call $t4 := $Splice1(0, $t2, $t4);
    call $t5 := $WritebackToValue($t2, 5, $t5);
    call $t1 := $WritebackToReference($t2, $t1);
    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(20, 5503, 8, $Dereference($ret0));
    }

    $ret1 := $t5;
    if (true)
    {
        assume $DebugTrackLocal(20, 5503, 9, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultMutation;
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $Option_borrow_mut_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Mutation, $ret1: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Dereference($ret0), $Option_spec_get($tv0, $ret1))));
  ensures $Option_Option_is_well_formed($ret1);



procedure {:inline 1} $Option_borrow_mut_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Mutation, $ret1: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Dereference($ret0), $Option_spec_get($tv0, $ret1))));
  ensures $Option_Option_is_well_formed($ret1);



procedure {:inline 1} $Option_borrow_mut($tv0: $TypeValue, t: $Value) returns ($ret0: $Mutation, $ret1: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Dereference($ret0), $Option_spec_get($tv0, $ret1))));
  ensures $Option_Option_is_well_formed($ret1);



procedure {:inline 1} $Option_contains_$def($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_contains_$def($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 2397, 0, t);
    }

    if (true)
    {
        assume $DebugTrackLocal(20, 2397, 1, e_ref);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue(e_ref);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $Option_Option_vec);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t4 := $tmp;
    call $t5 := $Vector_contains($tv0, $t3, $t4);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t5;
    if (true)
    {
        assume $DebugTrackLocal(20, 2480, 8, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_contains_$direct_inter($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) && b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, t), e_ref)))))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $Option_contains_$direct_intra($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) && b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, t), e_ref)))))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $Option_contains($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) && b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, t), e_ref)))))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $Option_swap_$def($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Option_swap_$def($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var old_value: $Value;
  var vec_ref: $Mutation;
  var $t4: $Mutation;
  var $t5: $Mutation;
  var $t6: $Mutation;
  var $t7: $Value;
  var $t8: $Mutation;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Mutation;
  var $t13: $Value;
  var $t14: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 5800, 0, t);
    }

    if (true)
    {
        assume $DebugTrackLocal(20, 5800, 1, e);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue(e);
    $t13 := $tmp;
    call $t12 := $BorrowLoc(11, $t11);
    call $Option_Option_before_update_inv($tv0, $Dereference($t12));
    call $t4 := $CopyOrMoveRef($t12);
    call $t5 := $BorrowField($t4, $Option_Option_vec);
    call $t11 := $WritebackToValue($t4, 11, $t11);
    call vec_ref := $CopyOrMoveRef($t5);
    if (true)
    {
        assume $DebugTrackLocal(20, 5885, 3, $Dereference(vec_ref));
    }

    call $t6 := $CopyOrMoveRef(vec_ref);
    call $tmp := $ReadRef($t6);
    $t14 := $tmp;
    call $t7, $t14 := $Vector_pop_back($tv0, $t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t6 := $WriteRef($t6, $t14);
    if (true)
    {
        assume $DebugTrackLocal(20, 5800, 3, $Dereference(vec_ref));
    }

    call vec_ref := $WritebackToReference($t6, vec_ref);
    call $tmp := $CopyOrMoveValue($t7);
    old_value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 5919, 2, $tmp);
    }

    call $t8 := $CopyOrMoveRef(vec_ref);
    call $tmp := $ReadRef($t8);
    $t14 := $tmp;
    call $t14 := $Vector_push_back($tv0, $t14, $t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t8 := $WriteRef($t8, $t14);
    if (true)
    {
        assume $DebugTrackLocal(20, 5800, 3, $Dereference(vec_ref));
    }

    call $t11 := $WritebackToValue($t8, 11, $t11);
    call $t4 := $WritebackToReference($t8, $t4);
    call $Option_Option_after_update_inv($tv0, $Dereference($t4));
    $ret0 := old_value;
    if (true)
    {
        assume $DebugTrackLocal(20, 6005, 15, $ret0);
    }

    $ret1 := $t11;
    if (true)
    {
        assume $DebugTrackLocal(20, 6005, 16, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $Option_swap_$direct_inter($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))));
  ensures !$abort_flag ==> b#$Boolean($Option_spec_is_some($tv0, $ret1));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret1), e)));
  ensures $Option_Option_is_well_formed($ret1);



procedure {:inline 1} $Option_swap_$direct_intra($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))));
  ensures !$abort_flag ==> b#$Boolean($Option_spec_is_some($tv0, $ret1));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret1), e)));
  ensures $Option_Option_is_well_formed($ret1);



procedure {:inline 1} $Option_swap($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))));
  ensures !$abort_flag ==> b#$Boolean($Option_spec_is_some($tv0, $ret1));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret1), e)));
  ensures $Option_Option_is_well_formed($ret1);



procedure {:inline 1} $Option_borrow_with_default_$def($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_borrow_with_default_$def($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value)
{
  var $t2: $Value;
  var vec_ref: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 3424, 0, t);
    }

    if (true)
    {
        assume $DebugTrackLocal(20, 3424, 1, default_ref);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(default_ref);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    $t4 := $tmp;
    call $tmp := $GetFieldFromValue($t4, $Option_Option_vec);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    vec_ref := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 3532, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue(vec_ref);
    $t6 := $tmp;
    call $t7 := $Vector_is_empty($tv0, $t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 3558, 2, $tmp);
    }

    goto L3;

  L2:
    call $tmp := $CopyOrMoveValue($t16);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t11 := $tmp;
    $tmp := $Integer(0);
    $t12 := $tmp;
    call $t13 := $Vector_borrow($tv0, $t11, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 3558, 2, $tmp);
    }

    goto L3;

  L3:
    call $tmp := $CopyOrMoveValue($t2);
    $t14 := $tmp;
    $ret0 := $t14;
    if (true)
    {
        assume $DebugTrackLocal(20, 3558, 17, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_borrow_with_default_$direct_inter($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, default_ref)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t))))));



procedure {:inline 1} $Option_borrow_with_default_$direct_intra($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, default_ref)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t))))));



procedure {:inline 1} $Option_borrow_with_default($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, default_ref)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t))))));



procedure {:inline 1} $Option_destroy_none_$def($tv0: $TypeValue, t: $Value);



implementation {:inline 1} $Option_destroy_none_$def($tv0: $TypeValue, t: $Value)
{
  var vec: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 7257, 0, t);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t5 := $tmp;
    call $t3 := $Option_Option_unpack($tv0, $t5);
    $t3 := $t3;
    call $tmp := $CopyOrMoveValue($t3);
    vec := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 7333, 1, $tmp);
    }

    call $Vector_destroy_empty($tv0, vec);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $Option_destroy_none_$direct_inter($tv0: $TypeValue, t: $Value);
  ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_some($tv0, t)));



procedure {:inline 1} $Option_destroy_none_$direct_intra($tv0: $TypeValue, t: $Value);
  ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_some($tv0, t)));



procedure {:inline 1} $Option_destroy_none($tv0: $TypeValue, t: $Value);
  ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_some($tv0, t)));



procedure {:inline 1} $Option_destroy_some_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_destroy_some_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
{
  var elem: $Value;
  var vec: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 6855, 0, t);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t9 := $tmp;
    call $t4 := $Option_Option_unpack($tv0, $t9);
    $t4 := $t4;
    call $tmp := $CopyOrMoveValue($t4);
    vec := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 6940, 2, $tmp);
    }

    call $t5 := $BorrowLoc(2, vec);
    call $tmp := $ReadRef($t5);
    $t10 := $tmp;
    call $t6, $t10 := $Vector_pop_back($tv0, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t5 := $WriteRef($t5, $t10);
    call vec := $WritebackToValue($t5, 2, vec);
    call $tmp := $CopyOrMoveValue($t6);
    elem := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 6963, 1, $tmp);
    }

    call $Vector_destroy_empty($tv0, vec);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := elem;
    if (true)
    {
        assume $DebugTrackLocal(20, 7042, 11, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_destroy_some_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))));



procedure {:inline 1} $Option_destroy_some_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))));



procedure {:inline 1} $Option_destroy_some($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))));



procedure {:inline 1} $Option_destroy_with_default_$def($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_destroy_with_default_$def($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
{
  var $t2: $Value;
  var vec: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Mutation;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 6311, 0, t);
    }

    if (true)
    {
        assume $DebugTrackLocal(20, 6311, 1, default);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue(default);
    $t14 := $tmp;
    call $t5 := $Option_Option_unpack($tv0, $t13);
    $t5 := $t5;
    call $tmp := $CopyOrMoveValue($t5);
    vec := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 6432, 3, $tmp);
    }

    call $t6 := $BorrowLoc(3, vec);
    call $tmp := $ReadRef($t6);
    $t7 := $tmp;
    call vec := $WritebackToValue($t6, 3, vec);
    call $t8 := $Vector_is_empty($tv0, $t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $CopyOrMoveValue($t14);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 6451, 2, $tmp);
    }

    goto L3;

  L2:
    call $t10 := $BorrowLoc(3, vec);
    call $tmp := $ReadRef($t10);
    $t15 := $tmp;
    call $t11, $t15 := $Vector_pop_back($tv0, $t15);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t10 := $WriteRef($t10, $t15);
    call vec := $WritebackToValue($t10, 3, vec);
    call $tmp := $CopyOrMoveValue($t11);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 6451, 2, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(20, 6451, 16, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_destroy_with_default_$direct_inter($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, old(t))) ==> b#$Boolean($Boolean($IsEqual($ret0, default)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, old(t))) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))))));



procedure {:inline 1} $Option_destroy_with_default_$direct_intra($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, old(t))) ==> b#$Boolean($Boolean($IsEqual($ret0, default)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, old(t))) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))))));



procedure {:inline 1} $Option_destroy_with_default($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, old(t))) ==> b#$Boolean($Boolean($IsEqual($ret0, default)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, old(t))) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))))));



procedure {:inline 1} $Option_extract_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $Option_extract_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var $t1: $Mutation;
  var $t2: $Mutation;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 5037, 0, t);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t4 := $tmp;
    call $t5 := $BorrowLoc(4, $t4);
    call $Option_Option_before_update_inv($tv0, $Dereference($t5));
    call $t1 := $CopyOrMoveRef($t5);
    call $t2 := $BorrowField($t1, $Option_Option_vec);
    call $t4 := $WritebackToValue($t1, 4, $t4);
    call $tmp := $ReadRef($t2);
    $t6 := $tmp;
    call $t3, $t6 := $Vector_pop_back($tv0, $t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t2 := $WriteRef($t2, $t6);
    call $t4 := $WritebackToValue($t2, 4, $t4);
    call $t1 := $WritebackToReference($t2, $t1);
    call $Option_Option_after_update_inv($tv0, $Dereference($t1));
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(20, 5109, 7, $ret0);
    }

    $ret1 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(20, 5109, 8, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $Option_extract_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))));
  ensures !$abort_flag ==> b#$Boolean($Option_spec_is_none($tv0, $ret1));
  ensures $Option_Option_is_well_formed($ret1);



procedure {:inline 1} $Option_extract_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))));
  ensures !$abort_flag ==> b#$Boolean($Option_spec_is_none($tv0, $ret1));
  ensures $Option_Option_is_well_formed($ret1);



procedure {:inline 1} $Option_extract($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_none($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t)))));
  ensures !$abort_flag ==> b#$Boolean($Option_spec_is_none($tv0, $ret1));
  ensures $Option_Option_is_well_formed($ret1);



procedure {:inline 1} $Option_fill_$def($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_fill_$def($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value)
{
  var vec_ref: $Mutation;
  var $t3: $Mutation;
  var $t4: $Mutation;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Mutation;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Mutation;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 4517, 0, t);
    }

    if (true)
    {
        assume $DebugTrackLocal(20, 4517, 1, e);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue(e);
    $t14 := $tmp;
    call $t13 := $BorrowLoc(12, $t12);
    call $Option_Option_before_update_inv($tv0, $Dereference($t13));
    call $t3 := $CopyOrMoveRef($t13);
    call $t4 := $BorrowField($t3, $Option_Option_vec);
    call $t12 := $WritebackToValue($t3, 12, $t12);
    call vec_ref := $CopyOrMoveRef($t4);
    if (true)
    {
        assume $DebugTrackLocal(20, 4593, 2, $Dereference(vec_ref));
    }

    call $t5 := $CopyOrMoveRef(vec_ref);
    call $tmp := $ReadRef($t5);
    $t6 := $tmp;
    call vec_ref := $WritebackToReference($t5, vec_ref);
    call $t7 := $Vector_is_empty($tv0, $t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t8 := $CopyOrMoveRef(vec_ref);
    call $t12 := $WritebackToValue($t8, 12, $t12);
    call $t3 := $WritebackToReference($t8, $t3);
    call $Option_Option_after_update_inv($tv0, $Dereference($t3));
    $tmp := $Integer(0);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(20, 4697, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $t10 := $CopyOrMoveRef(vec_ref);
    call $tmp := $ReadRef($t10);
    $t15 := $tmp;
    call $t15 := $Vector_push_back($tv0, $t15, $t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t10 := $WriteRef($t10, $t15);
    if (true)
    {
        assume $DebugTrackLocal(20, 4517, 2, $Dereference(vec_ref));
    }

    call $t12 := $WritebackToValue($t10, 12, $t12);
    call $t3 := $WritebackToReference($t10, $t3);
    call $Option_Option_after_update_inv($tv0, $Dereference($t3));
    $ret0 := $t12;
    if (true)
    {
        assume $DebugTrackLocal(20, 4623, 16, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_fill_$direct_inter($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_some($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Option_spec_is_some($tv0, $ret0));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret0), e)));
  ensures $Option_Option_is_well_formed($ret0);



procedure {:inline 1} $Option_fill_$direct_intra($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_some($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Option_spec_is_some($tv0, $ret0));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret0), e)));
  ensures $Option_Option_is_well_formed($ret0);



procedure {:inline 1} $Option_fill($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Option_spec_is_some($tv0, t)));
  ensures !$abort_flag ==> b#$Boolean($Option_spec_is_some($tv0, $ret0));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret0), e)));
  ensures $Option_Option_is_well_formed($ret0);



procedure {:inline 1} $Option_get_with_default_$def($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_get_with_default_$def($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
{
  var $t2: $Value;
  var vec_ref: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 3972, 0, t);
    }

    if (true)
    {
        assume $DebugTrackLocal(20, 3972, 1, default);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(default);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    $t4 := $tmp;
    call $tmp := $GetFieldFromValue($t4, $Option_Option_vec);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    vec_ref := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 4081, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue(vec_ref);
    $t6 := $tmp;
    call $t7 := $Vector_is_empty($tv0, $t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t7;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 4107, 2, $tmp);
    }

    goto L3;

  L2:
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t10 := $tmp;
    $tmp := $Integer(0);
    $t11 := $tmp;
    call $t12 := $Vector_borrow($tv0, $t10, $t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(20, 4107, 2, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(20, 4107, 17, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_get_with_default_$direct_inter($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, default)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t))))));



procedure {:inline 1} $Option_get_with_default_$direct_intra($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, default)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t))))));



procedure {:inline 1} $Option_get_with_default($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, default)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t))))));



procedure {:inline 1} $Option_is_none_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_is_none_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 1524, 0, t);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Option_Option_vec);
    $t2 := $tmp;
    call $t3 := $Vector_is_empty($tv0, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(20, 1589, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_is_none_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_none($tv0, t))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $Option_is_none_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_none($tv0, t))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $Option_is_none($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_none($tv0, t))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $Option_is_some_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_is_some_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 1920, 0, t);
    }

    call $tmp := $CopyOrMoveValue(t);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $Option_Option_vec);
    $t2 := $tmp;
    call $t3 := $Vector_is_empty($tv0, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t3);
    $t4 := $tmp;
    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(20, 1985, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_is_some_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_some($tv0, t))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $Option_is_some_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_some($tv0, t))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $Option_is_some($tv0: $TypeValue, t: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_some($tv0, t))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $Option_none_$def($tv0: $TypeValue) returns ($ret0: $Value);



implementation {:inline 1} $Option_none_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
  var $t0: $Value;
  var $t1: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    call $t0 := $Vector_empty($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Option_Option_pack(0, 0, 0, $tv0, $t0);
    $t1 := $tmp;
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(20, 743, 2, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_none_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_none($tv0))));
  ensures $Option_Option_is_well_formed($ret0);



procedure {:inline 1} $Option_none_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_none($tv0))));
  ensures $Option_Option_is_well_formed($ret0);



procedure {:inline 1} $Option_none($tv0: $TypeValue) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_none($tv0))));
  ensures $Option_Option_is_well_formed($ret0);



procedure {:inline 1} $Option_some_$def($tv0: $TypeValue, e: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_some_$def($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(20, 1088, 0, e);
    }

    call $tmp := $CopyOrMoveValue(e);
    $t4 := $tmp;
    call $t2 := $Vector_singleton($tv0, $t4);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Option_Option_pack(0, 0, 0, $tv0, $t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(20, 1152, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $Option_some_$direct_inter($tv0: $TypeValue, e: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_some($tv0, e))));



implementation {:inline 1} $Option_some_$direct_inter($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Option_some_$def($tv0, e);
}



procedure {:inline 1} $Option_some_$direct_intra($tv0: $TypeValue, e: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_some_$direct_intra($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Option_some_$def($tv0, e);
}



procedure {:inline 1} $Option_some($tv0: $TypeValue, e: $Value) returns ($ret0: $Value);



implementation {:inline 1} $Option_some($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Option_some_$def($tv0, e);
}



function {:inline} $ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value) : $Value
{
  $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr)
}

function {:inline} $ValidatorConfig_spec_has_operator($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value) : $Value
{
  $Option_spec_is_some($AddressType(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_operator_account))
}

function {:inline} $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value) : $Value
{
  (if b#$Boolean($ValidatorConfig_spec_has_operator($ValidatorConfig_ValidatorConfig_$memory, addr)) then $Option_spec_get($AddressType(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_operator_account)) else addr)
}

function {:inline} $ValidatorConfig_spec_get_human_name($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value) : $Value
{
  $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_human_name)
}

function {:inline} $ValidatorConfig_spec_has_config($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value) : $Value
{
  $Option_spec_is_some($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config))
}

function {:inline} $ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value) : $Value
{
  $Boolean(b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)) && b#$Boolean($ValidatorConfig_spec_has_config($ValidatorConfig_ValidatorConfig_$memory, addr)))
}

function {:inline} $ValidatorConfig_spec_get_config($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value) : $Value
{
  $Option_spec_get($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config))
}

const unique $ValidatorConfig_Config: $TypeName;

const $ValidatorConfig_Config_consensus_pubkey: $FieldName;

axiom $ValidatorConfig_Config_consensus_pubkey == 0;

const $ValidatorConfig_Config_validator_network_identity_pubkey: $FieldName;

axiom $ValidatorConfig_Config_validator_network_identity_pubkey == 1;

const $ValidatorConfig_Config_validator_network_address: $FieldName;

axiom $ValidatorConfig_Config_validator_network_address == 2;

const $ValidatorConfig_Config_full_node_network_identity_pubkey: $FieldName;

axiom $ValidatorConfig_Config_full_node_network_identity_pubkey == 3;

const $ValidatorConfig_Config_full_node_network_address: $FieldName;

axiom $ValidatorConfig_Config_full_node_network_address == 4;

function $ValidatorConfig_Config_type_value() : $TypeValue;

axiom $ValidatorConfig_Config_type_value(): $TypeValue == $StructType($ValidatorConfig_Config, $EmptyTypeValueArray);

var $ValidatorConfig_Config_$memory: $Memory;

var $ValidatorConfig_Config_$memory_$old: $Memory;

function {:inline} $ValidatorConfig_Config_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 5 && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) && (forall $$0: int :: {:qid "quantifier745"} { $select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey), $$0))) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey)) && (forall $$0: int :: {:qid "quantifier746"} { $select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey), $$0))) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_validator_network_address)) && (forall $$0: int :: {:qid "quantifier747"} { $select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_address), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_validator_network_address)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_address), $$0))) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey)) && (forall $$0: int :: {:qid "quantifier748"} { $select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey), $$0))) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_full_node_network_address)) && (forall $$0: int :: {:qid "quantifier749"} { $select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_address), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_full_node_network_address)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_address), $$0)))
}

function {:inline} $ValidatorConfig_Config_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 5 && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) && (forall $$0: int :: {:qid "quantifier750"} { $select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey), $$0))) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey)) && (forall $$0: int :: {:qid "quantifier751"} { $select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey), $$0))) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_validator_network_address)) && (forall $$0: int :: {:qid "quantifier752"} { $select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_address), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_validator_network_address)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_address), $$0))) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey)) && (forall $$0: int :: {:qid "quantifier753"} { $select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey), $$0))) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_full_node_network_address)) && (forall $$0: int :: {:qid "quantifier754"} { $select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_address), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_full_node_network_address)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_address), $$0)))
}

procedure {:inline 1} $ValidatorConfig_Config_pack($file_id: int, $byte_index: int, $var_idx: int, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value) returns ($struct: $Value);



implementation {:inline 1} $ValidatorConfig_Config_pack($file_id: int, $byte_index: int, $var_idx: int, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(consensus_pubkey) && (forall $$0: int :: {:qid "quantifier755"} { $select_vector(consensus_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey, $$0)));
    assume $Vector_is_well_formed(validator_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier756"} { $select_vector(validator_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_identity_pubkey) ==> $IsValidU8($select_vector(validator_network_identity_pubkey, $$0)));
    assume $Vector_is_well_formed(validator_network_address) && (forall $$0: int :: {:qid "quantifier757"} { $select_vector(validator_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_address) ==> $IsValidU8($select_vector(validator_network_address, $$0)));
    assume $Vector_is_well_formed(full_node_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier758"} { $select_vector(full_node_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_identity_pubkey) ==> $IsValidU8($select_vector(full_node_network_identity_pubkey, $$0)));
    assume $Vector_is_well_formed(full_node_network_address) && (forall $$0: int :: {:qid "quantifier759"} { $select_vector(full_node_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_address) ==> $IsValidU8($select_vector(full_node_network_address, $$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := consensus_pubkey][1 := validator_network_identity_pubkey][2 := validator_network_address][3 := full_node_network_identity_pubkey][4 := full_node_network_address], 5));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $ValidatorConfig_Config_unpack($struct: $Value) returns (consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value);



implementation {:inline 1} $ValidatorConfig_Config_unpack($struct: $Value) returns (consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value)
{
    assume is#$Vector($struct);
    consensus_pubkey := $SelectField($struct, $ValidatorConfig_Config_consensus_pubkey);
    assume $Vector_is_well_formed(consensus_pubkey) && (forall $$0: int :: {:qid "quantifier760"} { $select_vector(consensus_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey, $$0)));
    validator_network_identity_pubkey := $SelectField($struct, $ValidatorConfig_Config_validator_network_identity_pubkey);
    assume $Vector_is_well_formed(validator_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier761"} { $select_vector(validator_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_identity_pubkey) ==> $IsValidU8($select_vector(validator_network_identity_pubkey, $$0)));
    validator_network_address := $SelectField($struct, $ValidatorConfig_Config_validator_network_address);
    assume $Vector_is_well_formed(validator_network_address) && (forall $$0: int :: {:qid "quantifier762"} { $select_vector(validator_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_address) ==> $IsValidU8($select_vector(validator_network_address, $$0)));
    full_node_network_identity_pubkey := $SelectField($struct, $ValidatorConfig_Config_full_node_network_identity_pubkey);
    assume $Vector_is_well_formed(full_node_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier763"} { $select_vector(full_node_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_identity_pubkey) ==> $IsValidU8($select_vector(full_node_network_identity_pubkey, $$0)));
    full_node_network_address := $SelectField($struct, $ValidatorConfig_Config_full_node_network_address);
    assume $Vector_is_well_formed(full_node_network_address) && (forall $$0: int :: {:qid "quantifier764"} { $select_vector(full_node_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_address) ==> $IsValidU8($select_vector(full_node_network_address, $$0)));
}



const unique $ValidatorConfig_ValidatorConfig: $TypeName;

const $ValidatorConfig_ValidatorConfig_config: $FieldName;

axiom $ValidatorConfig_ValidatorConfig_config == 0;

const $ValidatorConfig_ValidatorConfig_operator_account: $FieldName;

axiom $ValidatorConfig_ValidatorConfig_operator_account == 1;

const $ValidatorConfig_ValidatorConfig_human_name: $FieldName;

axiom $ValidatorConfig_ValidatorConfig_human_name == 2;

function $ValidatorConfig_ValidatorConfig_type_value() : $TypeValue;

axiom $ValidatorConfig_ValidatorConfig_type_value(): $TypeValue == $StructType($ValidatorConfig_ValidatorConfig, $EmptyTypeValueArray);

var $ValidatorConfig_ValidatorConfig_$memory: $Memory;

var $ValidatorConfig_ValidatorConfig_$memory_$old: $Memory;

function {:inline} $ValidatorConfig_ValidatorConfig_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $Option_Option_is_well_formed_types($SelectField($this, $ValidatorConfig_ValidatorConfig_config)) && $Option_Option_is_well_formed_types($SelectField($this, $ValidatorConfig_ValidatorConfig_operator_account)) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name)) && (forall $$0: int :: {:qid "quantifier765"} { $select_vector($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name), $$0)))
}

function {:inline} $ValidatorConfig_ValidatorConfig_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 3 && $Option_Option_is_well_formed($SelectField($this, $ValidatorConfig_ValidatorConfig_config)) && $Option_Option_is_well_formed($SelectField($this, $ValidatorConfig_ValidatorConfig_operator_account)) && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name)) && (forall $$0: int :: {:qid "quantifier766"} { $select_vector($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name), $$0)))
}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_before_update_inv($before: $Value);



implementation {:inline 1} $ValidatorConfig_ValidatorConfig_before_update_inv($before: $Value)
{
    call $Option_Option_before_update_inv($ValidatorConfig_Config_type_value(), $SelectField($before, $ValidatorConfig_ValidatorConfig_config));
    call $Option_Option_before_update_inv($AddressType(), $SelectField($before, $ValidatorConfig_ValidatorConfig_operator_account));
}



procedure {:inline 1} $ValidatorConfig_ValidatorConfig_after_update_inv($after: $Value);



implementation {:inline 1} $ValidatorConfig_ValidatorConfig_after_update_inv($after: $Value)
{
    call $Option_Option_after_update_inv($ValidatorConfig_Config_type_value(), $SelectField($after, $ValidatorConfig_ValidatorConfig_config));
    call $Option_Option_after_update_inv($AddressType(), $SelectField($after, $ValidatorConfig_ValidatorConfig_operator_account));
}



procedure {:inline 1} $ValidatorConfig_ValidatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, config: $Value, operator_account: $Value, human_name: $Value) returns ($struct: $Value);



implementation {:inline 1} $ValidatorConfig_ValidatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, config: $Value, operator_account: $Value, human_name: $Value) returns ($struct: $Value)
{
    assume $Option_Option_is_well_formed(config);
    assume $Option_Option_is_well_formed(operator_account);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier767"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := config][1 := operator_account][2 := human_name], 3));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $ValidatorConfig_ValidatorConfig_unpack($struct: $Value) returns (config: $Value, operator_account: $Value, human_name: $Value);



implementation {:inline 1} $ValidatorConfig_ValidatorConfig_unpack($struct: $Value) returns (config: $Value, operator_account: $Value, human_name: $Value)
{
    assume is#$Vector($struct);
    config := $SelectField($struct, $ValidatorConfig_ValidatorConfig_config);
    assume $Option_Option_is_well_formed(config);
    operator_account := $SelectField($struct, $ValidatorConfig_ValidatorConfig_operator_account);
    assume $Option_Option_is_well_formed(operator_account);
    human_name := $SelectField($struct, $ValidatorConfig_ValidatorConfig_human_name);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier768"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
}



const unique $ValidatorConfig_UpdateValidatorConfig: $TypeName;

const $ValidatorConfig_UpdateValidatorConfig_dummy_field: $FieldName;

axiom $ValidatorConfig_UpdateValidatorConfig_dummy_field == 0;

function $ValidatorConfig_UpdateValidatorConfig_type_value() : $TypeValue;

axiom $ValidatorConfig_UpdateValidatorConfig_type_value(): $TypeValue == $StructType($ValidatorConfig_UpdateValidatorConfig, $EmptyTypeValueArray);

var $ValidatorConfig_UpdateValidatorConfig_$memory: $Memory;

var $ValidatorConfig_UpdateValidatorConfig_$memory_$old: $Memory;

function {:inline} $ValidatorConfig_UpdateValidatorConfig_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $ValidatorConfig_UpdateValidatorConfig_dummy_field))
}

function {:inline} $ValidatorConfig_UpdateValidatorConfig_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Boolean($SelectField($this, $ValidatorConfig_UpdateValidatorConfig_dummy_field))
}

procedure {:inline 1} $ValidatorConfig_UpdateValidatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value);



implementation {:inline 1} $ValidatorConfig_UpdateValidatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $ValidatorConfig_UpdateValidatorConfig_unpack($struct: $Value) returns (dummy_field: $Value);



implementation {:inline 1} $ValidatorConfig_UpdateValidatorConfig_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $ValidatorConfig_UpdateValidatorConfig_dummy_field);
    assume is#$Boolean(dummy_field);
}



procedure {:inline 1} $ValidatorConfig_get_human_name_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_human_name_$def(addr: $Value) returns ($ret0: $Value)
{
  var t_ref: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 8492, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t13 := $tmp;
    $tmp := $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t13);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 8580, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(28, 8580, i#$Integer($t7));
    }

    $abort_code := i#$Integer($t7);
    goto Abort;

  L0:
    call $tmp := $GetGlobal($ValidatorConfig_ValidatorConfig_$memory, $t13, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(28, 8675, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    t_ref := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 8667, 1, $tmp);
    }

    call $tmp := $CopyOrMoveValue(t_ref);
    $t10 := $tmp;
    call $tmp := $GetFieldFromValue($t10, $ValidatorConfig_ValidatorConfig_human_name);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t12 := $tmp;
    $ret0 := $t12;
    if (true)
    {
        assume $DebugTrackLocal(28, 8721, 14, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $ValidatorConfig_get_human_name_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_human_name($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier769"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $ValidatorConfig_get_human_name_$direct_intra(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall validator: $Value :: {:qid "quantifier770"} is#$Address(validator) ==> b#$Boolean($Boolean(b#$Boolean(old($ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, validator))) ==> b#$Boolean($ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, validator)))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_human_name($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier771"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $ValidatorConfig_get_human_name(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_human_name($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures $Vector_is_well_formed($ret0) && (forall $$0: int :: {:qid "quantifier772"} { $select_vector($ret0, $$0) } $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0, $$0)));



procedure {:inline 1} $ValidatorConfig_publish_$def(account: $Value, lr_account: $Value, human_name: $Value);



implementation {:inline 1} $ValidatorConfig_publish_$def(account: $Value, lr_account: $Value, human_name: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 1304, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(28, 1304, 1, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(28, 1304, 2, human_name);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(lr_account);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t5 := $tmp;
    call $t6 := $Roles_has_libra_root_role($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 1431, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t15);
    $t8 := $tmp;
    $tmp := $Integer(0);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(28, 1431, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t15);
    $t10 := $tmp;
    call $t11 := $Option_none($ValidatorConfig_Config_type_value());
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t12 := $Option_none($AddressType());
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $ValidatorConfig_ValidatorConfig_pack(0, 0, 0, $t11, $t12, $t17);
    $t14 := $tmp;
    call $ValidatorConfig_ValidatorConfig_$memory := $MoveTo($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t14, $t10);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(28, 1504, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $ValidatorConfig_publish_$direct_inter(account: $Value, lr_account: $Value, human_name: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(lr_account)))))) || b#$Boolean(old($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account))));
  ensures !$abort_flag ==> b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account)));



implementation {:inline 1} $ValidatorConfig_publish_$direct_inter(account: $Value, lr_account: $Value, human_name: $Value)
{
    assume is#$Address(account);
    assume is#$Address(lr_account);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier773"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $ValidatorConfig_publish_$def(account, lr_account, human_name);
}



procedure {:inline 1} $ValidatorConfig_publish_$direct_intra(account: $Value, lr_account: $Value, human_name: $Value);



implementation {:inline 1} $ValidatorConfig_publish_$direct_intra(account: $Value, lr_account: $Value, human_name: $Value)
{
    assume is#$Address(account);
    assume is#$Address(lr_account);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier774"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $ValidatorConfig_publish_$def(account, lr_account, human_name);
}



procedure {:inline 1} $ValidatorConfig_publish(account: $Value, lr_account: $Value, human_name: $Value);



implementation {:inline 1} $ValidatorConfig_publish(account: $Value, lr_account: $Value, human_name: $Value)
{
    assume is#$Address(account);
    assume is#$Address(lr_account);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier775"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $ValidatorConfig_publish_$def(account, lr_account, human_name);
}



procedure {:inline 1} $ValidatorConfig_get_config_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_config_$def(addr: $Value) returns ($ret0: $Value)
{
  var config: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 7719, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t14 := $tmp;
    $tmp := $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t14);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 7799, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(28, 7799, i#$Integer($t7));
    }

    $abort_code := i#$Integer($t7);
    goto Abort;

  L0:
    call $tmp := $GetGlobal($ValidatorConfig_ValidatorConfig_$memory, $t14, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(28, 7896, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $tmp := $GetFieldFromValue($t9, $ValidatorConfig_ValidatorConfig_config);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    config := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 7886, 1, $tmp);
    }

    call $tmp := $CopyOrMoveValue(config);
    $t11 := $tmp;
    call $t12 := $Option_borrow($ValidatorConfig_Config_type_value(), $t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    $t13 := $tmp;
    $ret0 := $t13;
    if (true)
    {
        assume $DebugTrackLocal(28, 7949, 15, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $ValidatorConfig_get_config_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_has_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) || b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_has_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_config($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures $ValidatorConfig_Config_is_well_formed($ret0);



procedure {:inline 1} $ValidatorConfig_get_config_$direct_intra(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_has_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) || b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_has_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall validator: $Value :: {:qid "quantifier776"} is#$Address(validator) ==> b#$Boolean($Boolean(b#$Boolean(old($ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, validator))) ==> b#$Boolean($ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, validator)))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_config($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures $ValidatorConfig_Config_is_well_formed($ret0);



procedure {:inline 1} $ValidatorConfig_get_config(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_has_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) || b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_has_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_config($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures $ValidatorConfig_Config_is_well_formed($ret0);



procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey_$def(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_consensus_pubkey_$def(config_ref: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 9582, 0, config_ref);
    }

    call $tmp := $CopyOrMoveValue(config_ref);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $ValidatorConfig_Config_consensus_pubkey);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(28, 9658, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey_$direct_inter(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_consensus_pubkey_$direct_inter(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_is_well_formed(config_ref);
    call $ret0 := $ValidatorConfig_get_consensus_pubkey_$def(config_ref);
}



procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey_$direct_intra(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_consensus_pubkey_$direct_intra(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_is_well_formed(config_ref);
    call $ret0 := $ValidatorConfig_get_consensus_pubkey_$def(config_ref);
}



procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_consensus_pubkey(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_is_well_formed(config_ref);
    call $ret0 := $ValidatorConfig_get_consensus_pubkey_$def(config_ref);
}



procedure {:inline 1} $ValidatorConfig_get_operator_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_operator_$def(addr: $Value) returns ($ret0: $Value)
{
  var t_ref: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 9063, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t15 := $tmp;
    $tmp := $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t15);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 9146, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(28, 9146, i#$Integer($t7));
    }

    $abort_code := i#$Integer($t7);
    goto Abort;

  L0:
    call $tmp := $GetGlobal($ValidatorConfig_ValidatorConfig_$memory, $t15, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(28, 9241, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    t_ref := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 9233, 1, $tmp);
    }

    call $tmp := $CopyOrMoveValue(t_ref);
    $t10 := $tmp;
    call $tmp := $GetFieldFromValue($t10, $ValidatorConfig_ValidatorConfig_operator_account);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    $t12 := $tmp;
    call $t13 := $Option_borrow_with_default($AddressType(), $t11, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    $t14 := $tmp;
    $ret0 := $t14;
    if (true)
    {
        assume $DebugTrackLocal(28, 9287, 16, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $ValidatorConfig_get_operator_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures is#$Address($ret0);



procedure {:inline 1} $ValidatorConfig_get_operator_$direct_intra(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall validator: $Value :: {:qid "quantifier777"} is#$Address(validator) ==> b#$Boolean($Boolean(b#$Boolean(old($ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, validator))) ==> b#$Boolean($ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, validator)))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures is#$Address($ret0);



procedure {:inline 1} $ValidatorConfig_get_operator(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures is#$Address($ret0);



procedure {:inline 1} $ValidatorConfig_get_validator_network_address_$def(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_validator_network_address_$def(config_ref: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 10002, 0, config_ref);
    }

    call $tmp := $CopyOrMoveValue(config_ref);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $ValidatorConfig_Config_validator_network_address);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(28, 10087, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $ValidatorConfig_get_validator_network_address_$direct_inter(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_validator_network_address_$direct_inter(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_is_well_formed(config_ref);
    call $ret0 := $ValidatorConfig_get_validator_network_address_$def(config_ref);
}



procedure {:inline 1} $ValidatorConfig_get_validator_network_address_$direct_intra(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_validator_network_address_$direct_intra(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_is_well_formed(config_ref);
    call $ret0 := $ValidatorConfig_get_validator_network_address_$def(config_ref);
}



procedure {:inline 1} $ValidatorConfig_get_validator_network_address(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_validator_network_address(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_is_well_formed(config_ref);
    call $ret0 := $ValidatorConfig_get_validator_network_address_$def(config_ref);
}



procedure {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey_$def(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey_$def(config_ref: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 9779, 0, config_ref);
    }

    call $tmp := $CopyOrMoveValue(config_ref);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $ValidatorConfig_Config_validator_network_identity_pubkey);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(28, 9872, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey_$direct_inter(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey_$direct_inter(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_is_well_formed(config_ref);
    call $ret0 := $ValidatorConfig_get_validator_network_identity_pubkey_$def(config_ref);
}



procedure {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey_$direct_intra(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey_$direct_intra(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_is_well_formed(config_ref);
    call $ret0 := $ValidatorConfig_get_validator_network_identity_pubkey_$def(config_ref);
}



procedure {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey(config_ref: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_is_well_formed(config_ref);
    call $ret0 := $ValidatorConfig_get_validator_network_identity_pubkey_$def(config_ref);
}



procedure {:inline 1} $ValidatorConfig_is_valid_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $ValidatorConfig_is_valid_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 6819, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t10 := $tmp;
    $tmp := $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t10);
    $t3 := $tmp;
    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $GetGlobal($ValidatorConfig_ValidatorConfig_$memory, $t10, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(28, 6945, $abort_code);
        goto Abort;
    }

    $t5 := $tmp;
    call $tmp := $GetFieldFromValue($t5, $ValidatorConfig_ValidatorConfig_config);
    $t6 := $tmp;
    call $t7 := $Option_is_some($ValidatorConfig_Config_type_value(), $t6);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 6895, 1, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Boolean(false);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 6895, 1, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(28, 6895, 11, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $ValidatorConfig_is_valid_$direct_inter(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $ValidatorConfig_is_valid_$direct_intra(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures !$abort_flag ==> b#$Boolean($Boolean((forall validator: $Value :: {:qid "quantifier778"} is#$Address(validator) ==> b#$Boolean($Boolean(b#$Boolean(old($ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, validator))) ==> b#$Boolean($ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, validator)))))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $ValidatorConfig_is_valid(addr: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(false)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_is_valid($ValidatorConfig_ValidatorConfig_$memory, addr))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $ValidatorConfig_remove_operator_$def(account: $Value);



implementation {:inline 1} $ValidatorConfig_remove_operator_$def(account: $Value)
{
  var sender: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Mutation;
  var $t7: $Mutation;
  var $t8: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 3855, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    call $t3 := $Signer_address_of($t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t3);
    sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 3939, 1, $tmp);
    }

    call $t4 := $Option_none($AddressType());
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t6 := $BorrowGlobal($ValidatorConfig_ValidatorConfig_$memory, sender, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(28, 4022, $abort_code);
        goto Abort;
    }

    call $ValidatorConfig_ValidatorConfig_before_update_inv($Dereference($t6));
    call $t7 := $BorrowField($t6, $ValidatorConfig_ValidatorConfig_operator_account);
    call $ValidatorConfig_ValidatorConfig_$memory := $WritebackToGlobal($ValidatorConfig_ValidatorConfig_$memory, $t6);
    call $Option_Option_before_update_inv($AddressType(), $Dereference($t7));
    call $t7 := $WriteRef($t7, $t4);
    call $ValidatorConfig_ValidatorConfig_$memory := $WritebackToGlobal($ValidatorConfig_ValidatorConfig_$memory, $t7);
    call $t6 := $WritebackToReference($t7, $t6);
    call $ValidatorConfig_ValidatorConfig_after_update_inv($Dereference($t6));
    call $Option_Option_after_update_inv($AddressType(), $Dereference($t7));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $ValidatorConfig_remove_operator_$direct_inter(account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean(!b#$Boolean($ValidatorConfig_spec_has_operator($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account)), $Signer_spec_address_of(account))));



implementation {:inline 1} $ValidatorConfig_remove_operator_$direct_inter(account: $Value)
{
    assume is#$Address(account);
    call $ValidatorConfig_remove_operator_$def(account);
}



procedure {:inline 1} $ValidatorConfig_remove_operator_$direct_intra(account: $Value);



implementation {:inline 1} $ValidatorConfig_remove_operator_$direct_intra(account: $Value)
{
    assume is#$Address(account);
    call $ValidatorConfig_remove_operator_$def(account);
}



procedure {:inline 1} $ValidatorConfig_remove_operator(account: $Value);



implementation {:inline 1} $ValidatorConfig_remove_operator(account: $Value)
{
    assume is#$Address(account);
    call $ValidatorConfig_remove_operator_$def(account);
}



procedure {:inline 1} $ValidatorConfig_set_config_$def(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value);



implementation {:inline 1} $ValidatorConfig_set_config_$def(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value)
{
  var t_ref: $Mutation;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Mutation;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Mutation;
  var $t33: $Mutation;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 4826, 0, signer);
    }

    if (true)
    {
        assume $DebugTrackLocal(28, 4826, 1, validator_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(28, 4826, 2, consensus_pubkey);
    }

    if (true)
    {
        assume $DebugTrackLocal(28, 4826, 3, validator_network_identity_pubkey);
    }

    if (true)
    {
        assume $DebugTrackLocal(28, 4826, 4, validator_network_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(28, 4826, 5, full_node_network_identity_pubkey);
    }

    if (true)
    {
        assume $DebugTrackLocal(28, 4826, 6, full_node_network_address);
    }

    call $tmp := $CopyOrMoveValue(signer);
    $t34 := $tmp;
    call $tmp := $CopyOrMoveValue(validator_account);
    $t35 := $tmp;
    call $tmp := $CopyOrMoveValue(consensus_pubkey);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue(validator_network_identity_pubkey);
    $t37 := $tmp;
    call $tmp := $CopyOrMoveValue(validator_network_address);
    $t38 := $tmp;
    call $tmp := $CopyOrMoveValue(full_node_network_identity_pubkey);
    $t39 := $tmp;
    call $tmp := $CopyOrMoveValue(full_node_network_address);
    $t40 := $tmp;
    call $tmp := $CopyOrMoveValue($t34);
    $t12 := $tmp;
    call $t13 := $Signer_address_of($t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $ValidatorConfig_get_operator($t35);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t13, $t15));
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 5193, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(1);
    $t18 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(28, 5193, i#$Integer($t18));
    }

    $abort_code := i#$Integer($t18);
    goto Abort;

  L0:
    call $t20 := $Signature_ed25519_validate_pubkey($t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t20);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 5335, 10, $tmp);
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(3);
    $t22 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(28, 5335, i#$Integer($t22));
    }

    $abort_code := i#$Integer($t22);
    goto Abort;

  L2:
    call $t24 := $BorrowGlobal($ValidatorConfig_ValidatorConfig_$memory, $t35, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(28, 5524, $abort_code);
        goto Abort;
    }

    call $ValidatorConfig_ValidatorConfig_before_update_inv($Dereference($t24));
    call t_ref := $CopyOrMoveRef($t24);
    if (true)
    {
        assume $DebugTrackLocal(28, 5516, 7, $Dereference(t_ref));
    }

    call $tmp := $ValidatorConfig_Config_pack(0, 0, 0, $t36, $t37, $t38, $t39, $t40);
    $t30 := $tmp;
    call $t31 := $Option_some($ValidatorConfig_Config_type_value(), $t30);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t32 := $CopyOrMoveRef(t_ref);
    call $t33 := $BorrowField($t32, $ValidatorConfig_ValidatorConfig_config);
    call $ValidatorConfig_ValidatorConfig_$memory := $WritebackToGlobal($ValidatorConfig_ValidatorConfig_$memory, $t32);
    call $Option_Option_before_update_inv($ValidatorConfig_Config_type_value(), $Dereference($t33));
    call $t33 := $WriteRef($t33, $t31);
    if (true)
    {
        assume $DebugTrackLocal(28, 5587, 7, $Dereference(t_ref));
    }

    call $ValidatorConfig_ValidatorConfig_$memory := $WritebackToGlobal($ValidatorConfig_ValidatorConfig_$memory, $t33);
    call $t32 := $WritebackToReference($t33, $t32);
    call $ValidatorConfig_ValidatorConfig_after_update_inv($Dereference($t32));
    call $Option_Option_after_update_inv($ValidatorConfig_Config_type_value(), $Dereference($t33));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $ValidatorConfig_set_config_$direct_inter(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value);
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(signer), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_account))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_account))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Signature_spec_ed25519_validate_pubkey(consensus_pubkey))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(signer), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_account))))) || b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_account))))) || b#$Boolean(old($Boolean(!b#$Boolean($Signature_spec_ed25519_validate_pubkey(consensus_pubkey)))));
  ensures !$abort_flag ==> b#$Boolean($ValidatorConfig_spec_has_config($ValidatorConfig_ValidatorConfig_$memory, validator_account));



implementation {:inline 1} $ValidatorConfig_set_config_$direct_inter(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value)
{
    assume is#$Address(signer);
    assume is#$Address(validator_account);
    assume $Vector_is_well_formed(consensus_pubkey) && (forall $$0: int :: {:qid "quantifier779"} { $select_vector(consensus_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey, $$0)));
    assume $Vector_is_well_formed(validator_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier780"} { $select_vector(validator_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_identity_pubkey) ==> $IsValidU8($select_vector(validator_network_identity_pubkey, $$0)));
    assume $Vector_is_well_formed(validator_network_address) && (forall $$0: int :: {:qid "quantifier781"} { $select_vector(validator_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_address) ==> $IsValidU8($select_vector(validator_network_address, $$0)));
    assume $Vector_is_well_formed(full_node_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier782"} { $select_vector(full_node_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_identity_pubkey) ==> $IsValidU8($select_vector(full_node_network_identity_pubkey, $$0)));
    assume $Vector_is_well_formed(full_node_network_address) && (forall $$0: int :: {:qid "quantifier783"} { $select_vector(full_node_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_address) ==> $IsValidU8($select_vector(full_node_network_address, $$0)));
    call $ValidatorConfig_set_config_$def(signer, validator_account, consensus_pubkey, validator_network_identity_pubkey, validator_network_address, full_node_network_identity_pubkey, full_node_network_address);
}



procedure {:inline 1} $ValidatorConfig_set_config_$direct_intra(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value);



implementation {:inline 1} $ValidatorConfig_set_config_$direct_intra(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value)
{
    assume is#$Address(signer);
    assume is#$Address(validator_account);
    assume $Vector_is_well_formed(consensus_pubkey) && (forall $$0: int :: {:qid "quantifier784"} { $select_vector(consensus_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey, $$0)));
    assume $Vector_is_well_formed(validator_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier785"} { $select_vector(validator_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_identity_pubkey) ==> $IsValidU8($select_vector(validator_network_identity_pubkey, $$0)));
    assume $Vector_is_well_formed(validator_network_address) && (forall $$0: int :: {:qid "quantifier786"} { $select_vector(validator_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_address) ==> $IsValidU8($select_vector(validator_network_address, $$0)));
    assume $Vector_is_well_formed(full_node_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier787"} { $select_vector(full_node_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_identity_pubkey) ==> $IsValidU8($select_vector(full_node_network_identity_pubkey, $$0)));
    assume $Vector_is_well_formed(full_node_network_address) && (forall $$0: int :: {:qid "quantifier788"} { $select_vector(full_node_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_address) ==> $IsValidU8($select_vector(full_node_network_address, $$0)));
    call $ValidatorConfig_set_config_$def(signer, validator_account, consensus_pubkey, validator_network_identity_pubkey, validator_network_address, full_node_network_identity_pubkey, full_node_network_address);
}



procedure {:inline 1} $ValidatorConfig_set_config(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value);



implementation {:inline 1} $ValidatorConfig_set_config(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value)
{
    assume is#$Address(signer);
    assume is#$Address(validator_account);
    assume $Vector_is_well_formed(consensus_pubkey) && (forall $$0: int :: {:qid "quantifier789"} { $select_vector(consensus_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey, $$0)));
    assume $Vector_is_well_formed(validator_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier790"} { $select_vector(validator_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_identity_pubkey) ==> $IsValidU8($select_vector(validator_network_identity_pubkey, $$0)));
    assume $Vector_is_well_formed(validator_network_address) && (forall $$0: int :: {:qid "quantifier791"} { $select_vector(validator_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(validator_network_address) ==> $IsValidU8($select_vector(validator_network_address, $$0)));
    assume $Vector_is_well_formed(full_node_network_identity_pubkey) && (forall $$0: int :: {:qid "quantifier792"} { $select_vector(full_node_network_identity_pubkey, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_identity_pubkey) ==> $IsValidU8($select_vector(full_node_network_identity_pubkey, $$0)));
    assume $Vector_is_well_formed(full_node_network_address) && (forall $$0: int :: {:qid "quantifier793"} { $select_vector(full_node_network_address, $$0) } $$0 >= 0 && $$0 < $vlen(full_node_network_address) ==> $IsValidU8($select_vector(full_node_network_address, $$0)));
    call $ValidatorConfig_set_config_$def(signer, validator_account, consensus_pubkey, validator_network_identity_pubkey, validator_network_address, full_node_network_identity_pubkey, full_node_network_address);
}



procedure {:inline 1} $ValidatorConfig_set_operator_$def(account: $Value, operator_account: $Value);



implementation {:inline 1} $ValidatorConfig_set_operator_$def(account: $Value, operator_account: $Value)
{
  var sender: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Mutation;
  var $t9: $Mutation;
  var $t10: $Value;
  var $t11: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(28, 2425, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(28, 2425, 1, operator_account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue(operator_account);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t4);
    sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(28, 2533, 2, $tmp);
    }

    call $t6 := $Option_some($AddressType(), $t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t8 := $BorrowGlobal($ValidatorConfig_ValidatorConfig_$memory, sender, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(28, 2580, $abort_code);
        goto Abort;
    }

    call $ValidatorConfig_ValidatorConfig_before_update_inv($Dereference($t8));
    call $t9 := $BorrowField($t8, $ValidatorConfig_ValidatorConfig_operator_account);
    call $ValidatorConfig_ValidatorConfig_$memory := $WritebackToGlobal($ValidatorConfig_ValidatorConfig_$memory, $t8);
    call $Option_Option_before_update_inv($AddressType(), $Dereference($t9));
    call $t9 := $WriteRef($t9, $t6);
    call $ValidatorConfig_ValidatorConfig_$memory := $WritebackToGlobal($ValidatorConfig_ValidatorConfig_$memory, $t9);
    call $t8 := $WritebackToReference($t9, $t8);
    call $ValidatorConfig_ValidatorConfig_after_update_inv($Dereference($t8));
    call $Option_Option_after_update_inv($AddressType(), $Dereference($t9));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $ValidatorConfig_set_operator_$direct_inter(account: $Value, operator_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_spec_exists_config($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account))))));
  ensures !$abort_flag ==> b#$Boolean($ValidatorConfig_spec_has_operator($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account)));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, $Signer_spec_address_of(account)), operator_account)));



implementation {:inline 1} $ValidatorConfig_set_operator_$direct_inter(account: $Value, operator_account: $Value)
{
    assume is#$Address(account);
    assume is#$Address(operator_account);
    call $ValidatorConfig_set_operator_$def(account, operator_account);
}



procedure {:inline 1} $ValidatorConfig_set_operator_$direct_intra(account: $Value, operator_account: $Value);



implementation {:inline 1} $ValidatorConfig_set_operator_$direct_intra(account: $Value, operator_account: $Value)
{
    assume is#$Address(account);
    assume is#$Address(operator_account);
    call $ValidatorConfig_set_operator_$def(account, operator_account);
}



procedure {:inline 1} $ValidatorConfig_set_operator(account: $Value, operator_account: $Value);



implementation {:inline 1} $ValidatorConfig_set_operator(account: $Value, operator_account: $Value)
{
    assume is#$Address(account);
    assume is#$Address(operator_account);
    call $ValidatorConfig_set_operator_$def(account, operator_account);
}



function {:inline} $TransactionFee_spec_is_initialized($TransactionFee_TransactionFee_$memory: $Memory, $tv0: $TypeValue) : $Value
{
  $ResourceExists($TransactionFee_TransactionFee_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}

function {:inline} $TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory: $Memory, $tv0: $TypeValue) : $Value
{
  $SelectField($SelectField($ResourceValue($TransactionFee_TransactionFee_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()), $TransactionFee_TransactionFee_balance), $Libra_Libra_value)
}

function {:inline} $TransactionFee_spec_is_valid_txn_fee_currency($Libra_BurnCapability_$memory: $Memory, $Libra_CurrencyInfo_$memory: $Memory, $TransactionFee_TransactionFee_$memory: $Memory, $tv0: $TypeValue, tc_account: $Value) : $Value
{
  $Boolean(b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($TransactionFee_spec_is_initialized($TransactionFee_TransactionFee_$memory, $tv0)))) && b#$Boolean($Libra_spec_has_burn_cap($Libra_BurnCapability_$memory, $tv0, $Signer_spec_address_of(tc_account))))
}

const unique $TransactionFee_TransactionFee: $TypeName;

const $TransactionFee_TransactionFee_balance: $FieldName;

axiom $TransactionFee_TransactionFee_balance == 0;

const $TransactionFee_TransactionFee_preburn: $FieldName;

axiom $TransactionFee_TransactionFee_preburn == 1;

function $TransactionFee_TransactionFee_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier794"} { $TransactionFee_TransactionFee_type_value($tv0): $TypeValue } $TransactionFee_TransactionFee_type_value($tv0): $TypeValue == $StructType($TransactionFee_TransactionFee, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $TransactionFee_TransactionFee_$memory: $Memory;

var $TransactionFee_TransactionFee_$memory_$old: $Memory;

function {:inline} $TransactionFee_TransactionFee_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $Libra_Libra_is_well_formed_types($SelectField($this, $TransactionFee_TransactionFee_balance)) && $Libra_Preburn_is_well_formed_types($SelectField($this, $TransactionFee_TransactionFee_preburn))
}

function {:inline} $TransactionFee_TransactionFee_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $Libra_Libra_is_well_formed($SelectField($this, $TransactionFee_TransactionFee_balance)) && $Libra_Preburn_is_well_formed($SelectField($this, $TransactionFee_TransactionFee_preburn))
}

procedure {:inline 1} $TransactionFee_TransactionFee_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, balance: $Value, preburn: $Value) returns ($struct: $Value);



implementation {:inline 1} $TransactionFee_TransactionFee_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, balance: $Value, preburn: $Value) returns ($struct: $Value)
{
    assume $Libra_Libra_is_well_formed(balance);
    assume $Libra_Preburn_is_well_formed(preburn);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := balance][1 := preburn], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $TransactionFee_TransactionFee_unpack($tv0: $TypeValue, $struct: $Value) returns (balance: $Value, preburn: $Value);



implementation {:inline 1} $TransactionFee_TransactionFee_unpack($tv0: $TypeValue, $struct: $Value) returns (balance: $Value, preburn: $Value)
{
    assume is#$Vector($struct);
    balance := $SelectField($struct, $TransactionFee_TransactionFee_balance);
    assume $Libra_Libra_is_well_formed(balance);
    preburn := $SelectField($struct, $TransactionFee_TransactionFee_preburn);
    assume $Libra_Preburn_is_well_formed(preburn);
}



procedure {:inline 1} $TransactionFee_initialize_$def(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $TransactionFee_initialize_$def(lr_account: $Value, tc_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(26, 841, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(26, 841, 1, tc_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t34 := $tmp;
    call $t8 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 938, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t34);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t33);
    $t11 := $tmp;
    $tmp := $Integer(0);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(26, 938, i#$Integer($t12));
    }

    $abort_code := i#$Integer($t12);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t33);
    $t13 := $tmp;
    call $t14 := $Signer_address_of($t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t14, $t15));
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 998, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t34);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t33);
    $t19 := $tmp;
    $tmp := $Integer(2);
    $t20 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(26, 998, i#$Integer($t20));
    }

    $abort_code := i#$Integer($t20);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t34);
    $t21 := $tmp;
    call $t22 := $Roles_has_treasury_compliance_role($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t22);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 1147, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $tmp := $CopyOrMoveValue($t34);
    $t24 := $tmp;
    call $tmp := $CopyOrMoveValue($t33);
    $t25 := $tmp;
    $tmp := $Integer(1);
    $t26 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(26, 1147, i#$Integer($t26));
    }

    $abort_code := i#$Integer($t26);
    goto Abort;

  L4:
    call $tmp := $CopyOrMoveValue($t33);
    $t27 := $tmp;
    call $tmp := $CopyOrMoveValue($t34);
    $t28 := $tmp;
    call $TransactionFee_add_txn_fee_currency($Coin1_Coin1_type_value(), $t27, $t28);
    assume $abort_flag == false;
    call $tmp := $CopyOrMoveValue($t33);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue($t34);
    $t30 := $tmp;
    call $TransactionFee_add_txn_fee_currency($Coin2_Coin2_type_value(), $t29, $t30);
    assume $abort_flag == false;
    call $tmp := $CopyOrMoveValue($t33);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t34);
    $t32 := $tmp;
    call $TransactionFee_add_txn_fee_currency($LBR_LBR_type_value(), $t31, $t32);
    assume $abort_flag == false;
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $TransactionFee_initialize_$direct_inter(lr_account: $Value, tc_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($LibraTimestamp_TimeHasStarted_$memory))))) || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) || b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(tc_account))))));
  ensures !$abort_flag ==> b#$Boolean($TransactionFee_spec_is_initialized($TransactionFee_TransactionFee_$memory, $LBR_LBR_type_value()));
  ensures !$abort_flag ==> b#$Boolean($TransactionFee_spec_is_initialized($TransactionFee_TransactionFee_$memory, $Coin1_Coin1_type_value()));
  ensures !$abort_flag ==> b#$Boolean($TransactionFee_spec_is_initialized($TransactionFee_TransactionFee_$memory, $Coin2_Coin2_type_value()));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory, $LBR_LBR_type_value()), $Integer(0))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory, $Coin1_Coin1_type_value()), $Integer(0))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory, $Coin2_Coin2_type_value()), $Integer(0))));



implementation {:inline 1} $TransactionFee_initialize_$direct_inter(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $TransactionFee_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $TransactionFee_initialize_$direct_intra(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $TransactionFee_initialize_$direct_intra(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $TransactionFee_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $TransactionFee_initialize(lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $TransactionFee_initialize(lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $TransactionFee_initialize_$def(lr_account, tc_account);
}



procedure {:inline 1} $TransactionFee_add_txn_fee_currency_$def($tv0: $TypeValue, lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $TransactionFee_add_txn_fee_currency_$def($tv0: $TypeValue, lr_account: $Value, tc_account: $Value)
{
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(26, 2815, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(26, 2815, 1, tc_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue(tc_account);
    $t8 := $tmp;
    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    call $t3 := $Libra_zero($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t4 := $tmp;
    call $t5 := $Libra_create_preburn($tv0, $t4);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $TransactionFee_TransactionFee_pack(0, 0, 0, $tv0, $t3, $t5);
    $t6 := $tmp;
    call $TransactionFee_TransactionFee_$memory := $MoveTo($TransactionFee_TransactionFee_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t6, $t2);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(26, 2925, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $TransactionFee_add_txn_fee_currency_$direct_intra($tv0: $TypeValue, lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $TransactionFee_add_txn_fee_currency_$direct_intra($tv0: $TypeValue, lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $TransactionFee_add_txn_fee_currency_$def($tv0, lr_account, tc_account);
}



procedure {:inline 1} $TransactionFee_add_txn_fee_currency($tv0: $TypeValue, lr_account: $Value, tc_account: $Value);



implementation {:inline 1} $TransactionFee_add_txn_fee_currency($tv0: $TypeValue, lr_account: $Value, tc_account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(tc_account);
    call $TransactionFee_add_txn_fee_currency_$def($tv0, lr_account, tc_account);
}



procedure {:inline 1} $TransactionFee_burn_fees_$def($tv0: $TypeValue, tc_account: $Value);



implementation {:inline 1} $TransactionFee_burn_fees_$def($tv0: $TypeValue, tc_account: $Value)
{
  var burn_cap: $Value;
  var coin: $Value;
  var coin1: $Value;
  var coin1_burn_cap: $Value;
  var coin2: $Value;
  var coin2_burn_cap: $Value;
  var coins: $Value;
  var fee_address: $Value;
  var fees: $Mutation;
  var fees#1653: $Mutation;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Mutation;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Mutation;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Mutation;
  var $t41: $Mutation;
  var $t42: $Mutation;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Mutation;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $t56: $Value;
  var $t57: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(26, 4429, 0, tc_account);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t52 := $tmp;
    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    fee_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 4534, 8, $tmp);
    }

    call $t12 := $LBR_is_lbr($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t12;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t14 := $BorrowGlobal($TransactionFee_TransactionFee_$memory, fee_address, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(26, 4676, $abort_code);
        goto Abort;
    }

    call fees := $CopyOrMoveRef($t14);
    if (true)
    {
        assume $DebugTrackLocal(26, 4669, 9, $Dereference(fees));
    }

    call $t15 := $CopyOrMoveRef(fees);
    call $t16 := $BorrowField($t15, $TransactionFee_TransactionFee_balance);
    call $TransactionFee_TransactionFee_$memory := $WritebackToGlobal($TransactionFee_TransactionFee_$memory, $t15);
    call $tmp := $ReadRef($t16);
    $t53 := $tmp;
    call $t17, $t53 := $Libra_withdraw_all($LBR_LBR_type_value(), $t53);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t16 := $WriteRef($t16, $t53);
    if (true)
    {
        assume $DebugTrackLocal(26, 5885, 9, $Dereference(fees));
    }

    if (true)
    {
        assume $DebugTrackLocal(26, 5885, 10, $Dereference(fees#1653));
    }

    call $TransactionFee_TransactionFee_$memory := $WritebackToGlobal($TransactionFee_TransactionFee_$memory, $t16);
    call $t15 := $WritebackToReference($t16, $t15);
    call $tmp := $CopyOrMoveValue($t17);
    coins := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 4745, 7, $tmp);
    }

    call $t19, $t20 := $LBR_unpack(coins);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t20);
    coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 4822, 5, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t19);
    coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 4815, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t52);
    $t21 := $tmp;
    call $t22 := $Libra_remove_burn_capability($Coin1_Coin1_type_value(), $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t22);
    coin1_burn_cap := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 4887, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t52);
    $t23 := $tmp;
    call $t24 := $Libra_remove_burn_capability($Coin2_Coin2_type_value(), $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t24);
    coin2_burn_cap := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 4970, 6, $tmp);
    }

    call $tmp := $CopyOrMoveValue(coin1_burn_cap);
    $t25 := $tmp;
    call $t27 := $BorrowGlobal($TransactionFee_TransactionFee_$memory, fee_address, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(26, 5117, $abort_code);
        goto Abort;
    }

    call $tmp := $ReadRef($t27);
    $t55 := $tmp;
    call $t55 := $TransactionFee_preburn_burn_fees($Coin1_Coin1_type_value(), $t25, $t55, coin1);
    assume $abort_flag == false;
    call $t27 := $WriteRef($t27, $t55);
    if (true)
    {
        assume $DebugTrackLocal(26, 5935, 9, $Dereference(fees));
    }

    if (true)
    {
        assume $DebugTrackLocal(26, 5935, 10, $Dereference(fees#1653));
    }

    call $TransactionFee_TransactionFee_$memory := $WritebackToGlobal($TransactionFee_TransactionFee_$memory, $t27);
    call $tmp := $CopyOrMoveValue(coin2_burn_cap);
    $t29 := $tmp;
    call $t31 := $BorrowGlobal($TransactionFee_TransactionFee_$memory, fee_address, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin2_Coin2_type_value()], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(26, 5289, $abort_code);
        goto Abort;
    }

    call $tmp := $ReadRef($t31);
    $t56 := $tmp;
    call $t56 := $TransactionFee_preburn_burn_fees($Coin2_Coin2_type_value(), $t29, $t56, coin2);
    assume $abort_flag == false;
    call $t31 := $WriteRef($t31, $t56);
    if (true)
    {
        assume $DebugTrackLocal(26, 5957, 9, $Dereference(fees));
    }

    if (true)
    {
        assume $DebugTrackLocal(26, 5957, 10, $Dereference(fees#1653));
    }

    call $TransactionFee_TransactionFee_$memory := $WritebackToGlobal($TransactionFee_TransactionFee_$memory, $t31);
    call $tmp := $CopyOrMoveValue($t52);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue($t52);
    $t35 := $tmp;
    call $Libra_publish_burn_capability($Coin1_Coin1_type_value(), $t33, coin1_burn_cap, $t35);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t52);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue($t52);
    $t38 := $tmp;
    call $Libra_publish_burn_capability($Coin2_Coin2_type_value(), $t36, coin2_burn_cap, $t38);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L3;

  L2:
    call $t40 := $BorrowGlobal($TransactionFee_TransactionFee_$memory, fee_address, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(26, 5617, $abort_code);
        goto Abort;
    }

    call fees#1653 := $CopyOrMoveRef($t40);
    if (true)
    {
        assume $DebugTrackLocal(26, 5610, 10, $Dereference(fees#1653));
    }

    call $t41 := $CopyOrMoveRef(fees#1653);
    call $t42 := $BorrowField($t41, $TransactionFee_TransactionFee_balance);
    call fees#1653 := $WritebackToReference($t41, fees#1653);
    call $tmp := $ReadRef($t42);
    $t54 := $tmp;
    call $t43, $t54 := $Libra_withdraw_all($tv0, $t54);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t42 := $WriteRef($t42, $t54);
    if (true)
    {
        assume $DebugTrackLocal(26, 4594, 9, $Dereference(fees));
    }

    if (true)
    {
        assume $DebugTrackLocal(26, 4594, 10, $Dereference(fees#1653));
    }

    call fees#1653 := $WritebackToReference($t42, fees#1653);
    call $t41 := $WritebackToReference($t42, $t41);
    call $tmp := $CopyOrMoveValue($t43);
    coin := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 5691, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t52);
    $t44 := $tmp;
    call $t45 := $Libra_remove_burn_capability($tv0, $t44);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t45);
    burn_cap := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 5774, 1, $tmp);
    }

    call $tmp := $CopyOrMoveValue(burn_cap);
    $t46 := $tmp;
    call $t47 := $CopyOrMoveRef(fees#1653);
    call $tmp := $ReadRef($t47);
    $t57 := $tmp;
    call $t57 := $TransactionFee_preburn_burn_fees($tv0, $t46, $t57, coin);
    assume $abort_flag == false;
    call $t47 := $WriteRef($t47, $t57);
    if (true)
    {
        assume $DebugTrackLocal(26, 4429, 9, $Dereference(fees));
    }

    if (true)
    {
        assume $DebugTrackLocal(26, 4429, 10, $Dereference(fees#1653));
    }

    call $TransactionFee_TransactionFee_$memory := $WritebackToGlobal($TransactionFee_TransactionFee_$memory, $t47);
    call $tmp := $CopyOrMoveValue($t52);
    $t49 := $tmp;
    call $tmp := $CopyOrMoveValue($t52);
    $t51 := $tmp;
    call $Libra_publish_burn_capability($tv0, $t49, burn_cap, $t51);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L3;

  L3:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $TransactionFee_burn_fees_$direct_inter($tv0: $TypeValue, tc_account: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($TransactionFee_spec_is_initialized($TransactionFee_TransactionFee_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LBR_spec_is_lbr($tv0)) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($TransactionFee_spec_is_valid_txn_fee_currency($Libra_BurnCapability_$memory, $Libra_CurrencyInfo_$memory, $TransactionFee_TransactionFee_$memory, $Coin1_Coin1_type_value(), tc_account)))) || b#$Boolean($Boolean(!b#$Boolean($TransactionFee_spec_is_valid_txn_fee_currency($Libra_BurnCapability_$memory, $Libra_CurrencyInfo_$memory, $TransactionFee_TransactionFee_$memory, $Coin2_Coin2_type_value(), tc_account))))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($LBR_spec_is_lbr($tv0)))) && b#$Boolean($Boolean(!b#$Boolean($TransactionFee_spec_is_valid_txn_fee_currency($Libra_BurnCapability_$memory, $Libra_CurrencyInfo_$memory, $TransactionFee_TransactionFee_$memory, $tv0, tc_account))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($TransactionFee_spec_is_initialized($TransactionFee_TransactionFee_$memory, $tv0))))) || b#$Boolean(old($Boolean(b#$Boolean($LBR_spec_is_lbr($tv0)) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($TransactionFee_spec_is_valid_txn_fee_currency($Libra_BurnCapability_$memory, $Libra_CurrencyInfo_$memory, $TransactionFee_TransactionFee_$memory, $Coin1_Coin1_type_value(), tc_account)))) || b#$Boolean($Boolean(!b#$Boolean($TransactionFee_spec_is_valid_txn_fee_currency($Libra_BurnCapability_$memory, $Libra_CurrencyInfo_$memory, $TransactionFee_TransactionFee_$memory, $Coin2_Coin2_type_value(), tc_account))))))))) || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($LBR_spec_is_lbr($tv0)))) && b#$Boolean($Boolean(!b#$Boolean($TransactionFee_spec_is_valid_txn_fee_currency($Libra_BurnCapability_$memory, $Libra_CurrencyInfo_$memory, $TransactionFee_TransactionFee_$memory, $tv0, tc_account))))))) || b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, $Signer_spec_address_of(tc_account))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0), $Integer(i#$Integer(old($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0))) - i#$Integer(old($TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory, $tv0)))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory, $tv0), $Integer(0))));



implementation {:inline 1} $TransactionFee_burn_fees_$direct_inter($tv0: $TypeValue, tc_account: $Value)
{
    assume is#$Address(tc_account);
    call $TransactionFee_burn_fees_$def($tv0, tc_account);
}



procedure {:inline 1} $TransactionFee_burn_fees_$direct_intra($tv0: $TypeValue, tc_account: $Value);



implementation {:inline 1} $TransactionFee_burn_fees_$direct_intra($tv0: $TypeValue, tc_account: $Value)
{
    assume is#$Address(tc_account);
    call $TransactionFee_burn_fees_$def($tv0, tc_account);
}



procedure {:inline 1} $TransactionFee_burn_fees($tv0: $TypeValue, tc_account: $Value);



implementation {:inline 1} $TransactionFee_burn_fees($tv0: $TypeValue, tc_account: $Value)
{
    assume is#$Address(tc_account);
    call $TransactionFee_burn_fees_$def($tv0, tc_account);
}



procedure {:inline 1} $TransactionFee_pay_fee_$def($tv0: $TypeValue, coin: $Value);



implementation {:inline 1} $TransactionFee_pay_fee_$def($tv0: $TypeValue, coin: $Value)
{
  var fees: $Mutation;
  var $t2: $Value;
  var $t3: $Mutation;
  var $t4: $Mutation;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(26, 3733, 0, coin);
    }

    call $tmp := $CopyOrMoveValue(coin);
    $t7 := $tmp;
    call $t2 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t3 := $BorrowGlobal($TransactionFee_TransactionFee_$memory, $t2, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(26, 3830, $abort_code);
        goto Abort;
    }

    call fees := $CopyOrMoveRef($t3);
    if (true)
    {
        assume $DebugTrackLocal(26, 3823, 1, $Dereference(fees));
    }

    call $t4 := $CopyOrMoveRef(fees);
    call $t5 := $BorrowField($t4, $TransactionFee_TransactionFee_balance);
    call $TransactionFee_TransactionFee_$memory := $WritebackToGlobal($TransactionFee_TransactionFee_$memory, $t4);
    call $tmp := $ReadRef($t5);
    $t8 := $tmp;
    call $t8 := $Libra_deposit($tv0, $t8, $t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t5 := $WriteRef($t5, $t8);
    if (true)
    {
        assume $DebugTrackLocal(26, 3733, 1, $Dereference(fees));
    }

    call $TransactionFee_TransactionFee_$memory := $WritebackToGlobal($TransactionFee_TransactionFee_$memory, $t5);
    call $t4 := $WritebackToReference($t5, $t4);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $TransactionFee_pay_fee_$direct_inter($tv0: $TypeValue, coin: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($TransactionFee_spec_is_initialized($TransactionFee_TransactionFee_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory, $tv0)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($TransactionFee_spec_is_initialized($TransactionFee_TransactionFee_$memory, $tv0))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory, $tv0)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory, $tv0), $Integer(i#$Integer(old($TransactionFee_spec_txn_fee_balance($TransactionFee_TransactionFee_$memory, $tv0))) + i#$Integer($SelectField(coin, $Libra_Libra_value))))));



implementation {:inline 1} $TransactionFee_pay_fee_$direct_inter($tv0: $TypeValue, coin: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $TransactionFee_pay_fee_$def($tv0, coin);
}



procedure {:inline 1} $TransactionFee_pay_fee_$direct_intra($tv0: $TypeValue, coin: $Value);



implementation {:inline 1} $TransactionFee_pay_fee_$direct_intra($tv0: $TypeValue, coin: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $TransactionFee_pay_fee_$def($tv0, coin);
}



procedure {:inline 1} $TransactionFee_pay_fee($tv0: $TypeValue, coin: $Value);



implementation {:inline 1} $TransactionFee_pay_fee($tv0: $TypeValue, coin: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    call $TransactionFee_pay_fee_$def($tv0, coin);
}



procedure {:inline 1} $TransactionFee_preburn_burn_fees_$def($tv0: $TypeValue, burn_cap: $Value, fees: $Value, coin: $Value) returns ($ret0: $Value);



implementation {:inline 1} $TransactionFee_preburn_burn_fees_$def($tv0: $TypeValue, burn_cap: $Value, fees: $Value, coin: $Value) returns ($ret0: $Value)
{
  var preburn: $Mutation;
  var tc_address: $Value;
  var $t5: $Value;
  var $t6: $Mutation;
  var $t7: $Mutation;
  var $t8: $Value;
  var $t9: $Mutation;
  var $t10: $Value;
  var $t11: $Mutation;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(26, 7645, 0, burn_cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(26, 7645, 1, fees);
    }

    if (true)
    {
        assume $DebugTrackLocal(26, 7645, 2, coin);
    }

    call $tmp := $CopyOrMoveValue(burn_cap);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue(fees);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(coin);
    $t17 := $tmp;
    call $t16 := $BorrowLoc(15, $t15);
    call $t5 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    tc_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(26, 7818, 4, $tmp);
    }

    call $t6 := $CopyOrMoveRef($t16);
    call $t7 := $BorrowField($t6, $TransactionFee_TransactionFee_preburn);
    call $t15 := $WritebackToValue($t6, 15, $t15);
    call preburn := $CopyOrMoveRef($t7);
    if (true)
    {
        assume $DebugTrackLocal(26, 7889, 3, $Dereference(preburn));
    }

    call $t9 := $CopyOrMoveRef(preburn);
    call $tmp := $ReadRef($t9);
    $t18 := $tmp;
    call $t18 := $Libra_preburn_with_resource($tv0, $t17, $t18, tc_address);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t9 := $WriteRef($t9, $t18);
    if (true)
    {
        assume $DebugTrackLocal(26, 7645, 3, $Dereference(preburn));
    }

    call preburn := $WritebackToReference($t9, preburn);
    call $t11 := $CopyOrMoveRef(preburn);
    call $tmp := $CopyOrMoveValue($t14);
    $t13 := $tmp;
    call $tmp := $ReadRef($t11);
    $t18 := $tmp;
    call $t18 := $Libra_burn_with_resource_cap($tv0, $t18, tc_address, $t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $WriteRef($t11, $t18);
    if (true)
    {
        assume $DebugTrackLocal(26, 7645, 3, $Dereference(preburn));
    }

    call $t15 := $WritebackToValue($t11, 15, $t15);
    call $t6 := $WritebackToReference($t11, $t6);
    $ret0 := $t15;
    if (true)
    {
        assume $DebugTrackLocal(26, 7991, 19, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $TransactionFee_preburn_burn_fees_$direct_intra($tv0: $TypeValue, burn_cap: $Value, fees: $Value, coin: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($SelectField(fees, $TransactionFee_TransactionFee_preburn), $Libra_Preburn_to_burn), $Libra_Libra_value)) > i#$Integer($Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean($IsEqual($SelectField(coin, $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0)) < i#$Integer($SelectField(coin, $Libra_Libra_value))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) || b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($SelectField(fees, $TransactionFee_TransactionFee_preburn), $Libra_Preburn_to_burn), $Libra_Libra_value)) > i#$Integer($Integer(0))))) || b#$Boolean(old($Boolean($IsEqual($SelectField(coin, $Libra_Libra_value), $Integer(0))))) || b#$Boolean(old($Boolean(i#$Integer($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0)) < i#$Integer($SelectField(coin, $Libra_Libra_value)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0), $Integer(i#$Integer(old($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0))) - i#$Integer($SelectField(coin, $Libra_Libra_value))))));
  ensures $TransactionFee_TransactionFee_is_well_formed($ret0);



procedure {:inline 1} $TransactionFee_preburn_burn_fees($tv0: $TypeValue, burn_cap: $Value, fees: $Value, coin: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($SelectField(fees, $TransactionFee_TransactionFee_preburn), $Libra_Preburn_to_burn), $Libra_Libra_value)) > i#$Integer($Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean($IsEqual($SelectField(coin, $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0)) < i#$Integer($SelectField(coin, $Libra_Libra_value))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) || b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($SelectField(fees, $TransactionFee_TransactionFee_preburn), $Libra_Preburn_to_burn), $Libra_Libra_value)) > i#$Integer($Integer(0))))) || b#$Boolean(old($Boolean($IsEqual($SelectField(coin, $Libra_Libra_value), $Integer(0))))) || b#$Boolean(old($Boolean(i#$Integer($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0)) < i#$Integer($SelectField(coin, $Libra_Libra_value)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0), $Integer(i#$Integer(old($Libra_spec_market_cap($Libra_CurrencyInfo_$memory, $tv0))) - i#$Integer($SelectField(coin, $Libra_Libra_value))))));
  ensures $TransactionFee_TransactionFee_is_well_formed($ret0);



const unique $SlidingNonce_SlidingNonce: $TypeName;

const $SlidingNonce_SlidingNonce_min_nonce: $FieldName;

axiom $SlidingNonce_SlidingNonce_min_nonce == 0;

const $SlidingNonce_SlidingNonce_nonce_mask: $FieldName;

axiom $SlidingNonce_SlidingNonce_nonce_mask == 1;

function $SlidingNonce_SlidingNonce_type_value() : $TypeValue;

axiom $SlidingNonce_SlidingNonce_type_value(): $TypeValue == $StructType($SlidingNonce_SlidingNonce, $EmptyTypeValueArray);

var $SlidingNonce_SlidingNonce_$memory: $Memory;

var $SlidingNonce_SlidingNonce_$memory_$old: $Memory;

function {:inline} $SlidingNonce_SlidingNonce_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $IsValidU64($SelectField($this, $SlidingNonce_SlidingNonce_min_nonce)) && $IsValidU128($SelectField($this, $SlidingNonce_SlidingNonce_nonce_mask))
}

function {:inline} $SlidingNonce_SlidingNonce_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 2 && $IsValidU64($SelectField($this, $SlidingNonce_SlidingNonce_min_nonce)) && $IsValidU128($SelectField($this, $SlidingNonce_SlidingNonce_nonce_mask))
}

procedure {:inline 1} $SlidingNonce_SlidingNonce_pack($file_id: int, $byte_index: int, $var_idx: int, min_nonce: $Value, nonce_mask: $Value) returns ($struct: $Value);



implementation {:inline 1} $SlidingNonce_SlidingNonce_pack($file_id: int, $byte_index: int, $var_idx: int, min_nonce: $Value, nonce_mask: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(min_nonce);
    assume $IsValidU128(nonce_mask);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := min_nonce][1 := nonce_mask], 2));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $SlidingNonce_SlidingNonce_unpack($struct: $Value) returns (min_nonce: $Value, nonce_mask: $Value);



implementation {:inline 1} $SlidingNonce_SlidingNonce_unpack($struct: $Value) returns (min_nonce: $Value, nonce_mask: $Value)
{
    assume is#$Vector($struct);
    min_nonce := $SelectField($struct, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64(min_nonce);
    nonce_mask := $SelectField($struct, $SlidingNonce_SlidingNonce_nonce_mask);
    assume $IsValidU128(nonce_mask);
}



procedure {:inline 1} $SlidingNonce_publish_$def(account: $Value);



implementation {:inline 1} $SlidingNonce_publish_$def(account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(25, 2987, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t5 := $tmp;
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    $tmp := $Integer(0);
    $t2 := $tmp;
    $tmp := $Integer(0);
    $t3 := $tmp;
    call $tmp := $SlidingNonce_SlidingNonce_pack(0, 0, 0, $t2, $t3);
    $t4 := $tmp;
    call $SlidingNonce_SlidingNonce_$memory := $MoveTo($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $t4, $t1);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 3034, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $SlidingNonce_publish_$direct_inter(account: $Value);



implementation {:inline 1} $SlidingNonce_publish_$direct_inter(account: $Value)
{
    assume is#$Address(account);
    call $SlidingNonce_publish_$def(account);
}



procedure {:inline 1} $SlidingNonce_publish_$direct_intra(account: $Value);



implementation {:inline 1} $SlidingNonce_publish_$direct_intra(account: $Value)
{
    assume is#$Address(account);
    call $SlidingNonce_publish_$def(account);
}



procedure {:inline 1} $SlidingNonce_publish(account: $Value);



implementation {:inline 1} $SlidingNonce_publish(account: $Value)
{
    assume is#$Address(account);
    call $SlidingNonce_publish_$def(account);
}



procedure {:inline 1} $SlidingNonce_publish_nonce_resource_$def(lr_account: $Value, account: $Value);



implementation {:inline 1} $SlidingNonce_publish_nonce_resource_$def(lr_account: $Value, account: $Value)
{
  var new_resource: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(25, 3249, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(25, 3249, 1, account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue(account);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    call $t6 := $Roles_has_libra_root_role($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(25, 3354, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t15);
    $t8 := $tmp;
    $tmp := $Integer(4);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(25, 3354, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t15);
    $t10 := $tmp;
    $tmp := $Integer(0);
    $t11 := $tmp;
    $tmp := $Integer(0);
    $t12 := $tmp;
    call $tmp := $SlidingNonce_SlidingNonce_pack(0, 0, 0, $t11, $t12);
    $t13 := $tmp;
    call $SlidingNonce_SlidingNonce_$memory := $MoveTo($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $t13, $t10);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 3533, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $SlidingNonce_publish_nonce_resource_$direct_inter(lr_account: $Value, account: $Value);



implementation {:inline 1} $SlidingNonce_publish_nonce_resource_$direct_inter(lr_account: $Value, account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(account);
    call $SlidingNonce_publish_nonce_resource_$def(lr_account, account);
}



procedure {:inline 1} $SlidingNonce_publish_nonce_resource_$direct_intra(lr_account: $Value, account: $Value);



implementation {:inline 1} $SlidingNonce_publish_nonce_resource_$direct_intra(lr_account: $Value, account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(account);
    call $SlidingNonce_publish_nonce_resource_$def(lr_account, account);
}



procedure {:inline 1} $SlidingNonce_publish_nonce_resource(lr_account: $Value, account: $Value);



implementation {:inline 1} $SlidingNonce_publish_nonce_resource(lr_account: $Value, account: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(account);
    call $SlidingNonce_publish_nonce_resource_$def(lr_account, account);
}



procedure {:inline 1} $SlidingNonce_record_nonce_or_abort_$def(account: $Value, seq_nonce: $Value);



implementation {:inline 1} $SlidingNonce_record_nonce_or_abort_$def(account: $Value, seq_nonce: $Value)
{
  var code: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(25, 1335, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(25, 1335, 1, seq_nonce);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue(seq_nonce);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    call $t7 := $SlidingNonce_try_record_nonce($t5, $t15);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    code := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(25, 1438, 2, $tmp);
    }

    $tmp := $Integer(0);
    $t9 := $tmp;
    $tmp := $Boolean($IsEqual(code, $t9));
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue(code);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(25, 1491, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(25, 1491, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    if (true)
    {
        assume $DebugTrackAbort(25, 1491, i#$Integer($t4));
    }

    $abort_code := i#$Integer($t4);
    goto Abort;

  L0:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $SlidingNonce_record_nonce_or_abort_$direct_inter(account: $Value, seq_nonce: $Value);



implementation {:inline 1} $SlidingNonce_record_nonce_or_abort_$direct_inter(account: $Value, seq_nonce: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(seq_nonce);
    call $SlidingNonce_record_nonce_or_abort_$def(account, seq_nonce);
}



procedure {:inline 1} $SlidingNonce_record_nonce_or_abort_$direct_intra(account: $Value, seq_nonce: $Value);



implementation {:inline 1} $SlidingNonce_record_nonce_or_abort_$direct_intra(account: $Value, seq_nonce: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(seq_nonce);
    call $SlidingNonce_record_nonce_or_abort_$def(account, seq_nonce);
}



procedure {:inline 1} $SlidingNonce_record_nonce_or_abort(account: $Value, seq_nonce: $Value);



implementation {:inline 1} $SlidingNonce_record_nonce_or_abort(account: $Value, seq_nonce: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(seq_nonce);
    call $SlidingNonce_record_nonce_or_abort_$def(account, seq_nonce);
}



procedure {:inline 1} $SlidingNonce_try_record_nonce_$def(account: $Value, seq_nonce: $Value) returns ($ret0: $Value);



implementation {:inline 1} $SlidingNonce_try_record_nonce_$def(account: $Value, seq_nonce: $Value) returns ($ret0: $Value)
{
  var bit_pos: $Value;
  var bit_pos#1652: $Value;
  var jump_limit: $Value;
  var set: $Value;
  var shift: $Value;
  var t: $Mutation;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Mutation;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Mutation;
  var $t22: $Value;
  var $t23: $Mutation;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Mutation;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Mutation;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Mutation;
  var $t50: $Mutation;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $t56: $Mutation;
  var $t57: $Mutation;
  var $t58: $Mutation;
  var $t59: $Value;
  var $t60: $Value;
  var $t61: $Value;
  var $t62: $Value;
  var $t63: $Value;
  var $t64: $Mutation;
  var $t65: $Mutation;
  var $t66: $Mutation;
  var $t67: $Value;
  var $t68: $Value;
  var $t69: $Value;
  var $t70: $Value;
  var $t71: $Mutation;
  var $t72: $Mutation;
  var $t73: $Value;
  var $t74: $Mutation;
  var $t75: $Value;
  var $t76: $Value;
  var $t77: $Value;
  var $t78: $Value;
  var $t79: $Value;
  var $t80: $Value;
  var $t81: $Value;
  var $t82: $Mutation;
  var $t83: $Value;
  var $t84: $Value;
  var $t85: $Value;
  var $t86: $Value;
  var $t87: $Value;
  var $t88: $Value;
  var $t89: $Mutation;
  var $t90: $Value;
  var $t91: $Mutation;
  var $t92: $Value;
  var $t93: $Value;
  var $t94: $Value;
  var $t95: $Value;
  var $t96: $Mutation;
  var $t97: $Mutation;
  var $t98: $Value;
  var $t99: $Value;
  var $t100: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(25, 1640, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(25, 1640, 1, seq_nonce);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t99 := $tmp;
    call $tmp := $CopyOrMoveValue(seq_nonce);
    $t100 := $tmp;
    $tmp := $Integer(0);
    $t9 := $tmp;
    $tmp := $Boolean($IsEqual($t100, $t9));
    $t10 := $tmp;
    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $tmp := $CopyOrMoveValue($t99);
    $t11 := $tmp;
    $tmp := $Integer(0);
    $t12 := $tmp;
    $ret0 := $t12;
    if (true)
    {
        assume $DebugTrackLocal(25, 1773, 101, $ret0);
    }

    return;

  L2:
    call $tmp := $CopyOrMoveValue($t99);
    $t13 := $tmp;
    call $t14 := $Signer_address_of($t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $BorrowGlobal($SlidingNonce_SlidingNonce_$memory, $t14, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 1809, $abort_code);
        goto Abort;
    }

    call t := $CopyOrMoveRef($t15);
    if (true)
    {
        assume $DebugTrackLocal(25, 1805, 7, $Dereference(t));
    }

    call $t16 := $CopyOrMoveRef(t);
    call $tmp := $GetFieldFromReference($t16, $SlidingNonce_SlidingNonce_min_nonce);
    $t17 := $tmp;
    call t := $WritebackToReference($t16, t);
    call $tmp := $CopyOrMoveValue($t17);
    $t18 := $tmp;
    call $tmp := $Gt($t18, $t100);
    $t20 := $tmp;
    $tmp := $t20;
    if (b#$Boolean($tmp))
    {
        goto L3;
    }
    else
    {
        goto L4;
    }

  L4:
    goto L5;

  L3:
    call $t21 := $CopyOrMoveRef(t);
    call $SlidingNonce_SlidingNonce_$memory := $WritebackToGlobal($SlidingNonce_SlidingNonce_$memory, $t21);
    $tmp := $Integer(1);
    $t22 := $tmp;
    $ret0 := $t22;
    if (true)
    {
        assume $DebugTrackLocal(25, 1922, 101, $ret0);
    }

    return;

  L5:
    call $t23 := $CopyOrMoveRef(t);
    call $tmp := $GetFieldFromReference($t23, $SlidingNonce_SlidingNonce_min_nonce);
    $t24 := $tmp;
    call t := $WritebackToReference($t23, t);
    call $tmp := $CopyOrMoveValue($t24);
    $t25 := $tmp;
    $tmp := $Integer(10000);
    $t26 := $tmp;
    call $tmp := $AddU64($t25, $t26);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2083, $abort_code);
        goto Abort;
    }

    $t27 := $tmp;
    call $tmp := $Le($t27, $t100);
    $t29 := $tmp;
    $tmp := $t29;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    call $t30 := $CopyOrMoveRef(t);
    call $SlidingNonce_SlidingNonce_$memory := $WritebackToGlobal($SlidingNonce_SlidingNonce_$memory, $t30);
    $tmp := $Integer(2);
    $t31 := $tmp;
    $ret0 := $t31;
    if (true)
    {
        assume $DebugTrackLocal(25, 2124, 101, $ret0);
    }

    return;

  L8:
    call $t33 := $CopyOrMoveRef(t);
    call $tmp := $GetFieldFromReference($t33, $SlidingNonce_SlidingNonce_min_nonce);
    $t34 := $tmp;
    call t := $WritebackToReference($t33, t);
    call $tmp := $CopyOrMoveValue($t34);
    $t35 := $tmp;
    call $tmp := $Sub($t100, $t35);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2189, $abort_code);
        goto Abort;
    }

    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue($t36);
    bit_pos := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(25, 2169, 2, $tmp);
    }

    $tmp := $Integer(128);
    $t38 := $tmp;
    call $tmp := $Ge(bit_pos, $t38);
    $t39 := $tmp;
    $tmp := $t39;
    if (b#$Boolean($tmp))
    {
        goto L9;
    }
    else
    {
        goto L10;
    }

  L10:
    goto L11;

  L9:
    $tmp := $Integer(128);
    $t41 := $tmp;
    call $tmp := $Sub(bit_pos, $t41);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2279, $abort_code);
        goto Abort;
    }

    $t42 := $tmp;
    $tmp := $Integer(1);
    $t43 := $tmp;
    call $tmp := $AddU64($t42, $t43);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2297, $abort_code);
        goto Abort;
    }

    $t44 := $tmp;
    call $tmp := $CopyOrMoveValue($t44);
    shift := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(25, 2262, 6, $tmp);
    }

    $tmp := $Integer(128);
    $t46 := $tmp;
    call $tmp := $Ge(shift, $t46);
    $t47 := $tmp;
    $tmp := $t47;
    if (b#$Boolean($tmp))
    {
        goto L12;
    }
    else
    {
        goto L13;
    }

  L13:
    goto L14;

  L12:
    $tmp := $Integer(0);
    $t48 := $tmp;
    call $t49 := $CopyOrMoveRef(t);
    call $t50 := $BorrowField($t49, $SlidingNonce_SlidingNonce_nonce_mask);
    call t := $WritebackToReference($t49, t);
    call $t50 := $WriteRef($t50, $t48);
    if (true)
    {
        assume $DebugTrackLocal(25, 2362, 7, $Dereference(t));
    }

    call t := $WritebackToReference($t50, t);
    call $t49 := $WritebackToReference($t50, $t49);
    $tmp := $Integer(1);
    $t52 := $tmp;
    call $tmp := $AddU64($t100, $t52);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2420, $abort_code);
        goto Abort;
    }

    $t53 := $tmp;
    $tmp := $Integer(128);
    $t54 := $tmp;
    call $tmp := $Sub($t53, $t54);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2424, $abort_code);
        goto Abort;
    }

    $t55 := $tmp;
    call $t56 := $CopyOrMoveRef(t);
    call $t57 := $BorrowField($t56, $SlidingNonce_SlidingNonce_min_nonce);
    call t := $WritebackToReference($t56, t);
    call $t57 := $WriteRef($t57, $t55);
    if (true)
    {
        assume $DebugTrackLocal(25, 2396, 7, $Dereference(t));
    }

    call t := $WritebackToReference($t57, t);
    call $t56 := $WritebackToReference($t57, $t56);
    goto L11;

  L14:
    call $t58 := $CopyOrMoveRef(t);
    call $tmp := $GetFieldFromReference($t58, $SlidingNonce_SlidingNonce_nonce_mask);
    $t59 := $tmp;
    call t := $WritebackToReference($t58, t);
    call $tmp := $CopyOrMoveValue($t59);
    $t60 := $tmp;
    call $tmp := $CastU8(shift);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2511, $abort_code);
        goto Abort;
    }

    $t62 := $tmp;
    call $tmp := $Shr($t60, $t62);
    $t63 := $tmp;
    call $t64 := $CopyOrMoveRef(t);
    call $t65 := $BorrowField($t64, $SlidingNonce_SlidingNonce_nonce_mask);
    call t := $WritebackToReference($t64, t);
    call $t65 := $WriteRef($t65, $t63);
    if (true)
    {
        assume $DebugTrackLocal(25, 2480, 7, $Dereference(t));
    }

    call t := $WritebackToReference($t65, t);
    call $t64 := $WritebackToReference($t65, $t64);
    call $t66 := $CopyOrMoveRef(t);
    call $tmp := $GetFieldFromReference($t66, $SlidingNonce_SlidingNonce_min_nonce);
    $t67 := $tmp;
    call t := $WritebackToReference($t66, t);
    call $tmp := $CopyOrMoveValue($t67);
    $t68 := $tmp;
    call $tmp := $AddU64($t68, shift);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2568, $abort_code);
        goto Abort;
    }

    $t70 := $tmp;
    call $t71 := $CopyOrMoveRef(t);
    call $t72 := $BorrowField($t71, $SlidingNonce_SlidingNonce_min_nonce);
    call t := $WritebackToReference($t71, t);
    call $t72 := $WriteRef($t72, $t70);
    if (true)
    {
        assume $DebugTrackLocal(25, 2542, 7, $Dereference(t));
    }

    call t := $WritebackToReference($t72, t);
    call $t71 := $WritebackToReference($t72, $t71);
    goto L11;

  L11:
    call $t74 := $CopyOrMoveRef(t);
    call $tmp := $GetFieldFromReference($t74, $SlidingNonce_SlidingNonce_min_nonce);
    $t75 := $tmp;
    call t := $WritebackToReference($t74, t);
    call $tmp := $CopyOrMoveValue($t75);
    $t76 := $tmp;
    call $tmp := $Sub($t100, $t76);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2634, $abort_code);
        goto Abort;
    }

    $t77 := $tmp;
    call $tmp := $CopyOrMoveValue($t77);
    bit_pos#1652 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(25, 2614, 3, $tmp);
    }

    $tmp := $Integer(1);
    $t78 := $tmp;
    call $tmp := $CastU8(bit_pos#1652);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(25, 2676, $abort_code);
        goto Abort;
    }

    $t80 := $tmp;
    call $tmp := $Shl($t78, $t80);
    $t81 := $tmp;
    call $tmp := $CopyOrMoveValue($t81);
    set := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(25, 2661, 5, $tmp);
    }

    call $t82 := $CopyOrMoveRef(t);
    call $tmp := $GetFieldFromReference($t82, $SlidingNonce_SlidingNonce_nonce_mask);
    $t83 := $tmp;
    call t := $WritebackToReference($t82, t);
    call $tmp := $CopyOrMoveValue($t83);
    $t84 := $tmp;
    assert false;
    $tmp := $Integer(0);
    $t87 := $tmp;
    $tmp := $Boolean(!$IsEqual($t86, $t87));
    $t88 := $tmp;
    $tmp := $t88;
    if (b#$Boolean($tmp))
    {
        goto L15;
    }
    else
    {
        goto L16;
    }

  L16:
    goto L17;

  L15:
    call $t89 := $CopyOrMoveRef(t);
    call $SlidingNonce_SlidingNonce_$memory := $WritebackToGlobal($SlidingNonce_SlidingNonce_$memory, $t89);
    $tmp := $Integer(3);
    $t90 := $tmp;
    $ret0 := $t90;
    if (true)
    {
        assume $DebugTrackLocal(25, 2744, 101, $ret0);
    }

    return;

  L17:
    call $t91 := $CopyOrMoveRef(t);
    call $tmp := $GetFieldFromReference($t91, $SlidingNonce_SlidingNonce_nonce_mask);
    $t92 := $tmp;
    call t := $WritebackToReference($t91, t);
    call $tmp := $CopyOrMoveValue($t92);
    $t93 := $tmp;
    assert false;
    call $t96 := $CopyOrMoveRef(t);
    call $t97 := $BorrowField($t96, $SlidingNonce_SlidingNonce_nonce_mask);
    call $SlidingNonce_SlidingNonce_$memory := $WritebackToGlobal($SlidingNonce_SlidingNonce_$memory, $t96);
    call $t97 := $WriteRef($t97, $t95);
    if (true)
    {
        assume $DebugTrackLocal(25, 2794, 7, $Dereference(t));
    }

    call $SlidingNonce_SlidingNonce_$memory := $WritebackToGlobal($SlidingNonce_SlidingNonce_$memory, $t97);
    call $t96 := $WritebackToReference($t97, $t96);
    $tmp := $Integer(0);
    $t98 := $tmp;
    $ret0 := $t98;
    if (true)
    {
        assume $DebugTrackLocal(25, 2837, 101, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $SlidingNonce_try_record_nonce_$direct_inter(account: $Value, seq_nonce: $Value) returns ($ret0: $Value);



implementation {:inline 1} $SlidingNonce_try_record_nonce_$direct_inter(account: $Value, seq_nonce: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(seq_nonce);
    call $ret0 := $SlidingNonce_try_record_nonce_$def(account, seq_nonce);
}



procedure {:inline 1} $SlidingNonce_try_record_nonce_$direct_intra(account: $Value, seq_nonce: $Value) returns ($ret0: $Value);



implementation {:inline 1} $SlidingNonce_try_record_nonce_$direct_intra(account: $Value, seq_nonce: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(seq_nonce);
    call $ret0 := $SlidingNonce_try_record_nonce_$def(account, seq_nonce);
}



procedure {:inline 1} $SlidingNonce_try_record_nonce(account: $Value, seq_nonce: $Value) returns ($ret0: $Value);



implementation {:inline 1} $SlidingNonce_try_record_nonce(account: $Value, seq_nonce: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(seq_nonce);
    call $ret0 := $SlidingNonce_try_record_nonce_$def(account, seq_nonce);
}



const unique $LibraTransactionTimeout_TTL: $TypeName;

const $LibraTransactionTimeout_TTL_duration_microseconds: $FieldName;

axiom $LibraTransactionTimeout_TTL_duration_microseconds == 0;

function $LibraTransactionTimeout_TTL_type_value() : $TypeValue;

axiom $LibraTransactionTimeout_TTL_type_value(): $TypeValue == $StructType($LibraTransactionTimeout_TTL, $EmptyTypeValueArray);

var $LibraTransactionTimeout_TTL_$memory: $Memory;

var $LibraTransactionTimeout_TTL_$memory_$old: $Memory;

function {:inline} $LibraTransactionTimeout_TTL_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $LibraTransactionTimeout_TTL_duration_microseconds))
}

function {:inline} $LibraTransactionTimeout_TTL_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $IsValidU64($SelectField($this, $LibraTransactionTimeout_TTL_duration_microseconds))
}

procedure {:inline 1} $LibraTransactionTimeout_TTL_pack($file_id: int, $byte_index: int, $var_idx: int, duration_microseconds: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraTransactionTimeout_TTL_pack($file_id: int, $byte_index: int, $var_idx: int, duration_microseconds: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(duration_microseconds);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := duration_microseconds], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraTransactionTimeout_TTL_unpack($struct: $Value) returns (duration_microseconds: $Value);



implementation {:inline 1} $LibraTransactionTimeout_TTL_unpack($struct: $Value) returns (duration_microseconds: $Value)
{
    assume is#$Vector($struct);
    duration_microseconds := $SelectField($struct, $LibraTransactionTimeout_TTL_duration_microseconds);
    assume $IsValidU64(duration_microseconds);
}



procedure {:inline 1} $LibraTransactionTimeout_initialize_$def(lr_account: $Value);



implementation {:inline 1} $LibraTransactionTimeout_initialize_$def(lr_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(19, 606, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t19 := $tmp;
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(19, 655, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t19);
    $t7 := $tmp;
    $tmp := $Integer(0);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(19, 655, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t19);
    $t9 := $tmp;
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(19, 782, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t19);
    $t14 := $tmp;
    $tmp := $Integer(1);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(19, 782, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t19);
    $t16 := $tmp;
    $tmp := $Integer(86400000000);
    $t17 := $tmp;
    call $tmp := $LibraTransactionTimeout_TTL_pack(0, 0, 0, $t17);
    $t18 := $tmp;
    call $LibraTransactionTimeout_TTL_$memory := $MoveTo($LibraTransactionTimeout_TTL_$memory, $EmptyTypeValueArray, $t18, $t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(19, 923, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraTransactionTimeout_initialize_$direct_inter(lr_account: $Value);



implementation {:inline 1} $LibraTransactionTimeout_initialize_$direct_inter(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraTransactionTimeout_initialize_$def(lr_account);
}



procedure {:inline 1} $LibraTransactionTimeout_initialize_$direct_intra(lr_account: $Value);



implementation {:inline 1} $LibraTransactionTimeout_initialize_$direct_intra(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraTransactionTimeout_initialize_$def(lr_account);
}



procedure {:inline 1} $LibraTransactionTimeout_initialize(lr_account: $Value);



implementation {:inline 1} $LibraTransactionTimeout_initialize(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraTransactionTimeout_initialize_$def(lr_account);
}



procedure {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp_$def(timestamp: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp_$def(timestamp: $Value) returns ($ret0: $Value)
{
  var current_block_time: $Value;
  var timeout: $Value;
  var txn_time_microseconds: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(19, 1335, 0, timestamp);
    }

    call $tmp := $CopyOrMoveValue(timestamp);
    $t22 := $tmp;
    $tmp := $Integer(18446744073709);
    $t5 := $tmp;
    call $tmp := $Gt($t22, $t5);
    $t6 := $tmp;
    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $Boolean(false);
    $t7 := $tmp;
    $ret0 := $t7;
    if (true)
    {
        assume $DebugTrackLocal(19, 1514, 23, $ret0);
    }

    return;

  L2:
    call $t8 := $LibraTimestamp_now_microseconds();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    current_block_time := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(19, 1543, 1, $tmp);
    }

    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($LibraTransactionTimeout_TTL_$memory, $t9, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(19, 1618, $abort_code);
        goto Abort;
    }

    $t10 := $tmp;
    call $tmp := $GetFieldFromValue($t10, $LibraTransactionTimeout_TTL_duration_microseconds);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    timeout := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(19, 1608, 2, $tmp);
    }

    call $tmp := $AddU64(current_block_time, timeout);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(19, 1740, $abort_code);
        goto Abort;
    }

    $t15 := $tmp;
    $tmp := $Integer(1000000);
    $t17 := $tmp;
    call $tmp := $MulU64($t22, $t17);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(19, 1794, $abort_code);
        goto Abort;
    }

    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    txn_time_microseconds := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(19, 1760, 3, $tmp);
    }

    call $tmp := $Lt(current_block_time, txn_time_microseconds);
    $t21 := $tmp;
    $ret0 := $t21;
    if (true)
    {
        assume $DebugTrackLocal(19, 2160, 23, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp_$direct_inter(timestamp: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp_$direct_inter(timestamp: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(timestamp);
    call $ret0 := $LibraTransactionTimeout_is_valid_transaction_timestamp_$def(timestamp);
}



procedure {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp_$direct_intra(timestamp: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp_$direct_intra(timestamp: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(timestamp);
    call $ret0 := $LibraTransactionTimeout_is_valid_transaction_timestamp_$def(timestamp);
}



procedure {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp(timestamp: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp(timestamp: $Value) returns ($ret0: $Value)
{
    assume $IsValidU64(timestamp);
    call $ret0 := $LibraTransactionTimeout_is_valid_transaction_timestamp_$def(timestamp);
}



procedure {:inline 1} $LibraTransactionTimeout_set_timeout_$def(lr_account: $Value, new_duration: $Value);



implementation {:inline 1} $LibraTransactionTimeout_set_timeout_$def(lr_account: $Value, new_duration: $Value)
{
  var timeout: $Mutation;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Value;
  var $t12: $Mutation;
  var $t13: $Mutation;
  var $t14: $Value;
  var $t15: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(19, 1037, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(19, 1037, 1, new_duration);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue(new_duration);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    call $t6 := $Roles_has_libra_root_role($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(19, 1134, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(2);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(19, 1134, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t10 := $BorrowGlobal($LibraTransactionTimeout_TTL_$memory, $t9, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(19, 1217, $abort_code);
        goto Abort;
    }

    call timeout := $CopyOrMoveRef($t10);
    if (true)
    {
        assume $DebugTrackLocal(19, 1207, 2, $Dereference(timeout));
    }

    call $t12 := $CopyOrMoveRef(timeout);
    call $t13 := $BorrowField($t12, $LibraTransactionTimeout_TTL_duration_microseconds);
    call $LibraTransactionTimeout_TTL_$memory := $WritebackToGlobal($LibraTransactionTimeout_TTL_$memory, $t12);
    call $t13 := $WriteRef($t13, $t15);
    if (true)
    {
        assume $DebugTrackLocal(19, 1282, 2, $Dereference(timeout));
    }

    call $LibraTransactionTimeout_TTL_$memory := $WritebackToGlobal($LibraTransactionTimeout_TTL_$memory, $t13);
    call $t12 := $WritebackToReference($t13, $t12);
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraTransactionTimeout_set_timeout_$direct_inter(lr_account: $Value, new_duration: $Value);



implementation {:inline 1} $LibraTransactionTimeout_set_timeout_$direct_inter(lr_account: $Value, new_duration: $Value)
{
    assume is#$Address(lr_account);
    assume $IsValidU64(new_duration);
    call $LibraTransactionTimeout_set_timeout_$def(lr_account, new_duration);
}



procedure {:inline 1} $LibraTransactionTimeout_set_timeout_$direct_intra(lr_account: $Value, new_duration: $Value);



implementation {:inline 1} $LibraTransactionTimeout_set_timeout_$direct_intra(lr_account: $Value, new_duration: $Value)
{
    assume is#$Address(lr_account);
    assume $IsValidU64(new_duration);
    call $LibraTransactionTimeout_set_timeout_$def(lr_account, new_duration);
}



procedure {:inline 1} $LibraTransactionTimeout_set_timeout(lr_account: $Value, new_duration: $Value);



implementation {:inline 1} $LibraTransactionTimeout_set_timeout(lr_account: $Value, new_duration: $Value)
{
    assume is#$Address(lr_account);
    assume $IsValidU64(new_duration);
    call $LibraTransactionTimeout_set_timeout_$def(lr_account, new_duration);
}



function {:inline} $LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, payer: $Value, payee: $Value, is_withdrawal: $Value) : $Value
{
  (if b#$Boolean(is_withdrawal) then $Boolean(b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))) || b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee))))))) else $Boolean(b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))) || b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee, payer))))))))
}

function {:inline} $LibraAccount_spec_rotate_authentication_key($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value, new_authentication_key: $Value) : $Value
{
  $Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr), $LibraAccount_LibraAccount_authentication_key), new_authentication_key))
}

function {:inline} $LibraAccount_spec_get_key_rotation_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value) : $Value
{
  $SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr), $LibraAccount_LibraAccount_key_rotation_capability)
}

function {:inline} $LibraAccount_spec_holds_own_key_rotation_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value) : $Value
{
  $Boolean(b#$Boolean($Option_spec_is_some($LibraAccount_KeyRotationCapability_type_value(), $LibraAccount_spec_get_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr))) && b#$Boolean($Boolean($IsEqual(addr, $SelectField($Option_spec_get($LibraAccount_KeyRotationCapability_type_value(), $LibraAccount_spec_get_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr)), $LibraAccount_KeyRotationCapability_account_address)))))
}

function {:inline} $LibraAccount_spec_key_rotation_capability_address(cap: $Value) : $Value
{
  $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)
}

function {:inline} $LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value) : $Value
{
  $Option_spec_is_none($LibraAccount_KeyRotationCapability_type_value(), $LibraAccount_spec_get_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr))
}

function {:inline} $LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory: $Memory) : $Value
{
  $ResourceExists($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraAccount_spec_has_key_rotation_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value) : $Value
{
  $Option_spec_is_some($LibraAccount_KeyRotationCapability_type_value(), $SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr), $LibraAccount_LibraAccount_key_rotation_capability))
}

function {:inline} $LibraAccount_spec_has_withdraw_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value) : $Value
{
  $Option_spec_is_some($LibraAccount_WithdrawCapability_type_value(), $SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr), $LibraAccount_LibraAccount_withdrawal_capability))
}

const unique $LibraAccount_LibraAccount: $TypeName;

const $LibraAccount_LibraAccount_authentication_key: $FieldName;

axiom $LibraAccount_LibraAccount_authentication_key == 0;

const $LibraAccount_LibraAccount_withdrawal_capability: $FieldName;

axiom $LibraAccount_LibraAccount_withdrawal_capability == 1;

const $LibraAccount_LibraAccount_key_rotation_capability: $FieldName;

axiom $LibraAccount_LibraAccount_key_rotation_capability == 2;

const $LibraAccount_LibraAccount_received_events: $FieldName;

axiom $LibraAccount_LibraAccount_received_events == 3;

const $LibraAccount_LibraAccount_sent_events: $FieldName;

axiom $LibraAccount_LibraAccount_sent_events == 4;

const $LibraAccount_LibraAccount_sequence_number: $FieldName;

axiom $LibraAccount_LibraAccount_sequence_number == 5;

function $LibraAccount_LibraAccount_type_value() : $TypeValue;

axiom $LibraAccount_LibraAccount_type_value(): $TypeValue == $StructType($LibraAccount_LibraAccount, $EmptyTypeValueArray);

var $LibraAccount_LibraAccount_$memory: $Memory;

var $LibraAccount_LibraAccount_$memory_$old: $Memory;

function {:inline} $LibraAccount_LibraAccount_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 6 && $Vector_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) && (forall $$0: int :: {:qid "quantifier795"} { $select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key), $$0))) && $Option_Option_is_well_formed_types($SelectField($this, $LibraAccount_LibraAccount_withdrawal_capability)) && $Option_Option_is_well_formed_types($SelectField($this, $LibraAccount_LibraAccount_key_rotation_capability)) && $Event_EventHandle_is_well_formed_types($SelectField($this, $LibraAccount_LibraAccount_received_events)) && $Event_EventHandle_is_well_formed_types($SelectField($this, $LibraAccount_LibraAccount_sent_events)) && $IsValidU64($SelectField($this, $LibraAccount_LibraAccount_sequence_number))
}

function {:inline} $LibraAccount_LibraAccount_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 6 && $Vector_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) && (forall $$0: int :: {:qid "quantifier796"} { $select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key), $$0))) && $Option_Option_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_withdrawal_capability)) && $Option_Option_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_key_rotation_capability)) && $Event_EventHandle_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_received_events)) && $Event_EventHandle_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_sent_events)) && $IsValidU64($SelectField($this, $LibraAccount_LibraAccount_sequence_number))
}

procedure {:inline 1} $LibraAccount_LibraAccount_before_update_inv($before: $Value);



implementation {:inline 1} $LibraAccount_LibraAccount_before_update_inv($before: $Value)
{
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $SelectField($before, $LibraAccount_LibraAccount_withdrawal_capability));
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $SelectField($before, $LibraAccount_LibraAccount_key_rotation_capability));
}



procedure {:inline 1} $LibraAccount_LibraAccount_after_update_inv($after: $Value);



implementation {:inline 1} $LibraAccount_LibraAccount_after_update_inv($after: $Value)
{
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $SelectField($after, $LibraAccount_LibraAccount_withdrawal_capability));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $SelectField($after, $LibraAccount_LibraAccount_key_rotation_capability));
}



procedure {:inline 1} $LibraAccount_LibraAccount_pack($file_id: int, $byte_index: int, $var_idx: int, authentication_key: $Value, withdrawal_capability: $Value, key_rotation_capability: $Value, received_events: $Value, sent_events: $Value, sequence_number: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraAccount_LibraAccount_pack($file_id: int, $byte_index: int, $var_idx: int, authentication_key: $Value, withdrawal_capability: $Value, key_rotation_capability: $Value, received_events: $Value, sent_events: $Value, sequence_number: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(authentication_key) && (forall $$0: int :: {:qid "quantifier797"} { $select_vector(authentication_key, $$0) } $$0 >= 0 && $$0 < $vlen(authentication_key) ==> $IsValidU8($select_vector(authentication_key, $$0)));
    assume $Option_Option_is_well_formed(withdrawal_capability);
    assume $Option_Option_is_well_formed(key_rotation_capability);
    assume $Event_EventHandle_is_well_formed(received_events);
    assume $Event_EventHandle_is_well_formed(sent_events);
    assume $IsValidU64(sequence_number);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := authentication_key][1 := withdrawal_capability][2 := key_rotation_capability][3 := received_events][4 := sent_events][5 := sequence_number], 6));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraAccount_LibraAccount_unpack($struct: $Value) returns (authentication_key: $Value, withdrawal_capability: $Value, key_rotation_capability: $Value, received_events: $Value, sent_events: $Value, sequence_number: $Value);



implementation {:inline 1} $LibraAccount_LibraAccount_unpack($struct: $Value) returns (authentication_key: $Value, withdrawal_capability: $Value, key_rotation_capability: $Value, received_events: $Value, sent_events: $Value, sequence_number: $Value)
{
    assume is#$Vector($struct);
    authentication_key := $SelectField($struct, $LibraAccount_LibraAccount_authentication_key);
    assume $Vector_is_well_formed(authentication_key) && (forall $$0: int :: {:qid "quantifier798"} { $select_vector(authentication_key, $$0) } $$0 >= 0 && $$0 < $vlen(authentication_key) ==> $IsValidU8($select_vector(authentication_key, $$0)));
    withdrawal_capability := $SelectField($struct, $LibraAccount_LibraAccount_withdrawal_capability);
    assume $Option_Option_is_well_formed(withdrawal_capability);
    key_rotation_capability := $SelectField($struct, $LibraAccount_LibraAccount_key_rotation_capability);
    assume $Option_Option_is_well_formed(key_rotation_capability);
    received_events := $SelectField($struct, $LibraAccount_LibraAccount_received_events);
    assume $Event_EventHandle_is_well_formed(received_events);
    sent_events := $SelectField($struct, $LibraAccount_LibraAccount_sent_events);
    assume $Event_EventHandle_is_well_formed(sent_events);
    sequence_number := $SelectField($struct, $LibraAccount_LibraAccount_sequence_number);
    assume $IsValidU64(sequence_number);
}



const unique $LibraAccount_AccountOperationsCapability: $TypeName;

const $LibraAccount_AccountOperationsCapability_limits_cap: $FieldName;

axiom $LibraAccount_AccountOperationsCapability_limits_cap == 0;

function $LibraAccount_AccountOperationsCapability_type_value() : $TypeValue;

axiom $LibraAccount_AccountOperationsCapability_type_value(): $TypeValue == $StructType($LibraAccount_AccountOperationsCapability, $EmptyTypeValueArray);

var $LibraAccount_AccountOperationsCapability_$memory: $Memory;

var $LibraAccount_AccountOperationsCapability_$memory_$old: $Memory;

function {:inline} $LibraAccount_AccountOperationsCapability_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $AccountLimits_AccountLimitMutationCapability_is_well_formed_types($SelectField($this, $LibraAccount_AccountOperationsCapability_limits_cap))
}

function {:inline} $LibraAccount_AccountOperationsCapability_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $AccountLimits_AccountLimitMutationCapability_is_well_formed($SelectField($this, $LibraAccount_AccountOperationsCapability_limits_cap))
}

procedure {:inline 1} $LibraAccount_AccountOperationsCapability_pack($file_id: int, $byte_index: int, $var_idx: int, limits_cap: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraAccount_AccountOperationsCapability_pack($file_id: int, $byte_index: int, $var_idx: int, limits_cap: $Value) returns ($struct: $Value)
{
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(limits_cap);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := limits_cap], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraAccount_AccountOperationsCapability_unpack($struct: $Value) returns (limits_cap: $Value);



implementation {:inline 1} $LibraAccount_AccountOperationsCapability_unpack($struct: $Value) returns (limits_cap: $Value)
{
    assume is#$Vector($struct);
    limits_cap := $SelectField($struct, $LibraAccount_AccountOperationsCapability_limits_cap);
    assume $AccountLimits_AccountLimitMutationCapability_is_well_formed(limits_cap);
}



const unique $LibraAccount_Balance: $TypeName;

const $LibraAccount_Balance_coin: $FieldName;

axiom $LibraAccount_Balance_coin == 0;

function $LibraAccount_Balance_type_value($tv0: $TypeValue) : $TypeValue;

axiom (forall $tv0: $TypeValue :: {:qid "quantifier799"} { $LibraAccount_Balance_type_value($tv0): $TypeValue } $LibraAccount_Balance_type_value($tv0): $TypeValue == $StructType($LibraAccount_Balance, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1)));

var $LibraAccount_Balance_$memory: $Memory;

var $LibraAccount_Balance_$memory_$old: $Memory;

function {:inline} $LibraAccount_Balance_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Libra_Libra_is_well_formed_types($SelectField($this, $LibraAccount_Balance_coin))
}

function {:inline} $LibraAccount_Balance_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && $Libra_Libra_is_well_formed($SelectField($this, $LibraAccount_Balance_coin))
}

procedure {:inline 1} $LibraAccount_Balance_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, coin: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraAccount_Balance_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, coin: $Value) returns ($struct: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := coin], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraAccount_Balance_unpack($tv0: $TypeValue, $struct: $Value) returns (coin: $Value);



implementation {:inline 1} $LibraAccount_Balance_unpack($tv0: $TypeValue, $struct: $Value) returns (coin: $Value)
{
    assume is#$Vector($struct);
    coin := $SelectField($struct, $LibraAccount_Balance_coin);
    assume $Libra_Libra_is_well_formed(coin);
}



const unique $LibraAccount_KeyRotationCapability: $TypeName;

const $LibraAccount_KeyRotationCapability_account_address: $FieldName;

axiom $LibraAccount_KeyRotationCapability_account_address == 0;

function $LibraAccount_KeyRotationCapability_type_value() : $TypeValue;

axiom $LibraAccount_KeyRotationCapability_type_value(): $TypeValue == $StructType($LibraAccount_KeyRotationCapability, $EmptyTypeValueArray);

var $LibraAccount_KeyRotationCapability_$memory: $Memory;

var $LibraAccount_KeyRotationCapability_$memory_$old: $Memory;

function {:inline} $LibraAccount_KeyRotationCapability_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Address($SelectField($this, $LibraAccount_KeyRotationCapability_account_address))
}

function {:inline} $LibraAccount_KeyRotationCapability_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Address($SelectField($this, $LibraAccount_KeyRotationCapability_account_address))
}

procedure {:inline 1} $LibraAccount_KeyRotationCapability_pack($file_id: int, $byte_index: int, $var_idx: int, account_address: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraAccount_KeyRotationCapability_pack($file_id: int, $byte_index: int, $var_idx: int, account_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(account_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := account_address], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraAccount_KeyRotationCapability_unpack($struct: $Value) returns (account_address: $Value);



implementation {:inline 1} $LibraAccount_KeyRotationCapability_unpack($struct: $Value) returns (account_address: $Value)
{
    assume is#$Vector($struct);
    account_address := $SelectField($struct, $LibraAccount_KeyRotationCapability_account_address);
    assume is#$Address(account_address);
}



const unique $LibraAccount_ReceivedPaymentEvent: $TypeName;

const $LibraAccount_ReceivedPaymentEvent_amount: $FieldName;

axiom $LibraAccount_ReceivedPaymentEvent_amount == 0;

const $LibraAccount_ReceivedPaymentEvent_currency_code: $FieldName;

axiom $LibraAccount_ReceivedPaymentEvent_currency_code == 1;

const $LibraAccount_ReceivedPaymentEvent_payer: $FieldName;

axiom $LibraAccount_ReceivedPaymentEvent_payer == 2;

const $LibraAccount_ReceivedPaymentEvent_metadata: $FieldName;

axiom $LibraAccount_ReceivedPaymentEvent_metadata == 3;

function $LibraAccount_ReceivedPaymentEvent_type_value() : $TypeValue;

axiom $LibraAccount_ReceivedPaymentEvent_type_value(): $TypeValue == $StructType($LibraAccount_ReceivedPaymentEvent, $EmptyTypeValueArray);

var $LibraAccount_ReceivedPaymentEvent_$memory: $Memory;

var $LibraAccount_ReceivedPaymentEvent_$memory_$old: $Memory;

function {:inline} $LibraAccount_ReceivedPaymentEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 4 && $IsValidU64($SelectField($this, $LibraAccount_ReceivedPaymentEvent_amount)) && $Vector_is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier800"} { $select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code), $$0))) && is#$Address($SelectField($this, $LibraAccount_ReceivedPaymentEvent_payer)) && $Vector_is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) && (forall $$0: int :: {:qid "quantifier801"} { $select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata), $$0)))
}

function {:inline} $LibraAccount_ReceivedPaymentEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 4 && $IsValidU64($SelectField($this, $LibraAccount_ReceivedPaymentEvent_amount)) && $Vector_is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier802"} { $select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code), $$0))) && is#$Address($SelectField($this, $LibraAccount_ReceivedPaymentEvent_payer)) && $Vector_is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) && (forall $$0: int :: {:qid "quantifier803"} { $select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata), $$0)))
}

procedure {:inline 1} $LibraAccount_ReceivedPaymentEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, payer: $Value, metadata: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraAccount_ReceivedPaymentEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, payer: $Value, metadata: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier804"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    assume is#$Address(payer);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier805"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := payer][3 := metadata], 4));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraAccount_ReceivedPaymentEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, payer: $Value, metadata: $Value);



implementation {:inline 1} $LibraAccount_ReceivedPaymentEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, payer: $Value, metadata: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier806"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    payer := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_payer);
    assume is#$Address(payer);
    metadata := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_metadata);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier807"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
}



const unique $LibraAccount_SentPaymentEvent: $TypeName;

const $LibraAccount_SentPaymentEvent_amount: $FieldName;

axiom $LibraAccount_SentPaymentEvent_amount == 0;

const $LibraAccount_SentPaymentEvent_currency_code: $FieldName;

axiom $LibraAccount_SentPaymentEvent_currency_code == 1;

const $LibraAccount_SentPaymentEvent_payee: $FieldName;

axiom $LibraAccount_SentPaymentEvent_payee == 2;

const $LibraAccount_SentPaymentEvent_metadata: $FieldName;

axiom $LibraAccount_SentPaymentEvent_metadata == 3;

function $LibraAccount_SentPaymentEvent_type_value() : $TypeValue;

axiom $LibraAccount_SentPaymentEvent_type_value(): $TypeValue == $StructType($LibraAccount_SentPaymentEvent, $EmptyTypeValueArray);

var $LibraAccount_SentPaymentEvent_$memory: $Memory;

var $LibraAccount_SentPaymentEvent_$memory_$old: $Memory;

function {:inline} $LibraAccount_SentPaymentEvent_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 4 && $IsValidU64($SelectField($this, $LibraAccount_SentPaymentEvent_amount)) && $Vector_is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier808"} { $select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code), $$0))) && is#$Address($SelectField($this, $LibraAccount_SentPaymentEvent_payee)) && $Vector_is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) && (forall $$0: int :: {:qid "quantifier809"} { $select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata), $$0)))
}

function {:inline} $LibraAccount_SentPaymentEvent_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 4 && $IsValidU64($SelectField($this, $LibraAccount_SentPaymentEvent_amount)) && $Vector_is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) && (forall $$0: int :: {:qid "quantifier810"} { $select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code), $$0))) && is#$Address($SelectField($this, $LibraAccount_SentPaymentEvent_payee)) && $Vector_is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) && (forall $$0: int :: {:qid "quantifier811"} { $select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata), $$0) } $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata), $$0)))
}

procedure {:inline 1} $LibraAccount_SentPaymentEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, payee: $Value, metadata: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraAccount_SentPaymentEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, payee: $Value, metadata: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier812"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    assume is#$Address(payee);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier813"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := payee][3 := metadata], 4));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraAccount_SentPaymentEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, payee: $Value, metadata: $Value);



implementation {:inline 1} $LibraAccount_SentPaymentEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, payee: $Value, metadata: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $LibraAccount_SentPaymentEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $LibraAccount_SentPaymentEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {:qid "quantifier814"} { $select_vector(currency_code, $$0) } $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code, $$0)));
    payee := $SelectField($struct, $LibraAccount_SentPaymentEvent_payee);
    assume is#$Address(payee);
    metadata := $SelectField($struct, $LibraAccount_SentPaymentEvent_metadata);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier815"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
}



const unique $LibraAccount_WithdrawCapability: $TypeName;

const $LibraAccount_WithdrawCapability_account_address: $FieldName;

axiom $LibraAccount_WithdrawCapability_account_address == 0;

function $LibraAccount_WithdrawCapability_type_value() : $TypeValue;

axiom $LibraAccount_WithdrawCapability_type_value(): $TypeValue == $StructType($LibraAccount_WithdrawCapability, $EmptyTypeValueArray);

var $LibraAccount_WithdrawCapability_$memory: $Memory;

var $LibraAccount_WithdrawCapability_$memory_$old: $Memory;

function {:inline} $LibraAccount_WithdrawCapability_is_well_formed_types($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Address($SelectField($this, $LibraAccount_WithdrawCapability_account_address))
}

function {:inline} $LibraAccount_WithdrawCapability_is_well_formed($this: $Value) : bool
{
  $Vector_is_well_formed($this) && $vlen($this) == 1 && is#$Address($SelectField($this, $LibraAccount_WithdrawCapability_account_address))
}

procedure {:inline 1} $LibraAccount_WithdrawCapability_pack($file_id: int, $byte_index: int, $var_idx: int, account_address: $Value) returns ($struct: $Value);



implementation {:inline 1} $LibraAccount_WithdrawCapability_pack($file_id: int, $byte_index: int, $var_idx: int, account_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(account_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := account_address], 1));
    if ($byte_index > 0)
    {
        assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct);
    }
}



procedure {:inline 1} $LibraAccount_WithdrawCapability_unpack($struct: $Value) returns (account_address: $Value);



implementation {:inline 1} $LibraAccount_WithdrawCapability_unpack($struct: $Value) returns (account_address: $Value)
{
    assume is#$Vector($struct);
    account_address := $SelectField($struct, $LibraAccount_WithdrawCapability_account_address);
    assume is#$Address(account_address);
}



procedure {:inline 1} $LibraAccount_initialize_$def(lr_account: $Value);



implementation {:inline 1} $LibraAccount_initialize_$def(lr_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 5851, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t20 := $tmp;
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 5919, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t20);
    $t7 := $tmp;
    $tmp := $Integer(0);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 5919, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t20);
    $t9 := $tmp;
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6042, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t20);
    $t14 := $tmp;
    $tmp := $Integer(1);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 6042, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t20);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t17 := $tmp;
    call $t18 := $AccountLimits_grant_mutation_capability($t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_AccountOperationsCapability_pack(0, 0, 0, $t18);
    $t19 := $tmp;
    call $LibraAccount_AccountOperationsCapability_$memory := $MoveTo($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $t19, $t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 6157, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_initialize_$direct_inter(lr_account: $Value);



implementation {:inline 1} $LibraAccount_initialize_$direct_inter(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraAccount_initialize_$def(lr_account);
}



procedure {:inline 1} $LibraAccount_initialize_$direct_intra(lr_account: $Value);



implementation {:inline 1} $LibraAccount_initialize_$direct_intra(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraAccount_initialize_$def(lr_account);
}



procedure {:inline 1} $LibraAccount_initialize(lr_account: $Value);



implementation {:inline 1} $LibraAccount_initialize(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $LibraAccount_initialize_$def(lr_account);
}



procedure {:inline 1} $LibraAccount_initialize_$def_verify(lr_account: $Value);



implementation {:inline 1} $LibraAccount_initialize_$def_verify(lr_account: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 5851, 0, lr_account);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t20 := $tmp;
    call $t5 := $LibraTimestamp_is_genesis_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 5919, 1, $tmp);
    }

    $tmp := $t1;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t20);
    $t7 := $tmp;
    $tmp := $Integer(0);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 5919, i#$Integer($t8));
    }

    $abort_code := i#$Integer($t8);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t20);
    $t9 := $tmp;
    call $t10 := $Signer_address_of_$direct_inter($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6042, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t20);
    $t14 := $tmp;
    $tmp := $Integer(1);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 6042, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t20);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t17 := $tmp;
    call $t18 := $AccountLimits_grant_mutation_capability_$direct_inter($t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_AccountOperationsCapability_pack(0, 0, 0, $t18);
    $t19 := $tmp;
    call $LibraAccount_AccountOperationsCapability_$memory := $MoveTo($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $t19, $t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 6157, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_initialize_$verify(lr_account: $Value);



implementation $LibraAccount_initialize_$verify(lr_account: $Value)
{
    assume is#$Address(lr_account);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier816"} { contents#$Memory($LibraTimestamp_TimeHasStarted_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_TimeHasStarted_is_well_formed(contents#$Memory($LibraTimestamp_TimeHasStarted_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier817"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier818"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier819"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_initialize_$def_verify(lr_account);
}



procedure {:inline 1} $LibraAccount_preburn_$def($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value);



implementation {:inline 1} $LibraAccount_preburn_$def($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 18539, 0, dd);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 18539, 1, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 18539, 2, amount);
    }

    call $tmp := $CopyOrMoveValue(dd);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue(cap);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t5 := $tmp;
    call $t6 := $Signer_address_of($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t8 := $tmp;
    call $t9 := $LibraAccount_withdraw_from($tv0, $t4, $t6, $t12, $t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $Libra_preburn_to($tv0, $t3, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_preburn_$direct_inter($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value);



implementation {:inline 1} $LibraAccount_preburn_$direct_inter($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value)
{
    assume is#$Address(dd);
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount);
    call $LibraAccount_preburn_$def($tv0, dd, cap, amount);
}



procedure {:inline 1} $LibraAccount_preburn_$direct_intra($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value);



implementation {:inline 1} $LibraAccount_preburn_$direct_intra($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value)
{
    assume is#$Address(dd);
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount);
    call $LibraAccount_preburn_$def($tv0, dd, cap, amount);
}



procedure {:inline 1} $LibraAccount_preburn($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value);



implementation {:inline 1} $LibraAccount_preburn($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value)
{
    assume is#$Address(dd);
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount);
    call $LibraAccount_preburn_$def($tv0, dd, cap, amount);
}



procedure {:inline 1} $LibraAccount_preburn_$def_verify($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value);



implementation {:inline 1} $LibraAccount_preburn_$def_verify($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 18539, 0, dd);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 18539, 1, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 18539, 2, amount);
    }

    call $tmp := $CopyOrMoveValue(dd);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue(cap);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t5 := $tmp;
    call $t6 := $Signer_address_of_$direct_inter($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t8 := $tmp;
    call $t9 := $LibraAccount_withdraw_from_$direct_intra($tv0, $t4, $t6, $t12, $t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $Libra_preburn_to_$direct_inter($tv0, $t3, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_preburn_$verify($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value);



implementation $LibraAccount_preburn_$verify($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value)
{
    assume is#$Address(dd);
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier820"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier821"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier822"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier823"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier824"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier825"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier826"} { contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Preburn_is_well_formed(contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier827"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier828"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier829"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier830"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier831"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier832"} { contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_WithdrawCapability_is_well_formed(contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier833"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier834"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier835"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_preburn_$def_verify($tv0, dd, cap, amount);
}



procedure {:inline 1} $LibraAccount_cancel_burn_$def($tv0: $TypeValue, account: $Value, preburn_address: $Value);



implementation {:inline 1} $LibraAccount_cancel_burn_$def($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
  var coin: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 14631, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 14631, 1, preburn_address);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t3 := $tmp;
    call $t5 := $Libra_cancel_burn($tv0, $t3, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    coin := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 14802, 2, $tmp);
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t9 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t10 := $tmp;
    call $LibraAccount_deposit($tv0, $t12, $t12, coin, $t9, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_cancel_burn_$direct_inter($tv0: $TypeValue, account: $Value, preburn_address: $Value);



implementation {:inline 1} $LibraAccount_cancel_burn_$direct_inter($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $LibraAccount_cancel_burn_$def($tv0, account, preburn_address);
}



procedure {:inline 1} $LibraAccount_cancel_burn_$direct_intra($tv0: $TypeValue, account: $Value, preburn_address: $Value);



implementation {:inline 1} $LibraAccount_cancel_burn_$direct_intra($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $LibraAccount_cancel_burn_$def($tv0, account, preburn_address);
}



procedure {:inline 1} $LibraAccount_cancel_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value);



implementation {:inline 1} $LibraAccount_cancel_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $LibraAccount_cancel_burn_$def($tv0, account, preburn_address);
}



procedure {:inline 1} $LibraAccount_cancel_burn_$def_verify($tv0: $TypeValue, account: $Value, preburn_address: $Value);



implementation {:inline 1} $LibraAccount_cancel_burn_$def_verify($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
  var coin: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 14631, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 14631, 1, preburn_address);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    $t3 := $tmp;
    call $t5 := $Libra_cancel_burn_$direct_inter($tv0, $t3, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    coin := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 14802, 2, $tmp);
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t9 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t10 := $tmp;
    call $LibraAccount_deposit_$direct_intra($tv0, $t12, $t12, coin, $t9, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_cancel_burn_$verify($tv0: $TypeValue, account: $Value, preburn_address: $Value);



implementation $LibraAccount_cancel_burn_$verify($tv0: $TypeValue, account: $Value, preburn_address: $Value)
{
    assume is#$Address(account);
    assume is#$Address(preburn_address);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier836"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier837"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier838"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier839"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier840"} { contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr] } $FixedPoint32_FixedPoint32_is_well_formed(contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier841"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier842"} { contents#$Memory($Libra_BurnCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_BurnCapability_is_well_formed(contents#$Memory($Libra_BurnCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier843"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier844"} { contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Preburn_is_well_formed(contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier845"} { contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr] } $DesignatedDealer_Dealer_is_well_formed(contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier846"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier847"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier848"} { contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Credential_is_well_formed(contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier849"} { contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Limit_is_well_formed(contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier850"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier851"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier852"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier853"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier854"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier855"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_cancel_burn_$def_verify($tv0, account, preburn_address);
}



procedure {:inline 1} $LibraAccount_deposit_$def($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $LibraAccount_deposit_$def($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value)
{
  var deposit_value: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Mutation;
  var $t56: $Mutation;
  var $t57: $Value;
  var $t58: $Value;
  var $t59: $Mutation;
  var $t60: $Mutation;
  var $t61: $Value;
  var $t62: $Value;
  var $t63: $Value;
  var $t64: $Value;
  var $t65: $Value;
  var $t66: $Value;
  var $t67: $Value;
  var $t68: $Value;
  var $t69: $Value;
  var $t70: $Value;
  var $t71: $Value;
  var $t72: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 2, to_deposit);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 3, metadata);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 4, metadata_signature);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t66 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t67 := $tmp;
    call $tmp := $CopyOrMoveValue(to_deposit);
    $t68 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata);
    $t69 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t70 := $tmp;
    call $t17 := $AccountFreezing_account_is_frozen($t67);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t17);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10375, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(16);
    $t20 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 10375, i#$Integer($t20));
    }

    $abort_code := i#$Integer($t20);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t68);
    $t21 := $tmp;
    call $t22 := $Libra_value($tv0, $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t22);
    deposit_value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10513, 5, $tmp);
    }

    $tmp := $Integer(0);
    $t24 := $tmp;
    call $tmp := $Gt(deposit_value, $t24);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue($t25);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10564, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(2);
    $t27 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 10564, i#$Integer($t27));
    }

    $abort_code := i#$Integer($t27);
    goto Abort;

  L2:
    $tmp := $ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $t67);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue($t29);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10673, 10, $tmp);
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    $tmp := $Integer(17);
    $t31 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 10673, i#$Integer($t31));
    }

    $abort_code := i#$Integer($t31);
    goto Abort;

  L4:
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t67);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue($t33);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10802, 12, $tmp);
    }

    $tmp := $t12;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    $tmp := $Integer(18);
    $t35 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 10802, i#$Integer($t35));
    }

    $abort_code := i#$Integer($t35);
    goto Abort;

  L6:
    call $DualAttestation_assert_payment_ok($tv0, $t66, $t67, deposit_value, $t69, $t70);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean(false);
    $t43 := $tmp;
    call $t44 := $LibraAccount_should_track_limits_for_account($t66, $t67, $t43);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t44;
    if (b#$Boolean($tmp))
    {
        goto L8;
    }
    else
    {
        goto L9;
    }

  L9:
    goto L10;

  L8:
    call $t47 := $VASP_parent_address($t67);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t48 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($LibraAccount_AccountOperationsCapability_$memory, $t48, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 11439, $abort_code);
        goto Abort;
    }

    $t49 := $tmp;
    call $tmp := $GetFieldFromValue($t49, $LibraAccount_AccountOperationsCapability_limits_cap);
    $t50 := $tmp;
    call $t51 := $AccountLimits_update_deposit_limits($tv0, deposit_value, $t47, $t50);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t51);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 11265, 14, $tmp);
    }

    $tmp := $t14;
    if (b#$Boolean($tmp))
    {
        goto L10;
    }
    else
    {
        goto L11;
    }

  L11:
    $tmp := $Integer(3);
    $t53 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 11265, i#$Integer($t53));
    }

    $abort_code := i#$Integer($t53);
    goto Abort;

  L10:
    call $t55 := $BorrowGlobal($LibraAccount_Balance_$memory, $t67, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 11684, $abort_code);
        goto Abort;
    }

    call $t56 := $BorrowField($t55, $LibraAccount_Balance_coin);
    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, $t55);
    call $tmp := $ReadRef($t56);
    $t72 := $tmp;
    call $t72 := $Libra_deposit($tv0, $t72, $t68);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t56 := $WriteRef($t56, $t72);
    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, $t56);
    call $t55 := $WritebackToReference($t56, $t55);
    call $t59 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t67, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 11843, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t59));
    call $t60 := $BorrowField($t59, $LibraAccount_LibraAccount_received_events);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t59);
    call $t62 := $Libra_currency_code($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_ReceivedPaymentEvent_pack(0, 0, 0, deposit_value, $t62, $t66, $t69);
    $t65 := $tmp;
    call $tmp := $ReadRef($t60);
    $t71 := $tmp;
    call $t71 := $Event_emit_event($LibraAccount_ReceivedPaymentEvent_type_value(), $t71, $t65);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t60 := $WriteRef($t60, $t71);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t60);
    call $t59 := $WritebackToReference($t60, $t59);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t59));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_deposit_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $LibraAccount_deposit_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value)
{
    assume is#$Address(payer);
    assume is#$Address(payee);
    assume $Libra_Libra_is_well_formed(to_deposit);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier856"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    assume $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {:qid "quantifier857"} { $select_vector(metadata_signature, $$0) } $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature, $$0)));
    call $LibraAccount_deposit_$def($tv0, payer, payee, to_deposit, metadata, metadata_signature);
}



procedure {:inline 1} $LibraAccount_deposit($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $LibraAccount_deposit($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value)
{
    assume is#$Address(payer);
    assume is#$Address(payee);
    assume $Libra_Libra_is_well_formed(to_deposit);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier858"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    assume $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {:qid "quantifier859"} { $select_vector(metadata_signature, $$0) } $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature, $$0)));
    call $LibraAccount_deposit_$def($tv0, payer, payee, to_deposit, metadata, metadata_signature);
}



procedure {:inline 1} $LibraAccount_deposit_$def_verify($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $LibraAccount_deposit_$def_verify($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value)
{
  var deposit_value: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Value;
  var $t52: $Value;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Mutation;
  var $t56: $Mutation;
  var $t57: $Value;
  var $t58: $Value;
  var $t59: $Mutation;
  var $t60: $Mutation;
  var $t61: $Value;
  var $t62: $Value;
  var $t63: $Value;
  var $t64: $Value;
  var $t65: $Value;
  var $t66: $Value;
  var $t67: $Value;
  var $t68: $Value;
  var $t69: $Value;
  var $t70: $Value;
  var $t71: $Value;
  var $t72: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 2, to_deposit);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 3, metadata);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 10128, 4, metadata_signature);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t66 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t67 := $tmp;
    call $tmp := $CopyOrMoveValue(to_deposit);
    $t68 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata);
    $t69 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t70 := $tmp;
    call $t17 := $AccountFreezing_account_is_frozen_$direct_inter($t67);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t17);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10375, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(16);
    $t20 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 10375, i#$Integer($t20));
    }

    $abort_code := i#$Integer($t20);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t68);
    $t21 := $tmp;
    call $t22 := $Libra_value_$direct_inter($tv0, $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t22);
    deposit_value := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10513, 5, $tmp);
    }

    $tmp := $Integer(0);
    $t24 := $tmp;
    call $tmp := $Gt(deposit_value, $t24);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue($t25);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10564, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(2);
    $t27 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 10564, i#$Integer($t27));
    }

    $abort_code := i#$Integer($t27);
    goto Abort;

  L2:
    $tmp := $ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $t67);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue($t29);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10673, 10, $tmp);
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    $tmp := $Integer(17);
    $t31 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 10673, i#$Integer($t31));
    }

    $abort_code := i#$Integer($t31);
    goto Abort;

  L4:
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t67);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue($t33);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 10802, 12, $tmp);
    }

    $tmp := $t12;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    $tmp := $Integer(18);
    $t35 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 10802, i#$Integer($t35));
    }

    $abort_code := i#$Integer($t35);
    goto Abort;

  L6:
    call $DualAttestation_assert_payment_ok_$direct_inter($tv0, $t66, $t67, deposit_value, $t69, $t70);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean(false);
    $t43 := $tmp;
    call $t44 := $LibraAccount_should_track_limits_for_account_$direct_intra($t66, $t67, $t43);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t44;
    if (b#$Boolean($tmp))
    {
        goto L8;
    }
    else
    {
        goto L9;
    }

  L9:
    goto L10;

  L8:
    call $t47 := $VASP_parent_address_$direct_inter($t67);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t48 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($LibraAccount_AccountOperationsCapability_$memory, $t48, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 11439, $abort_code);
        goto Abort;
    }

    $t49 := $tmp;
    call $tmp := $GetFieldFromValue($t49, $LibraAccount_AccountOperationsCapability_limits_cap);
    $t50 := $tmp;
    call $t51 := $AccountLimits_update_deposit_limits_$direct_inter($tv0, deposit_value, $t47, $t50);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t51);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 11265, 14, $tmp);
    }

    $tmp := $t14;
    if (b#$Boolean($tmp))
    {
        goto L10;
    }
    else
    {
        goto L11;
    }

  L11:
    $tmp := $Integer(3);
    $t53 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 11265, i#$Integer($t53));
    }

    $abort_code := i#$Integer($t53);
    goto Abort;

  L10:
    call $t55 := $BorrowGlobal($LibraAccount_Balance_$memory, $t67, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 11684, $abort_code);
        goto Abort;
    }

    call $t56 := $BorrowField($t55, $LibraAccount_Balance_coin);
    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, $t55);
    call $tmp := $ReadRef($t56);
    $t72 := $tmp;
    call $t72 := $Libra_deposit_$direct_inter($tv0, $t72, $t68);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t56 := $WriteRef($t56, $t72);
    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, $t56);
    call $t55 := $WritebackToReference($t56, $t55);
    call $t59 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t67, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 11843, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t59));
    call $t60 := $BorrowField($t59, $LibraAccount_LibraAccount_received_events);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t59);
    call $t62 := $Libra_currency_code_$direct_inter($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_ReceivedPaymentEvent_pack(0, 0, 0, deposit_value, $t62, $t66, $t69);
    $t65 := $tmp;
    call $tmp := $ReadRef($t60);
    $t71 := $tmp;
    call $t71 := $Event_emit_event($LibraAccount_ReceivedPaymentEvent_type_value(), $t71, $t65);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t60 := $WriteRef($t60, $t71);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t60);
    call $t59 := $WritebackToReference($t60, $t59);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t59));
    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_deposit_$verify($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value);
  ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, payee))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) || b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, payee))))) || b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $DesignatedDealer_Dealer_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))))) || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value), $Integer(i#$Integer(old($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value))) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value))))));



implementation $LibraAccount_deposit_$verify($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value)
{
    assume is#$Address(payer);
    assume is#$Address(payee);
    assume $Libra_Libra_is_well_formed(to_deposit);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier860"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    assume $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {:qid "quantifier861"} { $select_vector(metadata_signature, $$0) } $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature, $$0)));
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier862"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier863"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier864"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier865"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier866"} { contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr] } $FixedPoint32_FixedPoint32_is_well_formed(contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier867"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier868"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier869"} { contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr] } $DesignatedDealer_Dealer_is_well_formed(contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier870"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier871"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier872"} { contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Credential_is_well_formed(contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier873"} { contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Limit_is_well_formed(contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier874"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier875"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier876"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier877"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier878"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier879"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_deposit_$def_verify($tv0, payer, payee, to_deposit, metadata, metadata_signature);
}



procedure {:inline 1} $LibraAccount_add_currency_$def($tv0: $TypeValue, account: $Value);



implementation {:inline 1} $LibraAccount_add_currency_$def($tv0: $TypeValue, account: $Value)
{
  var addr: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 31910, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t39 := $tmp;
    call $t9 := $Libra_is_currency($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32035, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t39);
    $t11 := $tmp;
    $tmp := $Integer(14);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 32035, i#$Integer($t12));
    }

    $abort_code := i#$Integer($t12);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t39);
    $t13 := $tmp;
    call $t14 := $Roles_can_hold_balance($t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32170, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t39);
    $t16 := $tmp;
    $tmp := $Integer(4);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 32170, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t39);
    $t18 := $tmp;
    call $t19 := $Signer_address_of($t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t19);
    addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32317, 1, $tmp);
    }

    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);
    $t21 := $tmp;
    call $tmp := $Not($t21);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32361, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $tmp := $CopyOrMoveValue($t39);
    $t24 := $tmp;
    $tmp := $Integer(15);
    $t25 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 32361, i#$Integer($t25));
    }

    $abort_code := i#$Integer($t25);
    goto Abort;

  L4:
    call $tmp := $CopyOrMoveValue($t39);
    $t26 := $tmp;
    call $t27 := $Roles_needs_account_limits($t26);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t27;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    call $t29 := $LibraAccount_has_published_account_limits($tv0, addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t29);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue($t30);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32506, 8, $tmp);
    }

    goto L9;

  L8:
    $tmp := $Boolean(false);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32506, 8, $tmp);
    }

    goto L9;

  L9:
    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L10;
    }
    else
    {
        goto L11;
    }

  L11:
    goto L12;

  L10:
    call $t34 := $VASP_is_vasp(addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t34;
    if (b#$Boolean($tmp))
    {
        goto L13;
    }
    else
    {
        goto L14;
    }

  L14:
    goto L12;

  L13:
    call $tmp := $CopyOrMoveValue($t39);
    $t35 := $tmp;
    call $VASP_add_account_limits($tv0, $t35);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L12;

  L12:
    call $tmp := $CopyOrMoveValue($t39);
    $t36 := $tmp;
    call $t37 := $Libra_zero($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_Balance_pack(0, 0, 0, $tv0, $t37);
    $t38 := $tmp;
    call $LibraAccount_Balance_$memory := $MoveTo($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t38, $t36);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 32812, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_add_currency_$direct_inter($tv0: $TypeValue, account: $Value);



implementation {:inline 1} $LibraAccount_add_currency_$direct_inter($tv0: $TypeValue, account: $Value)
{
    assume is#$Address(account);
    call $LibraAccount_add_currency_$def($tv0, account);
}



procedure {:inline 1} $LibraAccount_add_currency_$direct_intra($tv0: $TypeValue, account: $Value);



implementation {:inline 1} $LibraAccount_add_currency_$direct_intra($tv0: $TypeValue, account: $Value)
{
    assume is#$Address(account);
    call $LibraAccount_add_currency_$def($tv0, account);
}



procedure {:inline 1} $LibraAccount_add_currency($tv0: $TypeValue, account: $Value);



implementation {:inline 1} $LibraAccount_add_currency($tv0: $TypeValue, account: $Value)
{
    assume is#$Address(account);
    call $LibraAccount_add_currency_$def($tv0, account);
}



procedure {:inline 1} $LibraAccount_add_currency_$def_verify($tv0: $TypeValue, account: $Value);



implementation {:inline 1} $LibraAccount_add_currency_$def_verify($tv0: $TypeValue, account: $Value)
{
  var addr: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 31910, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t39 := $tmp;
    call $t9 := $Libra_is_currency_$direct_inter($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32035, 2, $tmp);
    }

    $tmp := $t2;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t39);
    $t11 := $tmp;
    $tmp := $Integer(14);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 32035, i#$Integer($t12));
    }

    $abort_code := i#$Integer($t12);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t39);
    $t13 := $tmp;
    call $t14 := $Roles_can_hold_balance_$direct_inter($t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32170, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t39);
    $t16 := $tmp;
    $tmp := $Integer(4);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 32170, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t39);
    $t18 := $tmp;
    call $t19 := $Signer_address_of_$direct_inter($t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t19);
    addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32317, 1, $tmp);
    }

    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);
    $t21 := $tmp;
    call $tmp := $Not($t21);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32361, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $tmp := $CopyOrMoveValue($t39);
    $t24 := $tmp;
    $tmp := $Integer(15);
    $t25 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 32361, i#$Integer($t25));
    }

    $abort_code := i#$Integer($t25);
    goto Abort;

  L4:
    call $tmp := $CopyOrMoveValue($t39);
    $t26 := $tmp;
    call $t27 := $Roles_needs_account_limits_$direct_inter($t26);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t27;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    call $t29 := $LibraAccount_has_published_account_limits_$direct_intra($tv0, addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t29);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue($t30);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32506, 8, $tmp);
    }

    goto L9;

  L8:
    $tmp := $Boolean(false);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 32506, 8, $tmp);
    }

    goto L9;

  L9:
    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L10;
    }
    else
    {
        goto L11;
    }

  L11:
    goto L12;

  L10:
    call $t34 := $VASP_is_vasp_$direct_inter(addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t34;
    if (b#$Boolean($tmp))
    {
        goto L13;
    }
    else
    {
        goto L14;
    }

  L14:
    goto L12;

  L13:
    call $tmp := $CopyOrMoveValue($t39);
    $t35 := $tmp;
    call $VASP_add_account_limits_$direct_inter($tv0, $t35);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L12;

  L12:
    call $tmp := $CopyOrMoveValue($t39);
    $t36 := $tmp;
    call $t37 := $Libra_zero_$direct_inter($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_Balance_pack(0, 0, 0, $tv0, $t37);
    $t38 := $tmp;
    call $LibraAccount_Balance_$memory := $MoveTo($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t38, $t36);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 32812, $abort_code);
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_add_currency_$verify($tv0: $TypeValue, account: $Value);



implementation $LibraAccount_add_currency_$verify($tv0: $TypeValue, account: $Value)
{
    assume is#$Address(account);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier880"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier881"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier882"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier883"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier884"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier885"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier886"} { contents#$Memory($VASP_VASPOperationsResource_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_VASPOperationsResource_is_well_formed(contents#$Memory($VASP_VASPOperationsResource_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier887"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier888"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier889"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier890"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_add_currency_$def_verify($tv0, account);
}



procedure {:inline 1} $LibraAccount_exists_at_$def(check_addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_exists_at_$def(check_addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 35017, 0, check_addr);
    }

    call $tmp := $CopyOrMoveValue(check_addr);
    $t3 := $tmp;
    $tmp := $ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(16, 35075, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_exists_at_$direct_inter(check_addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_exists_at_$direct_inter(check_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(check_addr);
    call $ret0 := $LibraAccount_exists_at_$def(check_addr);
}



procedure {:inline 1} $LibraAccount_exists_at_$direct_intra(check_addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_exists_at_$direct_intra(check_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(check_addr);
    call $ret0 := $LibraAccount_exists_at_$def(check_addr);
}



procedure {:inline 1} $LibraAccount_exists_at(check_addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_exists_at(check_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(check_addr);
    call $ret0 := $LibraAccount_exists_at_$def(check_addr);
}



procedure {:inline 1} $LibraAccount_exists_at_$def_verify(check_addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_exists_at_$def_verify(check_addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 35017, 0, check_addr);
    }

    call $tmp := $CopyOrMoveValue(check_addr);
    $t3 := $tmp;
    $tmp := $ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(16, 35075, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_exists_at_$verify(check_addr: $Value) returns ($ret0: $Value);



implementation $LibraAccount_exists_at_$verify(check_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(check_addr);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier891"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_exists_at_$def_verify(check_addr);
}



procedure {:inline 1} $LibraAccount_tiered_mint_$def($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value);



implementation {:inline 1} $LibraAccount_tiered_mint_$def($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value)
{
  var coin: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 13896, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 13896, 1, designated_dealer_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 13896, 2, mint_amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 13896, 3, tier_index);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(designated_dealer_address);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(mint_amount);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(tier_index);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    $t5 := $tmp;
    call $t9 := $DesignatedDealer_tiered_mint($tv0, $t5, $t17, $t16, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    coin := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 14131, 4, $tmp);
    }

    call $t10 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t13 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t14 := $tmp;
    call $LibraAccount_deposit($tv0, $t10, $t16, coin, $t13, $t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_tiered_mint_$direct_inter($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value);



implementation {:inline 1} $LibraAccount_tiered_mint_$direct_inter($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(designated_dealer_address);
    assume $IsValidU64(mint_amount);
    assume $IsValidU64(tier_index);
    call $LibraAccount_tiered_mint_$def($tv0, tc_account, designated_dealer_address, mint_amount, tier_index);
}



procedure {:inline 1} $LibraAccount_tiered_mint_$direct_intra($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value);



implementation {:inline 1} $LibraAccount_tiered_mint_$direct_intra($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(designated_dealer_address);
    assume $IsValidU64(mint_amount);
    assume $IsValidU64(tier_index);
    call $LibraAccount_tiered_mint_$def($tv0, tc_account, designated_dealer_address, mint_amount, tier_index);
}



procedure {:inline 1} $LibraAccount_tiered_mint($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value);



implementation {:inline 1} $LibraAccount_tiered_mint($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(designated_dealer_address);
    assume $IsValidU64(mint_amount);
    assume $IsValidU64(tier_index);
    call $LibraAccount_tiered_mint_$def($tv0, tc_account, designated_dealer_address, mint_amount, tier_index);
}



procedure {:inline 1} $LibraAccount_tiered_mint_$def_verify($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value);



implementation {:inline 1} $LibraAccount_tiered_mint_$def_verify($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value)
{
  var coin: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 13896, 0, tc_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 13896, 1, designated_dealer_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 13896, 2, mint_amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 13896, 3, tier_index);
    }

    call $tmp := $CopyOrMoveValue(tc_account);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue(designated_dealer_address);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(mint_amount);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(tier_index);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t15);
    $t5 := $tmp;
    call $t9 := $DesignatedDealer_tiered_mint_$direct_inter($tv0, $t5, $t17, $t16, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    coin := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 14131, 4, $tmp);
    }

    call $t10 := $CoreAddresses_VM_RESERVED_ADDRESS_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t13 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t14 := $tmp;
    call $LibraAccount_deposit_$direct_intra($tv0, $t10, $t16, coin, $t13, $t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_tiered_mint_$verify($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value);



implementation $LibraAccount_tiered_mint_$verify($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value)
{
    assume is#$Address(tc_account);
    assume is#$Address(designated_dealer_address);
    assume $IsValidU64(mint_amount);
    assume $IsValidU64(tier_index);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier892"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier893"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier894"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier895"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier896"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier897"} { contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr] } $FixedPoint32_FixedPoint32_is_well_formed(contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier898"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier899"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier900"} { contents#$Memory($Libra_MintCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_MintCapability_is_well_formed(contents#$Memory($Libra_MintCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier901"} { contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr] } $DesignatedDealer_Dealer_is_well_formed(contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier902"} { contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $DesignatedDealer_TierInfo_is_well_formed(contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier903"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier904"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier905"} { contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Credential_is_well_formed(contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier906"} { contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Limit_is_well_formed(contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier907"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier908"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier909"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier910"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier911"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier912"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_tiered_mint_$def_verify($tv0, tc_account, designated_dealer_address, mint_amount, tier_index);
}



procedure {:inline 1} $LibraAccount_balance_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_balance_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 31312, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t4 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_Balance_$memory, $t4, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 31397, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $t3 := $LibraAccount_balance_for($tv0, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(16, 31385, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_balance_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_balance_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_balance_$def($tv0, addr);
}



procedure {:inline 1} $LibraAccount_balance_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_balance_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_balance_$def($tv0, addr);
}



procedure {:inline 1} $LibraAccount_balance($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_balance($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_balance_$def($tv0, addr);
}



procedure {:inline 1} $LibraAccount_balance_$def_verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_balance_$def_verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 31312, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t4 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_Balance_$memory, $t4, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 31397, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $t3 := $LibraAccount_balance_for_$direct_intra($tv0, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(16, 31385, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_balance_$verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation $LibraAccount_balance_$verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $InitVerification();
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier913"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier914"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    call $ret0 := $LibraAccount_balance_$def_verify($tv0, addr);
}



procedure {:inline 1} $LibraAccount_accepts_currency_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_accepts_currency_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 33303, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(16, 33369, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_accepts_currency_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_accepts_currency_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_accepts_currency_$def($tv0, addr);
}



procedure {:inline 1} $LibraAccount_accepts_currency_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_accepts_currency_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_accepts_currency_$def($tv0, addr);
}



procedure {:inline 1} $LibraAccount_accepts_currency($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_accepts_currency($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_accepts_currency_$def($tv0, addr);
}



procedure {:inline 1} $LibraAccount_accepts_currency_$def_verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_accepts_currency_$def_verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 33303, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t3);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(16, 33369, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_accepts_currency_$verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation $LibraAccount_accepts_currency_$verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $InitVerification();
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier915"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    call $ret0 := $LibraAccount_accepts_currency_$def_verify($tv0, addr);
}



procedure {:inline 1} $LibraAccount_add_currencies_for_account_$def($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_add_currencies_for_account_$def($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value)
{
  var new_account_addr: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 23123, 0, new_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 23123, 1, add_all_currencies);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t3 := $tmp;
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t4);
    new_account_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 23246, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t21);
    $t5 := $tmp;
    call $LibraAccount_add_currency($tv0, $t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t22;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), new_account_addr);
    $t8 := $tmp;
    call $tmp := $Not($t8);
    $t9 := $tmp;
    $tmp := $t9;
    if (b#$Boolean($tmp))
    {
        goto L3;
    }
    else
    {
        goto L4;
    }

  L4:
    goto L5;

  L3:
    call $tmp := $CopyOrMoveValue($t21);
    $t10 := $tmp;
    call $LibraAccount_add_currency($Coin1_Coin1_type_value(), $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L5;

  L5:
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin2_Coin2_type_value()], 1), new_account_addr);
    $t12 := $tmp;
    call $tmp := $Not($t12);
    $t13 := $tmp;
    $tmp := $t13;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    call $tmp := $CopyOrMoveValue($t21);
    $t14 := $tmp;
    call $LibraAccount_add_currency($Coin2_Coin2_type_value(), $t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L8;

  L8:
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), new_account_addr);
    $t16 := $tmp;
    call $tmp := $Not($t16);
    $t17 := $tmp;
    $tmp := $t17;
    if (b#$Boolean($tmp))
    {
        goto L9;
    }
    else
    {
        goto L10;
    }

  L10:
    goto L11;

  L9:
    call $tmp := $CopyOrMoveValue($t21);
    $t18 := $tmp;
    call $LibraAccount_add_currency($LBR_LBR_type_value(), $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L12;

  L11:
    call $tmp := $CopyOrMoveValue($t21);
    $t19 := $tmp;
    goto L12;

  L12:
    goto L13;

  L2:
    call $tmp := $CopyOrMoveValue($t21);
    $t20 := $tmp;
    goto L13;

  L13:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_add_currencies_for_account_$direct_intra($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_add_currencies_for_account_$direct_intra($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value)
{
    assume is#$Address(new_account);
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_add_currencies_for_account_$def($tv0, new_account, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_add_currencies_for_account($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_add_currencies_for_account($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value)
{
    assume is#$Address(new_account);
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_add_currencies_for_account_$def($tv0, new_account, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_add_currencies_for_account_$def_verify($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_add_currencies_for_account_$def_verify($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value)
{
  var new_account_addr: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 23123, 0, new_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 23123, 1, add_all_currencies);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t21);
    $t3 := $tmp;
    call $t4 := $Signer_address_of_$direct_inter($t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t4);
    new_account_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 23246, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t21);
    $t5 := $tmp;
    call $LibraAccount_add_currency_$direct_intra($tv0, $t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t22;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), new_account_addr);
    $t8 := $tmp;
    call $tmp := $Not($t8);
    $t9 := $tmp;
    $tmp := $t9;
    if (b#$Boolean($tmp))
    {
        goto L3;
    }
    else
    {
        goto L4;
    }

  L4:
    goto L5;

  L3:
    call $tmp := $CopyOrMoveValue($t21);
    $t10 := $tmp;
    call $LibraAccount_add_currency_$direct_intra($Coin1_Coin1_type_value(), $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L5;

  L5:
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin2_Coin2_type_value()], 1), new_account_addr);
    $t12 := $tmp;
    call $tmp := $Not($t12);
    $t13 := $tmp;
    $tmp := $t13;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    call $tmp := $CopyOrMoveValue($t21);
    $t14 := $tmp;
    call $LibraAccount_add_currency_$direct_intra($Coin2_Coin2_type_value(), $t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L8;

  L8:
    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), new_account_addr);
    $t16 := $tmp;
    call $tmp := $Not($t16);
    $t17 := $tmp;
    $tmp := $t17;
    if (b#$Boolean($tmp))
    {
        goto L9;
    }
    else
    {
        goto L10;
    }

  L10:
    goto L11;

  L9:
    call $tmp := $CopyOrMoveValue($t21);
    $t18 := $tmp;
    call $LibraAccount_add_currency_$direct_intra($LBR_LBR_type_value(), $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L12;

  L11:
    call $tmp := $CopyOrMoveValue($t21);
    $t19 := $tmp;
    goto L12;

  L12:
    goto L13;

  L2:
    call $tmp := $CopyOrMoveValue($t21);
    $t20 := $tmp;
    goto L13;

  L13:
    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_add_currencies_for_account_$verify($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value);



implementation $LibraAccount_add_currencies_for_account_$verify($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value)
{
    assume is#$Address(new_account);
    assume is#$Boolean(add_all_currencies);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier916"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier917"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier918"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier919"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier920"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier921"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier922"} { contents#$Memory($VASP_VASPOperationsResource_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_VASPOperationsResource_is_well_formed(contents#$Memory($VASP_VASPOperationsResource_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier923"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier924"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier925"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier926"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_add_currencies_for_account_$def_verify($tv0, new_account, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_authentication_key_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_authentication_key_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 33847, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_LibraAccount_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 33938, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_authentication_key);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(16, 33936, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_authentication_key_$direct_inter(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_authentication_key_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_authentication_key_$def(addr);
}



procedure {:inline 1} $LibraAccount_authentication_key_$direct_intra(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_authentication_key_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_authentication_key_$def(addr);
}



procedure {:inline 1} $LibraAccount_authentication_key(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_authentication_key(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_authentication_key_$def(addr);
}



procedure {:inline 1} $LibraAccount_authentication_key_$def_verify(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_authentication_key_$def_verify(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 33847, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_LibraAccount_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 33938, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_authentication_key);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(16, 33936, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_authentication_key_$verify(addr: $Value) returns ($ret0: $Value);



implementation $LibraAccount_authentication_key_$verify(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier927"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_authentication_key_$def_verify(addr);
}



procedure {:inline 1} $LibraAccount_balance_for_$def($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_balance_for_$def($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 31141, 0, balance);
    }

    call $tmp := $CopyOrMoveValue(balance);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_Balance_coin);
    $t2 := $tmp;
    call $t3 := $Libra_value($tv0, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(16, 31205, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_balance_for_$direct_intra($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_balance_for_$direct_intra($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_Balance_is_well_formed(balance);
    call $ret0 := $LibraAccount_balance_for_$def($tv0, balance);
}



procedure {:inline 1} $LibraAccount_balance_for($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_balance_for($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_Balance_is_well_formed(balance);
    call $ret0 := $LibraAccount_balance_for_$def($tv0, balance);
}



procedure {:inline 1} $LibraAccount_balance_for_$def_verify($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_balance_for_$def_verify($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 31141, 0, balance);
    }

    call $tmp := $CopyOrMoveValue(balance);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_Balance_coin);
    $t2 := $tmp;
    call $t3 := $Libra_value_$direct_inter($tv0, $t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(16, 31205, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_balance_for_$verify($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value);



implementation $LibraAccount_balance_for_$verify($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_Balance_is_well_formed(balance);
    call $InitVerification();
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier928"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier929"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    call $ret0 := $LibraAccount_balance_for_$def_verify($tv0, balance);
}



procedure {:inline 1} $LibraAccount_bump_sequence_number_$def(signer: $Value);



implementation {:inline 1} $LibraAccount_bump_sequence_number_$def(signer: $Value)
{
  var sender_account: $Mutation;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Mutation;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Mutation;
  var $t12: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 40161, 0, signer);
    }

    call $tmp := $CopyOrMoveValue(signer);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t2 := $tmp;
    call $t3 := $Signer_address_of($t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t4 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 40256, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t4));
    call sender_account := $CopyOrMoveRef($t4);
    if (true)
    {
        assume $DebugTrackLocal(16, 40239, 1, $Dereference(sender_account));
    }

    call $t5 := $CopyOrMoveRef(sender_account);
    call $tmp := $GetFieldFromReference($t5, $LibraAccount_LibraAccount_sequence_number);
    $t6 := $tmp;
    call sender_account := $WritebackToReference($t5, sender_account);
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    $tmp := $Integer(1);
    $t8 := $tmp;
    call $tmp := $AddU64($t7, $t8);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 40389, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $t10 := $CopyOrMoveRef(sender_account);
    call $t11 := $BorrowField($t10, $LibraAccount_LibraAccount_sequence_number);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t10);
    call $t11 := $WriteRef($t11, $t9);
    if (true)
    {
        assume $DebugTrackLocal(16, 40325, 1, $Dereference(sender_account));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t11);
    call $t10 := $WritebackToReference($t11, $t10);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t10));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_bump_sequence_number_$direct_intra(signer: $Value);



implementation {:inline 1} $LibraAccount_bump_sequence_number_$direct_intra(signer: $Value)
{
    assume is#$Address(signer);
    call $LibraAccount_bump_sequence_number_$def(signer);
}



procedure {:inline 1} $LibraAccount_bump_sequence_number(signer: $Value);



implementation {:inline 1} $LibraAccount_bump_sequence_number(signer: $Value)
{
    assume is#$Address(signer);
    call $LibraAccount_bump_sequence_number_$def(signer);
}



procedure {:inline 1} $LibraAccount_bump_sequence_number_$def_verify(signer: $Value);



implementation {:inline 1} $LibraAccount_bump_sequence_number_$def_verify(signer: $Value)
{
  var sender_account: $Mutation;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Mutation;
  var $t5: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Mutation;
  var $t12: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 40161, 0, signer);
    }

    call $tmp := $CopyOrMoveValue(signer);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t2 := $tmp;
    call $t3 := $Signer_address_of_$direct_inter($t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t4 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 40256, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t4));
    call sender_account := $CopyOrMoveRef($t4);
    if (true)
    {
        assume $DebugTrackLocal(16, 40239, 1, $Dereference(sender_account));
    }

    call $t5 := $CopyOrMoveRef(sender_account);
    call $tmp := $GetFieldFromReference($t5, $LibraAccount_LibraAccount_sequence_number);
    $t6 := $tmp;
    call sender_account := $WritebackToReference($t5, sender_account);
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    $tmp := $Integer(1);
    $t8 := $tmp;
    call $tmp := $AddU64($t7, $t8);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 40389, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $t10 := $CopyOrMoveRef(sender_account);
    call $t11 := $BorrowField($t10, $LibraAccount_LibraAccount_sequence_number);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t10);
    call $t11 := $WriteRef($t11, $t9);
    if (true)
    {
        assume $DebugTrackLocal(16, 40325, 1, $Dereference(sender_account));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t11);
    call $t10 := $WritebackToReference($t11, $t10);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t10));
    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_bump_sequence_number_$verify(signer: $Value);



implementation $LibraAccount_bump_sequence_number_$verify(signer: $Value)
{
    assume is#$Address(signer);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier930"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $LibraAccount_bump_sequence_number_$def_verify(signer);
}



procedure {:inline 1} $LibraAccount_create_child_vasp_account_$def($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_child_vasp_account_$def($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value)
{
  var new_account: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 29998, 0, parent);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 29998, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 29998, 2, auth_key_prefix);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 29998, 3, add_all_currencies);
    }

    call $tmp := $CopyOrMoveValue(parent);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t19 := $tmp;
    call $t6 := $LibraAccount_create_signer($t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 30197, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t16);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t8 := $tmp;
    call $Roles_new_child_vasp_role($t7, $t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t10 := $tmp;
    call $VASP_publish_child_vasp_credential($t9, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t11 := $tmp;
    call $Event_publish_generator($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t12 := $tmp;
    call $LibraAccount_add_currencies_for_account($tv0, $t12, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account(new_account, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_create_child_vasp_account_$direct_inter($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, new_account_address)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, new_account_address))));



implementation {:inline 1} $LibraAccount_create_child_vasp_account_$direct_inter($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value)
{
    assume is#$Address(parent);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier931"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_create_child_vasp_account_$def($tv0, parent, new_account_address, auth_key_prefix, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_child_vasp_account_$direct_intra($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_child_vasp_account_$direct_intra($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value)
{
    assume is#$Address(parent);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier932"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_create_child_vasp_account_$def($tv0, parent, new_account_address, auth_key_prefix, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_child_vasp_account($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_child_vasp_account($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value)
{
    assume is#$Address(parent);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier933"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_create_child_vasp_account_$def($tv0, parent, new_account_address, auth_key_prefix, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_child_vasp_account_$def_verify($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_child_vasp_account_$def_verify($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value)
{
  var new_account: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 29998, 0, parent);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 29998, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 29998, 2, auth_key_prefix);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 29998, 3, add_all_currencies);
    }

    call $tmp := $CopyOrMoveValue(parent);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t19 := $tmp;
    call $t6 := $LibraAccount_create_signer($t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 30197, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t16);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t8 := $tmp;
    call $Roles_new_child_vasp_role_$direct_inter($t7, $t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t10 := $tmp;
    call $VASP_publish_child_vasp_credential_$direct_inter($t9, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t11 := $tmp;
    call $Event_publish_generator($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t12 := $tmp;
    call $LibraAccount_add_currencies_for_account_$direct_intra($tv0, $t12, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account_$direct_intra(new_account, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_create_child_vasp_account_$verify($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, new_account_address)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, new_account_address))));



implementation $LibraAccount_create_child_vasp_account_$verify($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value)
{
    assume is#$Address(parent);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier934"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier935"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier936"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier937"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier938"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier939"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier940"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier941"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier942"} { contents#$Memory($VASP_VASPOperationsResource_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_VASPOperationsResource_is_well_formed(contents#$Memory($VASP_VASPOperationsResource_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier943"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier944"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier945"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier946"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier947"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_create_child_vasp_account_$def_verify($tv0, parent, new_account_address, auth_key_prefix, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_designated_dealer_$def($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_designated_dealer_$def($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
  var new_dd_account: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 27295, 0, creator_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 27295, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 27295, 2, auth_key_prefix);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 27295, 3, human_name);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 27295, 4, base_url);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 27295, 5, compliance_public_key);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 27295, 6, add_all_currencies);
    }

    call $tmp := $CopyOrMoveValue(creator_account);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t26 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t27 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t28 := $tmp;
    call $tmp := $CopyOrMoveValue(base_url);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(compliance_public_key);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t31 := $tmp;
    call $t9 := $LibraAccount_create_signer($t26);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    new_dd_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 27610, 7, $tmp);
    }

    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t10 := $tmp;
    call $Event_publish_generator($t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t25);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t12 := $tmp;
    call $Roles_new_designated_dealer_role($t11, $t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t25);
    $t14 := $tmp;
    call $DesignatedDealer_publish_designated_dealer_credential($tv0, $t13, $t14, $t31);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t16 := $tmp;
    call $LibraAccount_add_currencies_for_account($tv0, $t16, $t31);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t25);
    $t19 := $tmp;
    call $DualAttestation_publish_credential($t18, $t19, $t28, $t29, $t30);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account(new_dd_account, $t27);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_create_designated_dealer_$direct_inter($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_designated_dealer_$direct_inter($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier948"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier949"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier950"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier951"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_create_designated_dealer_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, base_url, compliance_public_key, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_designated_dealer_$direct_intra($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_designated_dealer_$direct_intra($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier952"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier953"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier954"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier955"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_create_designated_dealer_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, base_url, compliance_public_key, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_designated_dealer($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_designated_dealer($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier956"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier957"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier958"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier959"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_create_designated_dealer_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, base_url, compliance_public_key, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_libra_root_account_$def(new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_libra_root_account_$def(new_account_address: $Value, auth_key_prefix: $Value)
{
  var new_account: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 25702, 0, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 25702, 1, auth_key_prefix);
    }

    call $tmp := $CopyOrMoveValue(new_account_address);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t22 := $tmp;
    call $t7 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 25831, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(0);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 25831, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t21, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 25891, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(1);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 25891, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L2:
    call $t16 := $LibraAccount_create_signer($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t16);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 25999, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t18 := $tmp;
    call $SlidingNonce_publish_nonce_resource($t17, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account(new_account, $t22);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_create_libra_root_account_$direct_inter(new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_libra_root_account_$direct_inter(new_account_address: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier960"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $LibraAccount_create_libra_root_account_$def(new_account_address, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_create_libra_root_account_$direct_intra(new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_libra_root_account_$direct_intra(new_account_address: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier961"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $LibraAccount_create_libra_root_account_$def(new_account_address, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_create_libra_root_account(new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_libra_root_account(new_account_address: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier962"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $LibraAccount_create_libra_root_account_$def(new_account_address, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_create_libra_root_account_$def_verify(new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_libra_root_account_$def_verify(new_account_address: $Value, auth_key_prefix: $Value)
{
  var new_account: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 25702, 0, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 25702, 1, auth_key_prefix);
    }

    call $tmp := $CopyOrMoveValue(new_account_address);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t22 := $tmp;
    call $t7 := $LibraTimestamp_is_genesis_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 25831, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(0);
    $t9 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 25831, i#$Integer($t9));
    }

    $abort_code := i#$Integer($t9);
    goto Abort;

  L0:
    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t21, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 25891, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(1);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 25891, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L2:
    call $t16 := $LibraAccount_create_signer($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t16);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 25999, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t18 := $tmp;
    call $SlidingNonce_publish_nonce_resource_$direct_inter($t17, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account_$direct_intra(new_account, $t22);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_create_libra_root_account_$verify(new_account_address: $Value, auth_key_prefix: $Value);



implementation $LibraAccount_create_libra_root_account_$verify(new_account_address: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier963"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier964"} { contents#$Memory($LibraTimestamp_TimeHasStarted_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_TimeHasStarted_is_well_formed(contents#$Memory($LibraTimestamp_TimeHasStarted_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier965"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier966"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier967"} { contents#$Memory($SlidingNonce_SlidingNonce_$memory)[$EmptyTypeValueArray, $inv_addr] } $SlidingNonce_SlidingNonce_is_well_formed(contents#$Memory($SlidingNonce_SlidingNonce_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier968"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier969"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_create_libra_root_account_$def_verify(new_account_address, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_create_parent_vasp_account_$def($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_parent_vasp_account_$def($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
  var new_account: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 0, creator_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 2, auth_key_prefix);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 3, human_name);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 4, base_url);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 5, compliance_public_key);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 6, add_all_currencies);
    }

    call $tmp := $CopyOrMoveValue(creator_account);
    $t24 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t26 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t27 := $tmp;
    call $tmp := $CopyOrMoveValue(base_url);
    $t28 := $tmp;
    call $tmp := $CopyOrMoveValue(compliance_public_key);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t30 := $tmp;
    call $t9 := $LibraAccount_create_signer($t25);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 29097, 7, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t24);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t11 := $tmp;
    call $Roles_new_parent_vasp_role($t10, $t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t24);
    $t13 := $tmp;
    call $VASP_publish_parent_vasp_credential($t12, $t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t24);
    $t15 := $tmp;
    call $DualAttestation_publish_credential($t14, $t15, $t27, $t28, $t29);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t19 := $tmp;
    call $Event_publish_generator($t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t20 := $tmp;
    call $LibraAccount_add_currencies_for_account($tv0, $t20, $t30);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account(new_account, $t26);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_create_parent_vasp_account_$direct_inter($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_parent_vasp_account_$direct_inter($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier970"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier971"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier972"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier973"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_create_parent_vasp_account_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, base_url, compliance_public_key, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_parent_vasp_account_$direct_intra($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_parent_vasp_account_$direct_intra($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier974"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier975"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier976"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier977"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_create_parent_vasp_account_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, base_url, compliance_public_key, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_parent_vasp_account($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_parent_vasp_account($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier978"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier979"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier980"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier981"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $LibraAccount_create_parent_vasp_account_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, base_url, compliance_public_key, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_parent_vasp_account_$def_verify($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation {:inline 1} $LibraAccount_create_parent_vasp_account_$def_verify($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
  var new_account: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 0, creator_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 2, auth_key_prefix);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 3, human_name);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 4, base_url);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 5, compliance_public_key);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 28769, 6, add_all_currencies);
    }

    call $tmp := $CopyOrMoveValue(creator_account);
    $t24 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t26 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t27 := $tmp;
    call $tmp := $CopyOrMoveValue(base_url);
    $t28 := $tmp;
    call $tmp := $CopyOrMoveValue(compliance_public_key);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t30 := $tmp;
    call $t9 := $LibraAccount_create_signer($t25);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 29097, 7, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t24);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t11 := $tmp;
    call $Roles_new_parent_vasp_role_$direct_inter($t10, $t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t24);
    $t13 := $tmp;
    call $VASP_publish_parent_vasp_credential_$direct_inter($t12, $t13);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t24);
    $t15 := $tmp;
    call $DualAttestation_publish_credential_$direct_inter($t14, $t15, $t27, $t28, $t29);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t19 := $tmp;
    call $Event_publish_generator($t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t20 := $tmp;
    call $LibraAccount_add_currencies_for_account_$direct_intra($tv0, $t20, $t30);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account_$direct_intra(new_account, $t26);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_create_parent_vasp_account_$verify($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value);



implementation $LibraAccount_create_parent_vasp_account_$verify($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier982"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier983"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {:qid "quantifier984"} { $select_vector(base_url, $$0) } $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url, $$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {:qid "quantifier985"} { $select_vector(compliance_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key, $$0)));
    assume is#$Boolean(add_all_currencies);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier986"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier987"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier988"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier989"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier990"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier991"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier992"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier993"} { contents#$Memory($VASP_VASPOperationsResource_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_VASPOperationsResource_is_well_formed(contents#$Memory($VASP_VASPOperationsResource_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier994"} { contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Credential_is_well_formed(contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier995"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier996"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier997"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier998"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier999"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_create_parent_vasp_account_$def_verify($tv0, creator_account, new_account_address, auth_key_prefix, human_name, base_url, compliance_public_key, add_all_currencies);
}



procedure {:inline 1} $LibraAccount_create_treasury_compliance_account_$def(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_treasury_compliance_account_$def(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value)
{
  var new_account: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 26329, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 26329, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 26329, 2, auth_key_prefix);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t24 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t26 := $tmp;
    call $t8 := $LibraTimestamp_is_genesis();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 26496, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t24);
    $t10 := $tmp;
    $tmp := $Integer(0);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 26496, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t24);
    $t12 := $tmp;
    call $t13 := $Roles_has_libra_root_role($t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 26556, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t24);
    $t15 := $tmp;
    $tmp := $Integer(11);
    $t16 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 26556, i#$Integer($t16));
    }

    $abort_code := i#$Integer($t16);
    goto Abort;

  L2:
    call $t18 := $LibraAccount_create_signer($t25);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t18);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 26633, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t24);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t20 := $tmp;
    call $SlidingNonce_publish_nonce_resource($t19, $t20);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t21 := $tmp;
    call $Event_publish_generator($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account(new_account, $t26);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_create_treasury_compliance_account_$direct_inter(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_treasury_compliance_account_$direct_inter(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1000"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $LibraAccount_create_treasury_compliance_account_$def(lr_account, new_account_address, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_create_treasury_compliance_account_$direct_intra(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_treasury_compliance_account_$direct_intra(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1001"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $LibraAccount_create_treasury_compliance_account_$def(lr_account, new_account_address, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_create_treasury_compliance_account(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_treasury_compliance_account(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1002"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $LibraAccount_create_treasury_compliance_account_$def(lr_account, new_account_address, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_create_treasury_compliance_account_$def_verify(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_create_treasury_compliance_account_$def_verify(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value)
{
  var new_account: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 26329, 0, lr_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 26329, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 26329, 2, auth_key_prefix);
    }

    call $tmp := $CopyOrMoveValue(lr_account);
    $t24 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t25 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t26 := $tmp;
    call $t8 := $LibraTimestamp_is_genesis_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 26496, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t24);
    $t10 := $tmp;
    $tmp := $Integer(0);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 26496, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t24);
    $t12 := $tmp;
    call $t13 := $Roles_has_libra_root_role_$direct_inter($t12);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 26556, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    call $tmp := $CopyOrMoveValue($t24);
    $t15 := $tmp;
    $tmp := $Integer(11);
    $t16 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 26556, i#$Integer($t16));
    }

    $abort_code := i#$Integer($t16);
    goto Abort;

  L2:
    call $t18 := $LibraAccount_create_signer($t25);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t18);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 26633, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t24);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account);
    $t20 := $tmp;
    call $SlidingNonce_publish_nonce_resource_$direct_inter($t19, $t20);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t21 := $tmp;
    call $Event_publish_generator($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account_$direct_intra(new_account, $t26);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_create_treasury_compliance_account_$verify(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value);



implementation $LibraAccount_create_treasury_compliance_account_$verify(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(lr_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1003"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1004"} { contents#$Memory($LibraTimestamp_TimeHasStarted_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_TimeHasStarted_is_well_formed(contents#$Memory($LibraTimestamp_TimeHasStarted_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1005"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1006"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1007"} { contents#$Memory($SlidingNonce_SlidingNonce_$memory)[$EmptyTypeValueArray, $inv_addr] } $SlidingNonce_SlidingNonce_is_well_formed(contents#$Memory($SlidingNonce_SlidingNonce_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1008"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_spec_is_up($LibraTimestamp_TimeHasStarted_$memory)) ==> b#$Boolean($ResourceExists($VASP_VASPOperationsResource_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1009"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_create_treasury_compliance_account_$def_verify(lr_account, new_account_address, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_create_validator_account_$def(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_account_$def(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
  var new_account: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 40653, 0, creator_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 40653, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 40653, 2, auth_key_prefix);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 40653, 3, human_name);
    }

    call $tmp := $CopyOrMoveValue(creator_account);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t7 := $tmp;
    call $t8 := $Roles_has_libra_root_role($t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 40847, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t20);
    $t10 := $tmp;
    $tmp := $Integer(11);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 40847, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $t13 := $LibraAccount_create_signer($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 40929, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t14 := $tmp;
    call $Event_publish_generator($t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t16 := $tmp;
    call $ValidatorConfig_publish($t15, $t16, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account(new_account, $t22);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_create_validator_account_$direct_inter(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_account_$direct_inter(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1010"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier1011"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $LibraAccount_create_validator_account_$def(creator_account, new_account_address, auth_key_prefix, human_name);
}



procedure {:inline 1} $LibraAccount_create_validator_account_$direct_intra(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_account_$direct_intra(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1012"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier1013"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $LibraAccount_create_validator_account_$def(creator_account, new_account_address, auth_key_prefix, human_name);
}



procedure {:inline 1} $LibraAccount_create_validator_account(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_account(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1014"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier1015"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $LibraAccount_create_validator_account_$def(creator_account, new_account_address, auth_key_prefix, human_name);
}



procedure {:inline 1} $LibraAccount_create_validator_account_$def_verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_account_$def_verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
  var new_account: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 40653, 0, creator_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 40653, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 40653, 2, auth_key_prefix);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 40653, 3, human_name);
    }

    call $tmp := $CopyOrMoveValue(creator_account);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t7 := $tmp;
    call $t8 := $Roles_has_libra_root_role_$direct_inter($t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 40847, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t20);
    $t10 := $tmp;
    $tmp := $Integer(11);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 40847, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $t13 := $LibraAccount_create_signer($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 40929, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t14 := $tmp;
    call $Event_publish_generator($t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t16 := $tmp;
    call $ValidatorConfig_publish_$direct_inter($t15, $t16, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account_$direct_intra(new_account, $t22);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_create_validator_account_$verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation $LibraAccount_create_validator_account_$verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1016"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier1017"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1018"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1019"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1020"} { contents#$Memory($ValidatorConfig_ValidatorConfig_$memory)[$EmptyTypeValueArray, $inv_addr] } $ValidatorConfig_ValidatorConfig_is_well_formed(contents#$Memory($ValidatorConfig_ValidatorConfig_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1021"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1022"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_create_validator_account_$def_verify(creator_account, new_account_address, auth_key_prefix, human_name);
}



procedure {:inline 1} $LibraAccount_create_validator_operator_account_$def(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_operator_account_$def(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
  var new_account: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 41166, 0, creator_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 41166, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 41166, 2, auth_key_prefix);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 41166, 3, human_name);
    }

    call $tmp := $CopyOrMoveValue(creator_account);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t7 := $tmp;
    call $t8 := $Roles_has_libra_root_role($t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 41369, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t20);
    $t10 := $tmp;
    $tmp := $Integer(11);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 41369, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $t13 := $LibraAccount_create_signer($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 41451, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t14 := $tmp;
    call $Event_publish_generator($t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t16 := $tmp;
    call $ValidatorOperatorConfig_publish($t15, $t16, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account(new_account, $t22);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_create_validator_operator_account_$direct_inter(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_operator_account_$direct_inter(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1023"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier1024"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $LibraAccount_create_validator_operator_account_$def(creator_account, new_account_address, auth_key_prefix, human_name);
}



procedure {:inline 1} $LibraAccount_create_validator_operator_account_$direct_intra(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_operator_account_$direct_intra(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1025"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier1026"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $LibraAccount_create_validator_operator_account_$def(creator_account, new_account_address, auth_key_prefix, human_name);
}



procedure {:inline 1} $LibraAccount_create_validator_operator_account(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_operator_account(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1027"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier1028"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $LibraAccount_create_validator_operator_account_$def(creator_account, new_account_address, auth_key_prefix, human_name);
}



procedure {:inline 1} $LibraAccount_create_validator_operator_account_$def_verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation {:inline 1} $LibraAccount_create_validator_operator_account_$def_verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
  var new_account: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 41166, 0, creator_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 41166, 1, new_account_address);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 41166, 2, auth_key_prefix);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 41166, 3, human_name);
    }

    call $tmp := $CopyOrMoveValue(creator_account);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue(human_name);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t7 := $tmp;
    call $t8 := $Roles_has_libra_root_role_$direct_inter($t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 41369, 5, $tmp);
    }

    $tmp := $t5;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $tmp := $CopyOrMoveValue($t20);
    $t10 := $tmp;
    $tmp := $Integer(11);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 41369, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $t13 := $LibraAccount_create_signer($t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t13);
    new_account := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 41451, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t14 := $tmp;
    call $Event_publish_generator($t14);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t15 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t16 := $tmp;
    call $ValidatorOperatorConfig_publish_$direct_inter($t15, $t16, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_make_account_$direct_intra(new_account, $t22);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_create_validator_operator_account_$verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value);



implementation $LibraAccount_create_validator_operator_account_$verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value)
{
    assume is#$Address(creator_account);
    assume is#$Address(new_account_address);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1029"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {:qid "quantifier1030"} { $select_vector(human_name, $$0) } $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name, $$0)));
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1031"} { contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr] } $Roles_RoleId_is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1032"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1033"} { contents#$Memory($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory)[$EmptyTypeValueArray, $inv_addr] } $ValidatorOperatorConfig_ValidatorOperatorConfig_is_well_formed(contents#$Memory($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1034"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1035"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_create_validator_operator_account_$def_verify(creator_account, new_account_address, auth_key_prefix, human_name);
}



procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_key_rotation_capability_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 34089, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_LibraAccount_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 34208, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_key_rotation_capability);
    $t3 := $tmp;
    call $t4 := $Option_is_none($LibraAccount_KeyRotationCapability_type_value(), $t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(16, 34191, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability_$direct_inter(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_key_rotation_capability_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_delegated_key_rotation_capability_$def(addr);
}



procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability_$direct_intra(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_key_rotation_capability_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_delegated_key_rotation_capability_$def(addr);
}



procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_key_rotation_capability(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_delegated_key_rotation_capability_$def(addr);
}



procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability_$def_verify(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_key_rotation_capability_$def_verify(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 34089, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_LibraAccount_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 34208, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_key_rotation_capability);
    $t3 := $tmp;
    call $t4 := $Option_is_none_$direct_inter($LibraAccount_KeyRotationCapability_type_value(), $t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(16, 34191, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_delegated_key_rotation_capability_$verify(addr: $Value) returns ($ret0: $Value);



implementation $LibraAccount_delegated_key_rotation_capability_$verify(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $InitVerification();
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1036"} { contents#$Memory($Option_Option_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Option_Option_is_well_formed(contents#$Memory($Option_Option_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1037"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_delegated_key_rotation_capability_$def_verify(addr);
}



procedure {:inline 1} $LibraAccount_delegated_withdraw_capability_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_withdraw_capability_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 34361, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_LibraAccount_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 34476, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_withdrawal_capability);
    $t3 := $tmp;
    call $t4 := $Option_is_none($LibraAccount_WithdrawCapability_type_value(), $t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(16, 34459, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_delegated_withdraw_capability_$direct_inter(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_withdraw_capability_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_delegated_withdraw_capability_$def(addr);
}



procedure {:inline 1} $LibraAccount_delegated_withdraw_capability_$direct_intra(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_withdraw_capability_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_delegated_withdraw_capability_$def(addr);
}



procedure {:inline 1} $LibraAccount_delegated_withdraw_capability(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_withdraw_capability(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_delegated_withdraw_capability_$def(addr);
}



procedure {:inline 1} $LibraAccount_delegated_withdraw_capability_$def_verify(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_delegated_withdraw_capability_$def_verify(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 34361, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_LibraAccount_$memory, $t5, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 34476, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_withdrawal_capability);
    $t3 := $tmp;
    call $t4 := $Option_is_none_$direct_inter($LibraAccount_WithdrawCapability_type_value(), $t3);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t4;
    if (true)
    {
        assume $DebugTrackLocal(16, 34459, 6, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_delegated_withdraw_capability_$verify(addr: $Value) returns ($ret0: $Value);



implementation $LibraAccount_delegated_withdraw_capability_$verify(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $InitVerification();
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1038"} { contents#$Memory($Option_Option_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Option_Option_is_well_formed(contents#$Memory($Option_Option_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1039"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_delegated_withdraw_capability_$def_verify(addr);
}



procedure {:inline 1} $LibraAccount_epilogue_$def($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value);



implementation {:inline 1} $LibraAccount_epilogue_$def($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value)
{
  var sender_account: $Mutation;
  var sender_balance: $Mutation;
  var $t5: $Value;
  var $t6: $Mutation;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Mutation;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Mutation;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 37584, 0, sender);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 37584, 1, transaction_fee_amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 37584, 2, txn_sequence_number);
    }

    call $tmp := $CopyOrMoveValue(sender);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue(transaction_fee_amount);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t24 := $tmp;
    call $t6 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t22, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 37869, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t6));
    call sender_account := $CopyOrMoveRef($t6);
    if (true)
    {
        assume $DebugTrackLocal(16, 37852, 3, $Dereference(sender_account));
    }

    $tmp := $Integer(1);
    $t8 := $tmp;
    call $tmp := $AddU64($t24, $t8);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 38008, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $t10 := $CopyOrMoveRef(sender_account);
    call $t11 := $BorrowField($t10, $LibraAccount_LibraAccount_sequence_number);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t10);
    call $t11 := $WriteRef($t11, $t9);
    if (true)
    {
        assume $DebugTrackLocal(16, 37955, 3, $Dereference(sender_account));
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 37955, 4, $Dereference(sender_balance));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t11);
    call $t10 := $WritebackToReference($t11, $t10);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t10));
    $tmp := $Integer(0);
    $t13 := $tmp;
    call $tmp := $Gt($t23, $t13);
    $t14 := $tmp;
    $tmp := $t14;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t16 := $BorrowGlobal($LibraAccount_Balance_$memory, $t22, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 38089, $abort_code);
        goto Abort;
    }

    call sender_balance := $CopyOrMoveRef($t16);
    if (true)
    {
        assume $DebugTrackLocal(16, 38072, 4, $Dereference(sender_balance));
    }

    call $t18 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $CopyOrMoveRef(sender_balance);
    call $tmp := $ReadRef($t19);
    $t25 := $tmp;
    call $t21, $t25 := $LibraAccount_withdraw_from_balance($tv0, $t22, $t18, $t25, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $WriteRef($t19, $t25);
    if (true)
    {
        assume $DebugTrackLocal(16, 38022, 3, $Dereference(sender_account));
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38022, 4, $Dereference(sender_balance));
    }

    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, $t19);
    call $TransactionFee_pay_fee($tv0, $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L2;

  L2:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_epilogue_$direct_intra($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value);



implementation {:inline 1} $LibraAccount_epilogue_$direct_intra($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value)
{
    assume is#$Address(sender);
    assume $IsValidU64(transaction_fee_amount);
    assume $IsValidU64(txn_sequence_number);
    call $LibraAccount_epilogue_$def($tv0, sender, transaction_fee_amount, txn_sequence_number);
}



procedure {:inline 1} $LibraAccount_epilogue($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value);



implementation {:inline 1} $LibraAccount_epilogue($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value)
{
    assume is#$Address(sender);
    assume $IsValidU64(transaction_fee_amount);
    assume $IsValidU64(txn_sequence_number);
    call $LibraAccount_epilogue_$def($tv0, sender, transaction_fee_amount, txn_sequence_number);
}



procedure {:inline 1} $LibraAccount_epilogue_$def_verify($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value);



implementation {:inline 1} $LibraAccount_epilogue_$def_verify($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value)
{
  var sender_account: $Mutation;
  var sender_balance: $Mutation;
  var $t5: $Value;
  var $t6: $Mutation;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Mutation;
  var $t11: $Mutation;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Mutation;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 37584, 0, sender);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 37584, 1, transaction_fee_amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 37584, 2, txn_sequence_number);
    }

    call $tmp := $CopyOrMoveValue(sender);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue(transaction_fee_amount);
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t24 := $tmp;
    call $t6 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t22, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 37869, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t6));
    call sender_account := $CopyOrMoveRef($t6);
    if (true)
    {
        assume $DebugTrackLocal(16, 37852, 3, $Dereference(sender_account));
    }

    $tmp := $Integer(1);
    $t8 := $tmp;
    call $tmp := $AddU64($t24, $t8);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 38008, $abort_code);
        goto Abort;
    }

    $t9 := $tmp;
    call $t10 := $CopyOrMoveRef(sender_account);
    call $t11 := $BorrowField($t10, $LibraAccount_LibraAccount_sequence_number);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t10);
    call $t11 := $WriteRef($t11, $t9);
    if (true)
    {
        assume $DebugTrackLocal(16, 37955, 3, $Dereference(sender_account));
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 37955, 4, $Dereference(sender_balance));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t11);
    call $t10 := $WritebackToReference($t11, $t10);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t10));
    $tmp := $Integer(0);
    $t13 := $tmp;
    call $tmp := $Gt($t23, $t13);
    $t14 := $tmp;
    $tmp := $t14;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t16 := $BorrowGlobal($LibraAccount_Balance_$memory, $t22, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 38089, $abort_code);
        goto Abort;
    }

    call sender_balance := $CopyOrMoveRef($t16);
    if (true)
    {
        assume $DebugTrackLocal(16, 38072, 4, $Dereference(sender_balance));
    }

    call $t18 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $CopyOrMoveRef(sender_balance);
    call $tmp := $ReadRef($t19);
    $t25 := $tmp;
    call $t21, $t25 := $LibraAccount_withdraw_from_balance_$direct_intra($tv0, $t22, $t18, $t25, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $WriteRef($t19, $t25);
    if (true)
    {
        assume $DebugTrackLocal(16, 38022, 3, $Dereference(sender_account));
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38022, 4, $Dereference(sender_balance));
    }

    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, $t19);
    call $TransactionFee_pay_fee_$direct_inter($tv0, $t21);
    if ($abort_flag)
    {
        goto Abort;
    }

    goto L2;

  L2:
    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_epilogue_$verify($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value);



implementation $LibraAccount_epilogue_$verify($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value)
{
    assume is#$Address(sender);
    assume $IsValidU64(transaction_fee_amount);
    assume $IsValidU64(txn_sequence_number);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1040"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1041"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1042"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1043"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1044"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1045"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1046"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1047"} { contents#$Memory($TransactionFee_TransactionFee_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $TransactionFee_TransactionFee_is_well_formed(contents#$Memory($TransactionFee_TransactionFee_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1048"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1049"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1050"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1051"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1052"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1053"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_epilogue_$def_verify($tv0, sender, transaction_fee_amount, txn_sequence_number);
}



procedure {:inline 1} $LibraAccount_extract_key_rotation_capability_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_extract_key_rotation_capability_$def(account: $Value) returns ($ret0: $Value)
{
  var account#1517: $Mutation;
  var account_address: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Mutation;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 21693, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;
    call $t6 := $Signer_address_of($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    account_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 21817, 2, $tmp);
    }

    call $t8 := $LibraAccount_delegated_key_rotation_capability(account_address);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t8);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 21966, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(9);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 21966, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $t13 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, account_address, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 22093, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t13));
    call account#1517 := $CopyOrMoveRef($t13);
    if (true)
    {
        assume $DebugTrackLocal(16, 22083, 1, $Dereference(account#1517));
    }

    call $t14 := $CopyOrMoveRef(account#1517);
    call $t15 := $BorrowField($t14, $LibraAccount_LibraAccount_key_rotation_capability);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t14);
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));
    call $tmp := $ReadRef($t15);
    $t18 := $tmp;
    call $t16, $t18 := $Option_extract($LibraAccount_KeyRotationCapability_type_value(), $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $WriteRef($t15, $t18);
    if (true)
    {
        assume $DebugTrackLocal(16, 22151, 1, $Dereference(account#1517));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t15);
    call $t14 := $WritebackToReference($t15, $t14);
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));
    $ret0 := $t16;
    if (true)
    {
        assume $DebugTrackLocal(16, 22151, 19, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_extract_key_rotation_capability_$direct_inter(account: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $Signer_spec_address_of(account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) || b#$Boolean(old($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $Signer_spec_address_of(account))));
  ensures !$abort_flag ==> b#$Boolean($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $Signer_spec_address_of(account)));



implementation {:inline 1} $LibraAccount_extract_key_rotation_capability_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $LibraAccount_extract_key_rotation_capability_$def(account);
}



procedure {:inline 1} $LibraAccount_extract_key_rotation_capability_$direct_intra(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_extract_key_rotation_capability_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $LibraAccount_extract_key_rotation_capability_$def(account);
}



procedure {:inline 1} $LibraAccount_extract_key_rotation_capability(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_extract_key_rotation_capability(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $ret0 := $LibraAccount_extract_key_rotation_capability_$def(account);
}



procedure {:inline 1} $LibraAccount_extract_key_rotation_capability_$def_verify(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_extract_key_rotation_capability_$def_verify(account: $Value) returns ($ret0: $Value)
{
  var account#1517: $Mutation;
  var account_address: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Mutation;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 21693, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;
    call $t6 := $Signer_address_of_$direct_inter($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    account_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 21817, 2, $tmp);
    }

    call $t8 := $LibraAccount_delegated_key_rotation_capability_$direct_intra(account_address);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t8);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 21966, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(9);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 21966, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $t13 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, account_address, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 22093, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t13));
    call account#1517 := $CopyOrMoveRef($t13);
    if (true)
    {
        assume $DebugTrackLocal(16, 22083, 1, $Dereference(account#1517));
    }

    call $t14 := $CopyOrMoveRef(account#1517);
    call $t15 := $BorrowField($t14, $LibraAccount_LibraAccount_key_rotation_capability);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t14);
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));
    call $tmp := $ReadRef($t15);
    $t18 := $tmp;
    call $t16, $t18 := $Option_extract_$direct_inter($LibraAccount_KeyRotationCapability_type_value(), $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $WriteRef($t15, $t18);
    if (true)
    {
        assume $DebugTrackLocal(16, 22151, 1, $Dereference(account#1517));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t15);
    call $t14 := $WritebackToReference($t15, $t14);
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));
    $ret0 := $t16;
    if (true)
    {
        assume $DebugTrackLocal(16, 22151, 19, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_extract_key_rotation_capability_$verify(account: $Value) returns ($ret0: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) ==> $abort_flag;
  ensures b#$Boolean(old($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $Signer_spec_address_of(account)))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) || b#$Boolean(old($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $Signer_spec_address_of(account))));
  ensures !$abort_flag ==> b#$Boolean($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $Signer_spec_address_of(account)));



implementation $LibraAccount_extract_key_rotation_capability_$verify(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);
    call $InitVerification();
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1054"} { contents#$Memory($Option_Option_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Option_Option_is_well_formed(contents#$Memory($Option_Option_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1055"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_extract_key_rotation_capability_$def_verify(account);
}



procedure {:inline 1} $LibraAccount_extract_withdraw_capability_$def(sender: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_extract_withdraw_capability_$def(sender: $Value) returns ($ret0: $Value)
{
  var account: $Mutation;
  var sender_addr: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Mutation;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 18900, 0, sender);
    }

    call $tmp := $CopyOrMoveValue(sender);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;
    call $t6 := $Signer_address_of($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    sender_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 19026, 2, $tmp);
    }

    call $t8 := $LibraAccount_delegated_withdraw_capability(sender_addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t8);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 19166, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(7);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 19166, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $t13 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, sender_addr, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 19283, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t13));
    call account := $CopyOrMoveRef($t13);
    if (true)
    {
        assume $DebugTrackLocal(16, 19273, 1, $Dereference(account));
    }

    call $t14 := $CopyOrMoveRef(account);
    call $t15 := $BorrowField($t14, $LibraAccount_LibraAccount_withdrawal_capability);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t14);
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));
    call $tmp := $ReadRef($t15);
    $t18 := $tmp;
    call $t16, $t18 := $Option_extract($LibraAccount_WithdrawCapability_type_value(), $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $WriteRef($t15, $t18);
    if (true)
    {
        assume $DebugTrackLocal(16, 19337, 1, $Dereference(account));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t15);
    call $t14 := $WritebackToReference($t15, $t14);
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));
    $ret0 := $t16;
    if (true)
    {
        assume $DebugTrackLocal(16, 19337, 19, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_extract_withdraw_capability_$direct_inter(sender: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_extract_withdraw_capability_$direct_inter(sender: $Value) returns ($ret0: $Value)
{
    assume is#$Address(sender);
    call $ret0 := $LibraAccount_extract_withdraw_capability_$def(sender);
}



procedure {:inline 1} $LibraAccount_extract_withdraw_capability_$direct_intra(sender: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_extract_withdraw_capability_$direct_intra(sender: $Value) returns ($ret0: $Value)
{
    assume is#$Address(sender);
    call $ret0 := $LibraAccount_extract_withdraw_capability_$def(sender);
}



procedure {:inline 1} $LibraAccount_extract_withdraw_capability(sender: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_extract_withdraw_capability(sender: $Value) returns ($ret0: $Value)
{
    assume is#$Address(sender);
    call $ret0 := $LibraAccount_extract_withdraw_capability_$def(sender);
}



procedure {:inline 1} $LibraAccount_extract_withdraw_capability_$def_verify(sender: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_extract_withdraw_capability_$def_verify(sender: $Value) returns ($ret0: $Value)
{
  var account: $Mutation;
  var sender_addr: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Mutation;
  var $t14: $Mutation;
  var $t15: $Mutation;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 18900, 0, sender);
    }

    call $tmp := $CopyOrMoveValue(sender);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;
    call $t6 := $Signer_address_of_$direct_inter($t5);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t6);
    sender_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 19026, 2, $tmp);
    }

    call $t8 := $LibraAccount_delegated_withdraw_capability_$direct_intra(sender_addr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t8);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 19166, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(7);
    $t11 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 19166, i#$Integer($t11));
    }

    $abort_code := i#$Integer($t11);
    goto Abort;

  L0:
    call $t13 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, sender_addr, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 19283, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t13));
    call account := $CopyOrMoveRef($t13);
    if (true)
    {
        assume $DebugTrackLocal(16, 19273, 1, $Dereference(account));
    }

    call $t14 := $CopyOrMoveRef(account);
    call $t15 := $BorrowField($t14, $LibraAccount_LibraAccount_withdrawal_capability);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t14);
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));
    call $tmp := $ReadRef($t15);
    $t18 := $tmp;
    call $t16, $t18 := $Option_extract_$direct_inter($LibraAccount_WithdrawCapability_type_value(), $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t15 := $WriteRef($t15, $t18);
    if (true)
    {
        assume $DebugTrackLocal(16, 19337, 1, $Dereference(account));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t15);
    call $t14 := $WritebackToReference($t15, $t14);
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));
    $ret0 := $t16;
    if (true)
    {
        assume $DebugTrackLocal(16, 19337, 19, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_extract_withdraw_capability_$verify(sender: $Value) returns ($ret0: $Value);



implementation $LibraAccount_extract_withdraw_capability_$verify(sender: $Value) returns ($ret0: $Value)
{
    assume is#$Address(sender);
    call $InitVerification();
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1056"} { contents#$Memory($Option_Option_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Option_Option_is_well_formed(contents#$Memory($Option_Option_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1057"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_extract_withdraw_capability_$def_verify(sender);
}



procedure {:inline 1} $LibraAccount_failure_epilogue_$def($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation {:inline 1} $LibraAccount_failure_epilogue_$def($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
  var sender: $Value;
  var transaction_fee_amount: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 1, txn_sequence_number);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 2, txn_gas_price);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 3, txn_max_gas_units);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 4, gas_units_remaining);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_gas_price);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_max_gas_units);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue(gas_units_remaining);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t7 := $tmp;
    call $t8 := $Signer_address_of($t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39747, 5, $tmp);
    }

    call $tmp := $Sub($t20, $t21);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 39883, $abort_code);
        goto Abort;
    }

    $t12 := $tmp;
    call $tmp := $MulU64($t19, $t12);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 39862, $abort_code);
        goto Abort;
    }

    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    transaction_fee_amount := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39823, 6, $tmp);
    }

    call $LibraAccount_epilogue($tv0, sender, transaction_fee_amount, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_failure_epilogue_$direct_intra($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation {:inline 1} $LibraAccount_failure_epilogue_$direct_intra($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(txn_sequence_number);
    assume $IsValidU64(txn_gas_price);
    assume $IsValidU64(txn_max_gas_units);
    assume $IsValidU64(gas_units_remaining);
    call $LibraAccount_failure_epilogue_$def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}



procedure {:inline 1} $LibraAccount_failure_epilogue($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation {:inline 1} $LibraAccount_failure_epilogue($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(txn_sequence_number);
    assume $IsValidU64(txn_gas_price);
    assume $IsValidU64(txn_max_gas_units);
    assume $IsValidU64(gas_units_remaining);
    call $LibraAccount_failure_epilogue_$def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}



procedure {:inline 1} $LibraAccount_failure_epilogue_$def_verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation {:inline 1} $LibraAccount_failure_epilogue_$def_verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
  var sender: $Value;
  var transaction_fee_amount: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 1, txn_sequence_number);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 2, txn_gas_price);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 3, txn_max_gas_units);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 39485, 4, gas_units_remaining);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_gas_price);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_max_gas_units);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue(gas_units_remaining);
    $t21 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t7 := $tmp;
    call $t8 := $Signer_address_of_$direct_inter($t7);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t8);
    sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39747, 5, $tmp);
    }

    call $tmp := $Sub($t20, $t21);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 39883, $abort_code);
        goto Abort;
    }

    $t12 := $tmp;
    call $tmp := $MulU64($t19, $t12);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 39862, $abort_code);
        goto Abort;
    }

    $t13 := $tmp;
    call $tmp := $CopyOrMoveValue($t13);
    transaction_fee_amount := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39823, 6, $tmp);
    }

    call $LibraAccount_epilogue_$direct_intra($tv0, sender, transaction_fee_amount, $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_failure_epilogue_$verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation $LibraAccount_failure_epilogue_$verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(txn_sequence_number);
    assume $IsValidU64(txn_gas_price);
    assume $IsValidU64(txn_max_gas_units);
    assume $IsValidU64(gas_units_remaining);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1058"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1059"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1060"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1061"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1062"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1063"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1064"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1065"} { contents#$Memory($TransactionFee_TransactionFee_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $TransactionFee_TransactionFee_is_well_formed(contents#$Memory($TransactionFee_TransactionFee_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1066"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1067"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1068"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1069"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1070"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1071"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_failure_epilogue_$def_verify($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}



procedure {:inline 1} $LibraAccount_has_published_account_limits_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_has_published_account_limits_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 31526, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t9 := $tmp;
    call $t3 := $VASP_is_vasp($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t5 := $VASP_has_account_limits($tv0, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 31597, 1, $tmp);
    }

    goto L3;

  L2:
    call $t7 := $AccountLimits_has_window_published($tv0, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 31597, 1, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(16, 31597, 10, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_has_published_account_limits_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_has_published_account_limits_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_has_published_account_limits_$def($tv0, addr);
}



procedure {:inline 1} $LibraAccount_has_published_account_limits($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_has_published_account_limits($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_has_published_account_limits_$def($tv0, addr);
}



procedure {:inline 1} $LibraAccount_has_published_account_limits_$def_verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_has_published_account_limits_$def_verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 31526, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t9 := $tmp;
    call $t3 := $VASP_is_vasp_$direct_inter($t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t5 := $VASP_has_account_limits_$direct_inter($tv0, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 31597, 1, $tmp);
    }

    goto L3;

  L2:
    call $t7 := $AccountLimits_has_window_published_$direct_inter($tv0, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t7);
    $t1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 31597, 1, $tmp);
    }

    goto L3;

  L3:
    $ret0 := $t1;
    if (true)
    {
        assume $DebugTrackLocal(16, 31597, 10, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_has_published_account_limits_$verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value);



implementation $LibraAccount_has_published_account_limits_$verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $InitVerification();
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1072"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1073"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1074"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1075"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1076"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1077"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $ret0 := $LibraAccount_has_published_account_limits_$def_verify($tv0, addr);
}



procedure {:inline 1} $LibraAccount_key_rotation_capability_address_$def(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_key_rotation_capability_address_$def(cap: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 34841, 0, cap);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_KeyRotationCapability_account_address);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(16, 34933, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_key_rotation_capability_address_$direct_inter(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_key_rotation_capability_address_$direct_inter(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    call $ret0 := $LibraAccount_key_rotation_capability_address_$def(cap);
}



procedure {:inline 1} $LibraAccount_key_rotation_capability_address_$direct_intra(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_key_rotation_capability_address_$direct_intra(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    call $ret0 := $LibraAccount_key_rotation_capability_address_$def(cap);
}



procedure {:inline 1} $LibraAccount_key_rotation_capability_address(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_key_rotation_capability_address(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    call $ret0 := $LibraAccount_key_rotation_capability_address_$def(cap);
}



procedure {:inline 1} $LibraAccount_key_rotation_capability_address_$def_verify(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_key_rotation_capability_address_$def_verify(cap: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 34841, 0, cap);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_KeyRotationCapability_account_address);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(16, 34933, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_key_rotation_capability_address_$verify(cap: $Value) returns ($ret0: $Value);



implementation $LibraAccount_key_rotation_capability_address_$verify(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1078"} { contents#$Memory($LibraAccount_KeyRotationCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_KeyRotationCapability_is_well_formed(contents#$Memory($LibraAccount_KeyRotationCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_key_rotation_capability_address_$def_verify(cap);
}



procedure {:inline 1} $LibraAccount_make_account_$def(new_account: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_make_account_$def(new_account: $Value, auth_key_prefix: $Value)
{
  var authentication_key: $Value;
  var new_account_addr: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 24233, 0, new_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 24233, 1, auth_key_prefix);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t42 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t43 := $tmp;
    call $tmp := $CopyOrMoveValue($t42);
    $t8 := $tmp;
    call $t9 := $Signer_address_of($t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    new_account_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 24337, 3, $tmp);
    }

    call $t11 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean(!$IsEqual(new_account_addr, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 24462, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(10);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 24462, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t43);
    authentication_key := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 24608, 2, $tmp);
    }

    call $t16 := $BorrowLoc(2, authentication_key);
    call $tmp := $CopyOrMoveValue($t42);
    $t17 := $tmp;
    call $t18 := $Signer_borrow_address($t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $LCS_to_bytes($AddressType(), $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $ReadRef($t16);
    $t44 := $tmp;
    call $t44 := $Vector_append($IntegerType(), $t44, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t16 := $WriteRef($t16, $t44);
    call authentication_key := $WritebackToValue($t16, 2, authentication_key);
    call $tmp := $CopyOrMoveValue(authentication_key);
    $t20 := $tmp;
    call $t21 := $Vector_length($IntegerType(), $t20);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(32);
    $t22 := $tmp;
    $tmp := $Boolean($IsEqual($t21, $t22));
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 24778, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(8);
    $t25 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 24778, i#$Integer($t25));
    }

    $abort_code := i#$Integer($t25);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t42);
    $t26 := $tmp;
    call $tmp := $LibraAccount_WithdrawCapability_pack(0, 0, 0, new_account_addr);
    $t29 := $tmp;
    call $t30 := $Option_some($LibraAccount_WithdrawCapability_type_value(), $t29);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_KeyRotationCapability_pack(0, 0, 0, new_account_addr);
    $t32 := $tmp;
    call $t33 := $Option_some($LibraAccount_KeyRotationCapability_type_value(), $t32);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t42);
    $t34 := $tmp;
    call $t35 := $Event_new_event_handle($LibraAccount_ReceivedPaymentEvent_type_value(), $t34);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t42);
    $t36 := $tmp;
    call $t37 := $Event_new_event_handle($LibraAccount_SentPaymentEvent_type_value(), $t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(0);
    $t38 := $tmp;
    call $tmp := $LibraAccount_LibraAccount_pack(0, 0, 0, authentication_key, $t30, $t33, $t35, $t37, $t38);
    $t39 := $tmp;
    call $LibraAccount_LibraAccount_$memory := $MoveTo($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $t39, $t26);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 24868, $abort_code);
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t42);
    $t40 := $tmp;
    call $AccountFreezing_create($t40);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_destroy_signer($t42);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_make_account_$direct_intra(new_account: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_make_account_$direct_intra(new_account: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(new_account);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1079"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $LibraAccount_make_account_$def(new_account, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_make_account(new_account: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_make_account(new_account: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(new_account);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1080"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $LibraAccount_make_account_$def(new_account, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_make_account_$def_verify(new_account: $Value, auth_key_prefix: $Value);



implementation {:inline 1} $LibraAccount_make_account_$def_verify(new_account: $Value, auth_key_prefix: $Value)
{
  var authentication_key: $Value;
  var new_account_addr: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 24233, 0, new_account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 24233, 1, auth_key_prefix);
    }

    call $tmp := $CopyOrMoveValue(new_account);
    $t42 := $tmp;
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t43 := $tmp;
    call $tmp := $CopyOrMoveValue($t42);
    $t8 := $tmp;
    call $t9 := $Signer_address_of_$direct_inter($t8);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t9);
    new_account_addr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 24337, 3, $tmp);
    }

    call $t11 := $CoreAddresses_VM_RESERVED_ADDRESS_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean(!$IsEqual(new_account_addr, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 24462, 4, $tmp);
    }

    $tmp := $t4;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(10);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 24462, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L0:
    call $tmp := $CopyOrMoveValue($t43);
    authentication_key := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 24608, 2, $tmp);
    }

    call $t16 := $BorrowLoc(2, authentication_key);
    call $tmp := $CopyOrMoveValue($t42);
    $t17 := $tmp;
    call $t18 := $Signer_borrow_address($t17);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $LCS_to_bytes($AddressType(), $t18);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $ReadRef($t16);
    $t44 := $tmp;
    call $t44 := $Vector_append($IntegerType(), $t44, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t16 := $WriteRef($t16, $t44);
    call authentication_key := $WritebackToValue($t16, 2, authentication_key);
    call $tmp := $CopyOrMoveValue(authentication_key);
    $t20 := $tmp;
    call $t21 := $Vector_length($IntegerType(), $t20);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(32);
    $t22 := $tmp;
    $tmp := $Boolean($IsEqual($t21, $t22));
    $t23 := $tmp;
    call $tmp := $CopyOrMoveValue($t23);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 24778, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(8);
    $t25 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 24778, i#$Integer($t25));
    }

    $abort_code := i#$Integer($t25);
    goto Abort;

  L2:
    call $tmp := $CopyOrMoveValue($t42);
    $t26 := $tmp;
    call $tmp := $LibraAccount_WithdrawCapability_pack(0, 0, 0, new_account_addr);
    $t29 := $tmp;
    call $t30 := $Option_some_$direct_inter($LibraAccount_WithdrawCapability_type_value(), $t29);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_KeyRotationCapability_pack(0, 0, 0, new_account_addr);
    $t32 := $tmp;
    call $t33 := $Option_some_$direct_inter($LibraAccount_KeyRotationCapability_type_value(), $t32);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t42);
    $t34 := $tmp;
    call $t35 := $Event_new_event_handle($LibraAccount_ReceivedPaymentEvent_type_value(), $t34);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t42);
    $t36 := $tmp;
    call $t37 := $Event_new_event_handle($LibraAccount_SentPaymentEvent_type_value(), $t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(0);
    $t38 := $tmp;
    call $tmp := $LibraAccount_LibraAccount_pack(0, 0, 0, authentication_key, $t30, $t33, $t35, $t37, $t38);
    $t39 := $tmp;
    call $LibraAccount_LibraAccount_$memory := $MoveTo($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $t39, $t26);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 24868, $abort_code);
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t42);
    $t40 := $tmp;
    call $AccountFreezing_create_$direct_inter($t40);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_destroy_signer($t42);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_make_account_$verify(new_account: $Value, auth_key_prefix: $Value);
  ensures !$abort_flag ==> b#$Boolean($LibraAccount_spec_has_key_rotation_cap($LibraAccount_LibraAccount_$memory, $Signer_spec_address_of(new_account)));
  ensures !$abort_flag ==> b#$Boolean($LibraAccount_spec_has_withdraw_cap($LibraAccount_LibraAccount_$memory, $Signer_spec_address_of(new_account)));



implementation $LibraAccount_make_account_$verify(new_account: $Value, auth_key_prefix: $Value)
{
    assume is#$Address(new_account);
    assume $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {:qid "quantifier1081"} { $select_vector(auth_key_prefix, $$0) } $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix, $$0)));
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1082"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1083"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $LibraAccount_make_account_$def_verify(new_account, auth_key_prefix);
}



procedure {:inline 1} $LibraAccount_pay_from_$def($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $LibraAccount_pay_from_$def($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value)
{
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 2, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 3, metadata);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 4, metadata_signature);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t5 := $tmp;
    call $tmp := $GetFieldFromValue($t5, $LibraAccount_WithdrawCapability_account_address);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;
    call $t13 := $LibraAccount_withdraw_from($tv0, $t9, $t17, $t18, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_deposit($tv0, $t7, $t17, $t13, $t19, $t20);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_pay_from_$direct_inter($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $LibraAccount_pay_from_$direct_inter($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume is#$Address(payee);
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier1084"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    assume $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {:qid "quantifier1085"} { $select_vector(metadata_signature, $$0) } $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature, $$0)));
    call $LibraAccount_pay_from_$def($tv0, cap, payee, amount, metadata, metadata_signature);
}



procedure {:inline 1} $LibraAccount_pay_from_$direct_intra($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $LibraAccount_pay_from_$direct_intra($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume is#$Address(payee);
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier1086"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    assume $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {:qid "quantifier1087"} { $select_vector(metadata_signature, $$0) } $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature, $$0)));
    call $LibraAccount_pay_from_$def($tv0, cap, payee, amount, metadata, metadata_signature);
}



procedure {:inline 1} $LibraAccount_pay_from($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $LibraAccount_pay_from($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume is#$Address(payee);
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier1088"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    assume $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {:qid "quantifier1089"} { $select_vector(metadata_signature, $$0) } $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature, $$0)));
    call $LibraAccount_pay_from_$def($tv0, cap, payee, amount, metadata, metadata_signature);
}



procedure {:inline 1} $LibraAccount_pay_from_$def_verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value);



implementation {:inline 1} $LibraAccount_pay_from_$def_verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value)
{
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 2, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 3, metadata);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20088, 4, metadata_signature);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t16 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t5 := $tmp;
    call $tmp := $GetFieldFromValue($t5, $LibraAccount_WithdrawCapability_account_address);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;
    call $t13 := $LibraAccount_withdraw_from_$direct_intra($tv0, $t9, $t17, $t18, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $LibraAccount_deposit_$direct_intra($tv0, $t7, $t17, $t13, $t19, $t20);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_pay_from_$verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value);



implementation $LibraAccount_pay_from_$verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume is#$Address(payee);
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier1090"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    assume $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {:qid "quantifier1091"} { $select_vector(metadata_signature, $$0) } $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature, $$0)));
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1092"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1093"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1094"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1095"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1096"} { contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr] } $FixedPoint32_FixedPoint32_is_well_formed(contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1097"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1098"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1099"} { contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr] } $DesignatedDealer_Dealer_is_well_formed(contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1100"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1101"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1102"} { contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Credential_is_well_formed(contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1103"} { contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Limit_is_well_formed(contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1104"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1105"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1106"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1107"} { contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_WithdrawCapability_is_well_formed(contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1108"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1109"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1110"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_pay_from_$def_verify($tv0, cap, payee, amount, metadata, metadata_signature);
}



procedure {:inline 1} $LibraAccount_prologue_$def($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value);



implementation {:inline 1} $LibraAccount_prologue_$def($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value)
{
  var balance_amount: $Value;
  var max_transaction_fee: $Value;
  var sender_account: $Mutation;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var transaction_sender: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Mutation;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Mutation;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Value;
  var $t52: $Mutation;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $t56: $Value;
  var $t57: $Value;
  var $t58: $Value;
  var $t59: $Value;
  var $t60: $Value;
  var $t61: $Value;
  var $t62: $Value;
  var $t63: $Value;
  var $t64: $Value;
  var $t65: $Value;
  var $t66: $Mutation;
  var $t67: $Value;
  var $t68: $Value;
  var $t69: $Mutation;
  var $t70: $Value;
  var $t71: $Value;
  var $t72: $Value;
  var $t73: $Value;
  var $t74: $Mutation;
  var $t75: $Value;
  var $t76: $Value;
  var $t77: $Mutation;
  var $t78: $Value;
  var $t79: $Value;
  var $t80: $Value;
  var $t81: $Value;
  var $t82: $Value;
  var $t83: $Value;
  var $t84: $Value;
  var $t85: $Value;
  var $t86: $Value;
  var $t87: $Value;
  var $t88: $Value;
  var $t89: $Value;
  var $t90: $Value;
  var $t91: $Value;
  var $t92: $Value;
  var $t93: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 0, sender);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 1, txn_sequence_number);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 2, txn_public_key);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 3, txn_gas_price);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 4, txn_max_gas_units);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 5, txn_expiration_time);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 6, chain_id);
    }

    call $tmp := $CopyOrMoveValue(sender);
    $t87 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t88 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_public_key);
    $t89 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_gas_price);
    $t90 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_max_gas_units);
    $t91 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_expiration_time);
    $t92 := $tmp;
    call $tmp := $CopyOrMoveValue(chain_id);
    $t93 := $tmp;
    call $tmp := $CopyOrMoveValue($t87);
    $t27 := $tmp;
    call $t28 := $Signer_address_of($t27);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t28);
    transaction_sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 35708, 26, $tmp);
    }

    call $t29 := $ChainId_get();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t29, $t93));
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 35867, 10, $tmp);
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(7);
    $t33 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 35867, i#$Integer($t33));
    }

    $abort_code := i#$Integer($t33);
    goto Abort;

  L0:
    call $t35 := $LibraAccount_exists_at(transaction_sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t35);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 35999, 12, $tmp);
    }

    $tmp := $t12;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(4);
    $t37 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 35999, i#$Integer($t37));
    }

    $abort_code := i#$Integer($t37);
    goto Abort;

  L2:
    call $t39 := $AccountFreezing_account_is_frozen(transaction_sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t39);
    $t40 := $tmp;
    call $tmp := $CopyOrMoveValue($t40);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36167, 14, $tmp);
    }

    $tmp := $t14;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    $tmp := $Integer(0);
    $t42 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 36167, i#$Integer($t42));
    }

    $abort_code := i#$Integer($t42);
    goto Abort;

  L4:
    call $t44 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, transaction_sender, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 36337, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t44));
    call sender_account := $CopyOrMoveRef($t44);
    if (true)
    {
        assume $DebugTrackLocal(16, 36320, 9, $Dereference(sender_account));
    }

    call $t46 := $Hash_sha3_256($t89);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t47 := $CopyOrMoveRef(sender_account);
    call $tmp := $GetFieldFromReference($t47, $LibraAccount_LibraAccount_authentication_key);
    $t48 := $tmp;
    call sender_account := $WritebackToReference($t47, sender_account);
    call $tmp := $CopyOrMoveValue($t48);
    $t49 := $tmp;
    $tmp := $Boolean($IsEqual($t46, $t49));
    $t50 := $tmp;
    call $tmp := $CopyOrMoveValue($t50);
    $t16 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36493, 16, $tmp);
    }

    $tmp := $t16;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    call $t52 := $CopyOrMoveRef(sender_account);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t52);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t52));
    $tmp := $Integer(1);
    $t53 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 36493, i#$Integer($t53));
    }

    $abort_code := i#$Integer($t53);
    goto Abort;

  L6:
    call $tmp := $MulU64($t90, $t91);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 36763, $abort_code);
        goto Abort;
    }

    $t56 := $tmp;
    call $tmp := $CopyOrMoveValue($t56);
    max_transaction_fee := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36727, 8, $tmp);
    }

    $tmp := $Integer(0);
    $t58 := $tmp;
    call $tmp := $Gt(max_transaction_fee, $t58);
    $t59 := $tmp;
    $tmp := $t59;
    if (b#$Boolean($tmp))
    {
        goto L8;
    }
    else
    {
        goto L9;
    }

  L9:
    goto L10;

  L8:
    call $t61 := $LibraAccount_balance($tv0, transaction_sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t61);
    balance_amount := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36904, 7, $tmp);
    }

    call $tmp := $Ge(balance_amount, max_transaction_fee);
    $t64 := $tmp;
    call $tmp := $CopyOrMoveValue($t64);
    $t18 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36969, 18, $tmp);
    }

    $tmp := $t18;
    if (b#$Boolean($tmp))
    {
        goto L10;
    }
    else
    {
        goto L11;
    }

  L11:
    call $t66 := $CopyOrMoveRef(sender_account);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t66);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t66));
    $tmp := $Integer(5);
    $t67 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 36969, i#$Integer($t67));
    }

    $abort_code := i#$Integer($t67);
    goto Abort;

  L10:
    call $t69 := $CopyOrMoveRef(sender_account);
    call $tmp := $GetFieldFromReference($t69, $LibraAccount_LibraAccount_sequence_number);
    $t70 := $tmp;
    call sender_account := $WritebackToReference($t69, sender_account);
    call $tmp := $CopyOrMoveValue($t70);
    $t71 := $tmp;
    call $tmp := $Ge($t88, $t71);
    $t72 := $tmp;
    call $tmp := $CopyOrMoveValue($t72);
    $t20 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 37165, 20, $tmp);
    }

    $tmp := $t20;
    if (b#$Boolean($tmp))
    {
        goto L12;
    }
    else
    {
        goto L13;
    }

  L13:
    call $t74 := $CopyOrMoveRef(sender_account);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t74);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t74));
    $tmp := $Integer(2);
    $t75 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 37165, i#$Integer($t75));
    }

    $abort_code := i#$Integer($t75);
    goto Abort;

  L12:
    call $t77 := $CopyOrMoveRef(sender_account);
    call $tmp := $GetFieldFromReference($t77, $LibraAccount_LibraAccount_sequence_number);
    $t78 := $tmp;
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t77);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t77));
    call $tmp := $CopyOrMoveValue($t78);
    $t79 := $tmp;
    $tmp := $Boolean($IsEqual($t88, $t79));
    $t80 := $tmp;
    call $tmp := $CopyOrMoveValue($t80);
    $t22 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 37271, 22, $tmp);
    }

    $tmp := $t22;
    if (b#$Boolean($tmp))
    {
        goto L14;
    }
    else
    {
        goto L15;
    }

  L15:
    $tmp := $Integer(3);
    $t82 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 37271, i#$Integer($t82));
    }

    $abort_code := i#$Integer($t82);
    goto Abort;

  L14:
    call $t84 := $LibraTransactionTimeout_is_valid_transaction_timestamp($t92);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t84);
    $t24 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 37377, 24, $tmp);
    }

    $tmp := $t24;
    if (b#$Boolean($tmp))
    {
        goto L16;
    }
    else
    {
        goto L17;
    }

  L17:
    $tmp := $Integer(6);
    $t86 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 37377, i#$Integer($t86));
    }

    $abort_code := i#$Integer($t86);
    goto Abort;

  L16:
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_prologue_$direct_intra($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value);



implementation {:inline 1} $LibraAccount_prologue_$direct_intra($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value)
{
    assume is#$Address(sender);
    assume $IsValidU64(txn_sequence_number);
    assume $Vector_is_well_formed(txn_public_key) && (forall $$0: int :: {:qid "quantifier1111"} { $select_vector(txn_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key, $$0)));
    assume $IsValidU64(txn_gas_price);
    assume $IsValidU64(txn_max_gas_units);
    assume $IsValidU64(txn_expiration_time);
    assume $IsValidU8(chain_id);
    call $LibraAccount_prologue_$def($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time, chain_id);
}



procedure {:inline 1} $LibraAccount_prologue($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value);



implementation {:inline 1} $LibraAccount_prologue($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value)
{
    assume is#$Address(sender);
    assume $IsValidU64(txn_sequence_number);
    assume $Vector_is_well_formed(txn_public_key) && (forall $$0: int :: {:qid "quantifier1112"} { $select_vector(txn_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key, $$0)));
    assume $IsValidU64(txn_gas_price);
    assume $IsValidU64(txn_max_gas_units);
    assume $IsValidU64(txn_expiration_time);
    assume $IsValidU8(chain_id);
    call $LibraAccount_prologue_$def($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time, chain_id);
}



procedure {:inline 1} $LibraAccount_prologue_$def_verify($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value);



implementation {:inline 1} $LibraAccount_prologue_$def_verify($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value)
{
  var balance_amount: $Value;
  var max_transaction_fee: $Value;
  var sender_account: $Mutation;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var transaction_sender: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Value;
  var $t42: $Value;
  var $t43: $Value;
  var $t44: $Mutation;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Mutation;
  var $t48: $Value;
  var $t49: $Value;
  var $t50: $Value;
  var $t51: $Value;
  var $t52: $Mutation;
  var $t53: $Value;
  var $t54: $Value;
  var $t55: $Value;
  var $t56: $Value;
  var $t57: $Value;
  var $t58: $Value;
  var $t59: $Value;
  var $t60: $Value;
  var $t61: $Value;
  var $t62: $Value;
  var $t63: $Value;
  var $t64: $Value;
  var $t65: $Value;
  var $t66: $Mutation;
  var $t67: $Value;
  var $t68: $Value;
  var $t69: $Mutation;
  var $t70: $Value;
  var $t71: $Value;
  var $t72: $Value;
  var $t73: $Value;
  var $t74: $Mutation;
  var $t75: $Value;
  var $t76: $Value;
  var $t77: $Mutation;
  var $t78: $Value;
  var $t79: $Value;
  var $t80: $Value;
  var $t81: $Value;
  var $t82: $Value;
  var $t83: $Value;
  var $t84: $Value;
  var $t85: $Value;
  var $t86: $Value;
  var $t87: $Value;
  var $t88: $Value;
  var $t89: $Value;
  var $t90: $Value;
  var $t91: $Value;
  var $t92: $Value;
  var $t93: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 0, sender);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 1, txn_sequence_number);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 2, txn_public_key);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 3, txn_gas_price);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 4, txn_max_gas_units);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 5, txn_expiration_time);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 35426, 6, chain_id);
    }

    call $tmp := $CopyOrMoveValue(sender);
    $t87 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t88 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_public_key);
    $t89 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_gas_price);
    $t90 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_max_gas_units);
    $t91 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_expiration_time);
    $t92 := $tmp;
    call $tmp := $CopyOrMoveValue(chain_id);
    $t93 := $tmp;
    call $tmp := $CopyOrMoveValue($t87);
    $t27 := $tmp;
    call $t28 := $Signer_address_of_$direct_inter($t27);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t28);
    transaction_sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 35708, 26, $tmp);
    }

    call $t29 := $ChainId_get_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Boolean($IsEqual($t29, $t93));
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 35867, 10, $tmp);
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(7);
    $t33 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 35867, i#$Integer($t33));
    }

    $abort_code := i#$Integer($t33);
    goto Abort;

  L0:
    call $t35 := $LibraAccount_exists_at_$direct_intra(transaction_sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t35);
    $t12 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 35999, 12, $tmp);
    }

    $tmp := $t12;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    $tmp := $Integer(4);
    $t37 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 35999, i#$Integer($t37));
    }

    $abort_code := i#$Integer($t37);
    goto Abort;

  L2:
    call $t39 := $AccountFreezing_account_is_frozen_$direct_inter(transaction_sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t39);
    $t40 := $tmp;
    call $tmp := $CopyOrMoveValue($t40);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36167, 14, $tmp);
    }

    $tmp := $t14;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    $tmp := $Integer(0);
    $t42 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 36167, i#$Integer($t42));
    }

    $abort_code := i#$Integer($t42);
    goto Abort;

  L4:
    call $t44 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, transaction_sender, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 36337, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t44));
    call sender_account := $CopyOrMoveRef($t44);
    if (true)
    {
        assume $DebugTrackLocal(16, 36320, 9, $Dereference(sender_account));
    }

    call $t46 := $Hash_sha3_256($t89);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t47 := $CopyOrMoveRef(sender_account);
    call $tmp := $GetFieldFromReference($t47, $LibraAccount_LibraAccount_authentication_key);
    $t48 := $tmp;
    call sender_account := $WritebackToReference($t47, sender_account);
    call $tmp := $CopyOrMoveValue($t48);
    $t49 := $tmp;
    $tmp := $Boolean($IsEqual($t46, $t49));
    $t50 := $tmp;
    call $tmp := $CopyOrMoveValue($t50);
    $t16 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36493, 16, $tmp);
    }

    $tmp := $t16;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    call $t52 := $CopyOrMoveRef(sender_account);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t52);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t52));
    $tmp := $Integer(1);
    $t53 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 36493, i#$Integer($t53));
    }

    $abort_code := i#$Integer($t53);
    goto Abort;

  L6:
    call $tmp := $MulU64($t90, $t91);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 36763, $abort_code);
        goto Abort;
    }

    $t56 := $tmp;
    call $tmp := $CopyOrMoveValue($t56);
    max_transaction_fee := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36727, 8, $tmp);
    }

    $tmp := $Integer(0);
    $t58 := $tmp;
    call $tmp := $Gt(max_transaction_fee, $t58);
    $t59 := $tmp;
    $tmp := $t59;
    if (b#$Boolean($tmp))
    {
        goto L8;
    }
    else
    {
        goto L9;
    }

  L9:
    goto L10;

  L8:
    call $t61 := $LibraAccount_balance_$direct_intra($tv0, transaction_sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t61);
    balance_amount := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36904, 7, $tmp);
    }

    call $tmp := $Ge(balance_amount, max_transaction_fee);
    $t64 := $tmp;
    call $tmp := $CopyOrMoveValue($t64);
    $t18 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 36969, 18, $tmp);
    }

    $tmp := $t18;
    if (b#$Boolean($tmp))
    {
        goto L10;
    }
    else
    {
        goto L11;
    }

  L11:
    call $t66 := $CopyOrMoveRef(sender_account);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t66);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t66));
    $tmp := $Integer(5);
    $t67 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 36969, i#$Integer($t67));
    }

    $abort_code := i#$Integer($t67);
    goto Abort;

  L10:
    call $t69 := $CopyOrMoveRef(sender_account);
    call $tmp := $GetFieldFromReference($t69, $LibraAccount_LibraAccount_sequence_number);
    $t70 := $tmp;
    call sender_account := $WritebackToReference($t69, sender_account);
    call $tmp := $CopyOrMoveValue($t70);
    $t71 := $tmp;
    call $tmp := $Ge($t88, $t71);
    $t72 := $tmp;
    call $tmp := $CopyOrMoveValue($t72);
    $t20 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 37165, 20, $tmp);
    }

    $tmp := $t20;
    if (b#$Boolean($tmp))
    {
        goto L12;
    }
    else
    {
        goto L13;
    }

  L13:
    call $t74 := $CopyOrMoveRef(sender_account);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t74);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t74));
    $tmp := $Integer(2);
    $t75 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 37165, i#$Integer($t75));
    }

    $abort_code := i#$Integer($t75);
    goto Abort;

  L12:
    call $t77 := $CopyOrMoveRef(sender_account);
    call $tmp := $GetFieldFromReference($t77, $LibraAccount_LibraAccount_sequence_number);
    $t78 := $tmp;
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t77);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t77));
    call $tmp := $CopyOrMoveValue($t78);
    $t79 := $tmp;
    $tmp := $Boolean($IsEqual($t88, $t79));
    $t80 := $tmp;
    call $tmp := $CopyOrMoveValue($t80);
    $t22 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 37271, 22, $tmp);
    }

    $tmp := $t22;
    if (b#$Boolean($tmp))
    {
        goto L14;
    }
    else
    {
        goto L15;
    }

  L15:
    $tmp := $Integer(3);
    $t82 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 37271, i#$Integer($t82));
    }

    $abort_code := i#$Integer($t82);
    goto Abort;

  L14:
    call $t84 := $LibraTransactionTimeout_is_valid_transaction_timestamp_$direct_inter($t92);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t84);
    $t24 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 37377, 24, $tmp);
    }

    $tmp := $t24;
    if (b#$Boolean($tmp))
    {
        goto L16;
    }
    else
    {
        goto L17;
    }

  L17:
    $tmp := $Integer(6);
    $t86 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 37377, i#$Integer($t86));
    }

    $abort_code := i#$Integer($t86);
    goto Abort;

  L16:
    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_prologue_$verify($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value);



implementation $LibraAccount_prologue_$verify($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value)
{
    assume is#$Address(sender);
    assume $IsValidU64(txn_sequence_number);
    assume $Vector_is_well_formed(txn_public_key) && (forall $$0: int :: {:qid "quantifier1113"} { $select_vector(txn_public_key, $$0) } $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key, $$0)));
    assume $IsValidU64(txn_gas_price);
    assume $IsValidU64(txn_max_gas_units);
    assume $IsValidU64(txn_expiration_time);
    assume $IsValidU8(chain_id);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1114"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1115"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1116"} { contents#$Memory($ChainId_ChainId_$memory)[$EmptyTypeValueArray, $inv_addr] } $ChainId_ChainId_is_well_formed(contents#$Memory($ChainId_ChainId_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1117"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1118"} { contents#$Memory($LibraTransactionTimeout_TTL_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTransactionTimeout_TTL_is_well_formed(contents#$Memory($LibraTransactionTimeout_TTL_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1119"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1120"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    call $LibraAccount_prologue_$def_verify($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time, chain_id);
}



procedure {:inline 1} $LibraAccount_restore_key_rotation_capability_$def(cap: $Value);



implementation {:inline 1} $LibraAccount_restore_key_rotation_capability_$def(cap: $Value)
{
  var account: $Mutation;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Mutation;
  var $t7: $Mutation;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 22608, 0, cap);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_KeyRotationCapability_account_address);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    call $t5 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t4, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 22729, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t5));
    call account := $CopyOrMoveRef($t5);
    if (true)
    {
        assume $DebugTrackLocal(16, 22719, 1, $Dereference(account));
    }

    call $t6 := $CopyOrMoveRef(account);
    call $t7 := $BorrowField($t6, $LibraAccount_LibraAccount_key_rotation_capability);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t6);
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));
    call $tmp := $ReadRef($t7);
    $t10 := $tmp;
    call $t10 := $Option_fill($LibraAccount_KeyRotationCapability_type_value(), $t10, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t7 := $WriteRef($t7, $t10);
    if (true)
    {
        assume $DebugTrackLocal(16, 22608, 1, $Dereference(account));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t7);
    call $t6 := $WritebackToReference($t7, $t6);
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t6));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_restore_key_rotation_capability_$direct_inter(cap: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address))))));
  ensures !$abort_flag ==> b#$Boolean($LibraAccount_spec_holds_own_key_rotation_cap($LibraAccount_LibraAccount_$memory, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)));



implementation {:inline 1} $LibraAccount_restore_key_rotation_capability_$direct_inter(cap: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    call $LibraAccount_restore_key_rotation_capability_$def(cap);
}



procedure {:inline 1} $LibraAccount_restore_key_rotation_capability_$direct_intra(cap: $Value);



implementation {:inline 1} $LibraAccount_restore_key_rotation_capability_$direct_intra(cap: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    call $LibraAccount_restore_key_rotation_capability_$def(cap);
}



procedure {:inline 1} $LibraAccount_restore_key_rotation_capability(cap: $Value);



implementation {:inline 1} $LibraAccount_restore_key_rotation_capability(cap: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    call $LibraAccount_restore_key_rotation_capability_$def(cap);
}



procedure {:inline 1} $LibraAccount_restore_key_rotation_capability_$def_verify(cap: $Value);



implementation {:inline 1} $LibraAccount_restore_key_rotation_capability_$def_verify(cap: $Value)
{
  var account: $Mutation;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Mutation;
  var $t7: $Mutation;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 22608, 0, cap);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_KeyRotationCapability_account_address);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    call $t5 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t4, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 22729, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t5));
    call account := $CopyOrMoveRef($t5);
    if (true)
    {
        assume $DebugTrackLocal(16, 22719, 1, $Dereference(account));
    }

    call $t6 := $CopyOrMoveRef(account);
    call $t7 := $BorrowField($t6, $LibraAccount_LibraAccount_key_rotation_capability);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t6);
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));
    call $tmp := $ReadRef($t7);
    $t10 := $tmp;
    call $t10 := $Option_fill_$direct_inter($LibraAccount_KeyRotationCapability_type_value(), $t10, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t7 := $WriteRef($t7, $t10);
    if (true)
    {
        assume $DebugTrackLocal(16, 22608, 1, $Dereference(account));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t7);
    call $t6 := $WritebackToReference($t7, $t6);
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t6));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));
    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_restore_key_rotation_capability_$verify(cap: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_spec_delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address))))));
  ensures !$abort_flag ==> b#$Boolean($LibraAccount_spec_holds_own_key_rotation_cap($LibraAccount_LibraAccount_$memory, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)));



implementation $LibraAccount_restore_key_rotation_capability_$verify(cap: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1121"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1122"} { contents#$Memory($LibraAccount_KeyRotationCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_KeyRotationCapability_is_well_formed(contents#$Memory($LibraAccount_KeyRotationCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $LibraAccount_restore_key_rotation_capability_$def_verify(cap);
}



procedure {:inline 1} $LibraAccount_restore_withdraw_capability_$def(cap: $Value);



implementation {:inline 1} $LibraAccount_restore_withdraw_capability_$def(cap: $Value)
{
  var account: $Mutation;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Mutation;
  var $t7: $Mutation;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 19478, 0, cap);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_WithdrawCapability_account_address);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    call $t5 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t4, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 19592, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t5));
    call account := $CopyOrMoveRef($t5);
    if (true)
    {
        assume $DebugTrackLocal(16, 19582, 1, $Dereference(account));
    }

    call $t6 := $CopyOrMoveRef(account);
    call $t7 := $BorrowField($t6, $LibraAccount_LibraAccount_withdrawal_capability);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t6);
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));
    call $tmp := $ReadRef($t7);
    $t10 := $tmp;
    call $t10 := $Option_fill($LibraAccount_WithdrawCapability_type_value(), $t10, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t7 := $WriteRef($t7, $t10);
    if (true)
    {
        assume $DebugTrackLocal(16, 19478, 1, $Dereference(account));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t7);
    call $t6 := $WritebackToReference($t7, $t6);
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t6));
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_restore_withdraw_capability_$direct_inter(cap: $Value);



implementation {:inline 1} $LibraAccount_restore_withdraw_capability_$direct_inter(cap: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    call $LibraAccount_restore_withdraw_capability_$def(cap);
}



procedure {:inline 1} $LibraAccount_restore_withdraw_capability_$direct_intra(cap: $Value);



implementation {:inline 1} $LibraAccount_restore_withdraw_capability_$direct_intra(cap: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    call $LibraAccount_restore_withdraw_capability_$def(cap);
}



procedure {:inline 1} $LibraAccount_restore_withdraw_capability(cap: $Value);



implementation {:inline 1} $LibraAccount_restore_withdraw_capability(cap: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    call $LibraAccount_restore_withdraw_capability_$def(cap);
}



procedure {:inline 1} $LibraAccount_restore_withdraw_capability_$def_verify(cap: $Value);



implementation {:inline 1} $LibraAccount_restore_withdraw_capability_$def_verify(cap: $Value)
{
  var account: $Mutation;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Mutation;
  var $t6: $Mutation;
  var $t7: $Mutation;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 19478, 0, cap);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_WithdrawCapability_account_address);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    call $t5 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t4, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 19592, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t5));
    call account := $CopyOrMoveRef($t5);
    if (true)
    {
        assume $DebugTrackLocal(16, 19582, 1, $Dereference(account));
    }

    call $t6 := $CopyOrMoveRef(account);
    call $t7 := $BorrowField($t6, $LibraAccount_LibraAccount_withdrawal_capability);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t6);
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));
    call $tmp := $ReadRef($t7);
    $t10 := $tmp;
    call $t10 := $Option_fill_$direct_inter($LibraAccount_WithdrawCapability_type_value(), $t10, $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t7 := $WriteRef($t7, $t10);
    if (true)
    {
        assume $DebugTrackLocal(16, 19478, 1, $Dereference(account));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t7);
    call $t6 := $WritebackToReference($t7, $t6);
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t6));
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));
    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_restore_withdraw_capability_$verify(cap: $Value);



implementation $LibraAccount_restore_withdraw_capability_$verify(cap: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1123"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1124"} { contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_WithdrawCapability_is_well_formed(contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $LibraAccount_restore_withdraw_capability_$def_verify(cap);
}



procedure {:inline 1} $LibraAccount_rotate_authentication_key_$def(cap: $Value, new_authentication_key: $Value);



implementation {:inline 1} $LibraAccount_rotate_authentication_key_$def(cap: $Value, new_authentication_key: $Value)
{
  var sender_account_resource: $Mutation;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Mutation;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $t19: $Value;
  var $t20: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 20627, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20627, 1, new_authentication_key);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(new_authentication_key);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t19);
    $t5 := $tmp;
    call $tmp := $GetFieldFromValue($t5, $LibraAccount_KeyRotationCapability_account_address);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    call $t8 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t7, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 20815, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t8));
    call sender_account_resource := $CopyOrMoveRef($t8);
    if (true)
    {
        assume $DebugTrackLocal(16, 20789, 2, $Dereference(sender_account_resource));
    }

    call $tmp := $CopyOrMoveValue($t20);
    $t9 := $tmp;
    call $t10 := $Vector_length($IntegerType(), $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(32);
    $t11 := $tmp;
    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 20932, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t14 := $CopyOrMoveRef(sender_account_resource);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t14);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));
    $tmp := $Integer(8);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 20932, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L0:
    call $t17 := $CopyOrMoveRef(sender_account_resource);
    call $t18 := $BorrowField($t17, $LibraAccount_LibraAccount_authentication_key);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t17);
    call $t18 := $WriteRef($t18, $t20);
    if (true)
    {
        assume $DebugTrackLocal(16, 21026, 2, $Dereference(sender_account_resource));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t18);
    call $t17 := $WritebackToReference($t18, $t17);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t17));
    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_rotate_authentication_key_$direct_inter(cap: $Value, new_authentication_key: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($vlen_value(new_authentication_key), $Integer(32))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) || b#$Boolean(old($Boolean(!$IsEqual($vlen_value(new_authentication_key), $Integer(32)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)), $LibraAccount_LibraAccount_authentication_key), new_authentication_key)));



implementation {:inline 1} $LibraAccount_rotate_authentication_key_$direct_inter(cap: $Value, new_authentication_key: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    assume $Vector_is_well_formed(new_authentication_key) && (forall $$0: int :: {:qid "quantifier1125"} { $select_vector(new_authentication_key, $$0) } $$0 >= 0 && $$0 < $vlen(new_authentication_key) ==> $IsValidU8($select_vector(new_authentication_key, $$0)));
    call $LibraAccount_rotate_authentication_key_$def(cap, new_authentication_key);
}



procedure {:inline 1} $LibraAccount_rotate_authentication_key_$direct_intra(cap: $Value, new_authentication_key: $Value);



implementation {:inline 1} $LibraAccount_rotate_authentication_key_$direct_intra(cap: $Value, new_authentication_key: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    assume $Vector_is_well_formed(new_authentication_key) && (forall $$0: int :: {:qid "quantifier1126"} { $select_vector(new_authentication_key, $$0) } $$0 >= 0 && $$0 < $vlen(new_authentication_key) ==> $IsValidU8($select_vector(new_authentication_key, $$0)));
    call $LibraAccount_rotate_authentication_key_$def(cap, new_authentication_key);
}



procedure {:inline 1} $LibraAccount_rotate_authentication_key(cap: $Value, new_authentication_key: $Value);



implementation {:inline 1} $LibraAccount_rotate_authentication_key(cap: $Value, new_authentication_key: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    assume $Vector_is_well_formed(new_authentication_key) && (forall $$0: int :: {:qid "quantifier1127"} { $select_vector(new_authentication_key, $$0) } $$0 >= 0 && $$0 < $vlen(new_authentication_key) ==> $IsValidU8($select_vector(new_authentication_key, $$0)));
    call $LibraAccount_rotate_authentication_key_$def(cap, new_authentication_key);
}



procedure {:inline 1} $LibraAccount_rotate_authentication_key_$def_verify(cap: $Value, new_authentication_key: $Value);



implementation {:inline 1} $LibraAccount_rotate_authentication_key_$def_verify(cap: $Value, new_authentication_key: $Value)
{
  var sender_account_resource: $Mutation;
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Mutation;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Mutation;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Mutation;
  var $t18: $Mutation;
  var $t19: $Value;
  var $t20: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 20627, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 20627, 1, new_authentication_key);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t19 := $tmp;
    call $tmp := $CopyOrMoveValue(new_authentication_key);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t19);
    $t5 := $tmp;
    call $tmp := $GetFieldFromValue($t5, $LibraAccount_KeyRotationCapability_account_address);
    $t6 := $tmp;
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    call $t8 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t7, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 20815, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t8));
    call sender_account_resource := $CopyOrMoveRef($t8);
    if (true)
    {
        assume $DebugTrackLocal(16, 20789, 2, $Dereference(sender_account_resource));
    }

    call $tmp := $CopyOrMoveValue($t20);
    $t9 := $tmp;
    call $t10 := $Vector_length($IntegerType(), $t9);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Integer(32);
    $t11 := $tmp;
    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 20932, 3, $tmp);
    }

    $tmp := $t3;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t14 := $CopyOrMoveRef(sender_account_resource);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t14);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));
    $tmp := $Integer(8);
    $t15 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 20932, i#$Integer($t15));
    }

    $abort_code := i#$Integer($t15);
    goto Abort;

  L0:
    call $t17 := $CopyOrMoveRef(sender_account_resource);
    call $t18 := $BorrowField($t17, $LibraAccount_LibraAccount_authentication_key);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t17);
    call $t18 := $WriteRef($t18, $t20);
    if (true)
    {
        assume $DebugTrackLocal(16, 21026, 2, $Dereference(sender_account_resource));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t18);
    call $t17 := $WritebackToReference($t18, $t17);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t17));
    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_rotate_authentication_key_$verify(cap: $Value, new_authentication_key: $Value);
  ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(!$IsEqual($vlen_value(new_authentication_key), $Integer(32))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)))))) || b#$Boolean(old($Boolean(!$IsEqual($vlen_value(new_authentication_key), $Integer(32)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $SelectField(cap, $LibraAccount_KeyRotationCapability_account_address)), $LibraAccount_LibraAccount_authentication_key), new_authentication_key)));



implementation $LibraAccount_rotate_authentication_key_$verify(cap: $Value, new_authentication_key: $Value)
{
    assume $LibraAccount_KeyRotationCapability_is_well_formed(cap);
    assume $Vector_is_well_formed(new_authentication_key) && (forall $$0: int :: {:qid "quantifier1128"} { $select_vector(new_authentication_key, $$0) } $$0 >= 0 && $$0 < $vlen(new_authentication_key) ==> $IsValidU8($select_vector(new_authentication_key, $$0)));
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1129"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1130"} { contents#$Memory($LibraAccount_KeyRotationCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_KeyRotationCapability_is_well_formed(contents#$Memory($LibraAccount_KeyRotationCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $LibraAccount_rotate_authentication_key_$def_verify(cap, new_authentication_key);
}



procedure {:inline 1} $LibraAccount_sequence_number_$def(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_sequence_number_$def(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 33639, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t4 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_LibraAccount_$memory, $t4, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 33746, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $t3 := $LibraAccount_sequence_number_for_account($t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(16, 33718, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_sequence_number_$direct_inter(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_sequence_number_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_sequence_number_$def(addr);
}



procedure {:inline 1} $LibraAccount_sequence_number_$direct_intra(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_sequence_number_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_sequence_number_$def(addr);
}



procedure {:inline 1} $LibraAccount_sequence_number(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_sequence_number(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $ret0 := $LibraAccount_sequence_number_$def(addr);
}



procedure {:inline 1} $LibraAccount_sequence_number_$def_verify(addr: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_sequence_number_$def_verify(addr: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 33639, 0, addr);
    }

    call $tmp := $CopyOrMoveValue(addr);
    $t4 := $tmp;
    call $tmp := $GetGlobal($LibraAccount_LibraAccount_$memory, $t4, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 33746, $abort_code);
        goto Abort;
    }

    $t2 := $tmp;
    call $t3 := $LibraAccount_sequence_number_for_account_$direct_intra($t2);
    if ($abort_flag)
    {
        goto Abort;
    }

    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(16, 33718, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_sequence_number_$verify(addr: $Value) returns ($ret0: $Value);



implementation $LibraAccount_sequence_number_$verify(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1131"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_sequence_number_$def_verify(addr);
}



procedure {:inline 1} $LibraAccount_sequence_number_for_account_$def(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_sequence_number_for_account_$def(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 33480, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_LibraAccount_sequence_number);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(16, 33551, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_sequence_number_for_account_$direct_intra(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_sequence_number_for_account_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_LibraAccount_is_well_formed(account);
    call $ret0 := $LibraAccount_sequence_number_for_account_$def(account);
}



procedure {:inline 1} $LibraAccount_sequence_number_for_account(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_sequence_number_for_account(account: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_LibraAccount_is_well_formed(account);
    call $ret0 := $LibraAccount_sequence_number_for_account_$def(account);
}



procedure {:inline 1} $LibraAccount_sequence_number_for_account_$def_verify(account: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_sequence_number_for_account_$def_verify(account: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $t4: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 33480, 0, account);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_LibraAccount_sequence_number);
    $t2 := $tmp;
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;
    $ret0 := $t3;
    if (true)
    {
        assume $DebugTrackLocal(16, 33551, 5, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_sequence_number_for_account_$verify(account: $Value) returns ($ret0: $Value);



implementation $LibraAccount_sequence_number_for_account_$verify(account: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_LibraAccount_is_well_formed(account);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1132"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_sequence_number_for_account_$def_verify(account);
}



procedure {:inline 1} $LibraAccount_should_track_limits_for_account_$def(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_should_track_limits_for_account_$def(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 6649, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 6649, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 6649, 2, is_withdrawal);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t37 := $tmp;
    call $tmp := $CopyOrMoveValue(is_withdrawal);
    $t38 := $tmp;
    $tmp := $t38;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t10 := $VASP_is_vasp($t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L3;
    }
    else
    {
        goto L4;
    }

  L4:
    goto L5;

  L3:
    call $t12 := $VASP_is_vasp($t37);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t12);
    $t13 := $tmp;
    $tmp := $t13;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    $tmp := $Boolean(true);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6811, 3, $tmp);
    }

    goto L9;

  L8:
    call $t17 := $VASP_is_same_vasp($t36, $t37);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t17);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6811, 3, $tmp);
    }

    goto L9;

  L9:
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6787, 4, $tmp);
    }

    goto L10;

  L5:
    $tmp := $Boolean(false);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6787, 4, $tmp);
    }

    goto L10;

  L10:
    call $tmp := $CopyOrMoveValue($t4);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6754, 7, $tmp);
    }

    goto L11;

  L2:
    call $t23 := $VASP_is_vasp($t37);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t23;
    if (b#$Boolean($tmp))
    {
        goto L12;
    }
    else
    {
        goto L13;
    }

  L13:
    goto L14;

  L12:
    call $t25 := $VASP_is_vasp($t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t25);
    $t26 := $tmp;
    $tmp := $t26;
    if (b#$Boolean($tmp))
    {
        goto L15;
    }
    else
    {
        goto L16;
    }

  L16:
    goto L17;

  L15:
    $tmp := $Boolean(true);
    $t27 := $tmp;
    call $tmp := $CopyOrMoveValue($t27);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6925, 5, $tmp);
    }

    goto L18;

  L17:
    call $t30 := $VASP_is_same_vasp($t37, $t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t30);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6925, 5, $tmp);
    }

    goto L18;

  L18:
    call $tmp := $CopyOrMoveValue($t5);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6901, 6, $tmp);
    }

    goto L19;

  L14:
    $tmp := $Boolean(false);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue($t33);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6901, 6, $tmp);
    }

    goto L19;

  L19:
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6754, 7, $tmp);
    }

    goto L11;

  L11:
    $ret0 := $t7;
    if (true)
    {
        assume $DebugTrackLocal(16, 6754, 39, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_should_track_limits_for_account_$direct_intra(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, is_withdrawal))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $LibraAccount_should_track_limits_for_account(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, is_withdrawal))));
  ensures is#$Boolean($ret0);



procedure {:inline 1} $LibraAccount_should_track_limits_for_account_$def_verify(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_should_track_limits_for_account_$def_verify(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value)
{
  var $t3: $Value;
  var $t4: $Value;
  var $t5: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 6649, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 6649, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 6649, 2, is_withdrawal);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t37 := $tmp;
    call $tmp := $CopyOrMoveValue(is_withdrawal);
    $t38 := $tmp;
    $tmp := $t38;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t10 := $VASP_is_vasp_$direct_inter($t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L3;
    }
    else
    {
        goto L4;
    }

  L4:
    goto L5;

  L3:
    call $t12 := $VASP_is_vasp_$direct_inter($t37);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t12);
    $t13 := $tmp;
    $tmp := $t13;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    goto L8;

  L6:
    $tmp := $Boolean(true);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6811, 3, $tmp);
    }

    goto L9;

  L8:
    call $t17 := $VASP_is_same_vasp_$direct_inter($t36, $t37);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t17);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    $t3 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6811, 3, $tmp);
    }

    goto L9;

  L9:
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6787, 4, $tmp);
    }

    goto L10;

  L5:
    $tmp := $Boolean(false);
    $t20 := $tmp;
    call $tmp := $CopyOrMoveValue($t20);
    $t4 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6787, 4, $tmp);
    }

    goto L10;

  L10:
    call $tmp := $CopyOrMoveValue($t4);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6754, 7, $tmp);
    }

    goto L11;

  L2:
    call $t23 := $VASP_is_vasp_$direct_inter($t37);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t23;
    if (b#$Boolean($tmp))
    {
        goto L12;
    }
    else
    {
        goto L13;
    }

  L13:
    goto L14;

  L12:
    call $t25 := $VASP_is_vasp_$direct_inter($t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t25);
    $t26 := $tmp;
    $tmp := $t26;
    if (b#$Boolean($tmp))
    {
        goto L15;
    }
    else
    {
        goto L16;
    }

  L16:
    goto L17;

  L15:
    $tmp := $Boolean(true);
    $t27 := $tmp;
    call $tmp := $CopyOrMoveValue($t27);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6925, 5, $tmp);
    }

    goto L18;

  L17:
    call $t30 := $VASP_is_same_vasp_$direct_inter($t37, $t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t30);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue($t31);
    $t5 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6925, 5, $tmp);
    }

    goto L18;

  L18:
    call $tmp := $CopyOrMoveValue($t5);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6901, 6, $tmp);
    }

    goto L19;

  L14:
    $tmp := $Boolean(false);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue($t33);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6901, 6, $tmp);
    }

    goto L19;

  L19:
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 6754, 7, $tmp);
    }

    goto L11;

  L11:
    $ret0 := $t7;
    if (true)
    {
        assume $DebugTrackLocal(16, 6754, 39, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_should_track_limits_for_account_$verify(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value);
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($ret0, $LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, is_withdrawal))));



implementation $LibraAccount_should_track_limits_for_account_$verify(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value)
{
    assume is#$Address(payer);
    assume is#$Address(payee);
    assume is#$Boolean(is_withdrawal);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1133"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1134"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1135"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1136"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1137"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $ret0 := $LibraAccount_should_track_limits_for_account_$def_verify(payer, payee, is_withdrawal);
}



procedure {:inline 1} $LibraAccount_staple_lbr_$def(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_staple_lbr_$def(cap: $Value, amount_lbr: $Value)
{
  var amount_coin1: $Value;
  var amount_coin2: $Value;
  var cap_address: $Value;
  var coin1: $Value;
  var coin2: $Value;
  var lbr: $Value;
  var payee_address: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 8074, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 8074, 1, amount_lbr);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t35 := $tmp;
    call $tmp := $CopyOrMoveValue(amount_lbr);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue($t35);
    $t9 := $tmp;
    call $tmp := $GetFieldFromValue($t9, $LibraAccount_WithdrawCapability_account_address);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    cap_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8217, 4, $tmp);
    }

    call $t12 := $LBR_reserve_address();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    payee_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8322, 8, $tmp);
    }

    call $t14, $t15 := $LBR_calculate_component_amounts_for_lbr($t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t15);
    amount_coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8389, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t14);
    amount_coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8375, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t35);
    $t16 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t19 := $tmp;
    call $t20 := $LibraAccount_withdraw_from($Coin1_Coin1_type_value(), $t16, payee_address, amount_coin1, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t20);
    coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8471, 5, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t35);
    $t21 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t24 := $tmp;
    call $t25 := $LibraAccount_withdraw_from($Coin2_Coin2_type_value(), $t21, payee_address, amount_coin2, $t24);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t25);
    coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8552, 6, $tmp);
    }

    call $t29 := $LBR_create($t36, coin1, coin2);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t29);
    lbr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8668, 7, $tmp);
    }

    call $t30 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t33 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t34 := $tmp;
    call $LibraAccount_deposit($LBR_LBR_type_value(), $t30, cap_address, lbr, $t33, $t34);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_staple_lbr_$direct_inter(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_staple_lbr_$direct_inter(cap: $Value, amount_lbr: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount_lbr);
    call $LibraAccount_staple_lbr_$def(cap, amount_lbr);
}



procedure {:inline 1} $LibraAccount_staple_lbr_$direct_intra(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_staple_lbr_$direct_intra(cap: $Value, amount_lbr: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount_lbr);
    call $LibraAccount_staple_lbr_$def(cap, amount_lbr);
}



procedure {:inline 1} $LibraAccount_staple_lbr(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_staple_lbr(cap: $Value, amount_lbr: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount_lbr);
    call $LibraAccount_staple_lbr_$def(cap, amount_lbr);
}



procedure {:inline 1} $LibraAccount_staple_lbr_$def_verify(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_staple_lbr_$def_verify(cap: $Value, amount_lbr: $Value)
{
  var amount_coin1: $Value;
  var amount_coin2: $Value;
  var cap_address: $Value;
  var coin1: $Value;
  var coin2: $Value;
  var lbr: $Value;
  var payee_address: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 8074, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 8074, 1, amount_lbr);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t35 := $tmp;
    call $tmp := $CopyOrMoveValue(amount_lbr);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue($t35);
    $t9 := $tmp;
    call $tmp := $GetFieldFromValue($t9, $LibraAccount_WithdrawCapability_account_address);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;
    call $tmp := $CopyOrMoveValue($t11);
    cap_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8217, 4, $tmp);
    }

    call $t12 := $LBR_reserve_address_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    payee_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8322, 8, $tmp);
    }

    call $t14, $t15 := $LBR_calculate_component_amounts_for_lbr_$direct_inter($t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t15);
    amount_coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8389, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t14);
    amount_coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8375, 2, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t35);
    $t16 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t19 := $tmp;
    call $t20 := $LibraAccount_withdraw_from_$direct_intra($Coin1_Coin1_type_value(), $t16, payee_address, amount_coin1, $t19);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t20);
    coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8471, 5, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t35);
    $t21 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t24 := $tmp;
    call $t25 := $LibraAccount_withdraw_from_$direct_intra($Coin2_Coin2_type_value(), $t21, payee_address, amount_coin2, $t24);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t25);
    coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8552, 6, $tmp);
    }

    call $t29 := $LBR_create_$direct_inter($t36, coin1, coin2);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t29);
    lbr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 8668, 7, $tmp);
    }

    call $t30 := $CoreAddresses_VM_RESERVED_ADDRESS_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t33 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t34 := $tmp;
    call $LibraAccount_deposit_$direct_intra($LBR_LBR_type_value(), $t30, cap_address, lbr, $t33, $t34);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_staple_lbr_$verify(cap: $Value, amount_lbr: $Value);



implementation $LibraAccount_staple_lbr_$verify(cap: $Value, amount_lbr: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount_lbr);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1138"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1139"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1140"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1141"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1142"} { contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr] } $FixedPoint32_FixedPoint32_is_well_formed(contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1143"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1144"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1145"} { contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr] } $DesignatedDealer_Dealer_is_well_formed(contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1146"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1147"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1148"} { contents#$Memory($LBR_Reserve_$memory)[$EmptyTypeValueArray, $inv_addr] } $LBR_Reserve_is_well_formed(contents#$Memory($LBR_Reserve_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1149"} { contents#$Memory($LBR_ReserveComponent_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LBR_ReserveComponent_is_well_formed(contents#$Memory($LBR_ReserveComponent_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1150"} { contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Credential_is_well_formed(contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1151"} { contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Limit_is_well_formed(contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1152"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1153"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1154"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1155"} { contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_WithdrawCapability_is_well_formed(contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1156"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1157"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1158"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_staple_lbr_$def_verify(cap, amount_lbr);
}



procedure {:inline 1} $LibraAccount_success_epilogue_$def($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation {:inline 1} $LibraAccount_success_epilogue_$def($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
  var sender: $Value;
  var sender_balance: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var transaction_fee_amount: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 1, txn_sequence_number);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 2, txn_gas_price);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 3, txn_max_gas_units);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 4, gas_units_remaining);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t32 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_gas_price);
    $t34 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_max_gas_units);
    $t35 := $tmp;
    call $tmp := $CopyOrMoveValue(gas_units_remaining);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue($t32);
    $t11 := $tmp;
    call $t12 := $Signer_address_of($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 38777, 5, $tmp);
    }

    call $tmp := $Sub($t35, $t36);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 38914, $abort_code);
        goto Abort;
    }

    $t16 := $tmp;
    call $tmp := $MulU64($t34, $t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 38893, $abort_code);
        goto Abort;
    }

    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    transaction_fee_amount := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 38854, 10, $tmp);
    }

    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), sender);
    $t19 := $tmp;
    $tmp := $t19;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t21 := $LibraAccount_balance($tv0, sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t21);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39085, 7, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Integer(0);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39085, 7, $tmp);
    }

    goto L3;

  L3:
    call $tmp := $CopyOrMoveValue($t7);
    sender_balance := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39068, 6, $tmp);
    }

    call $tmp := $Ge(sender_balance, transaction_fee_amount);
    $t26 := $tmp;
    call $tmp := $CopyOrMoveValue($t26);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39160, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    $tmp := $Integer(5);
    $t28 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 39160, i#$Integer($t28));
    }

    $abort_code := i#$Integer($t28);
    goto Abort;

  L4:
    call $LibraAccount_epilogue($tv0, sender, transaction_fee_amount, $t33);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_success_epilogue_$direct_intra($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation {:inline 1} $LibraAccount_success_epilogue_$direct_intra($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(txn_sequence_number);
    assume $IsValidU64(txn_gas_price);
    assume $IsValidU64(txn_max_gas_units);
    assume $IsValidU64(gas_units_remaining);
    call $LibraAccount_success_epilogue_$def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}



procedure {:inline 1} $LibraAccount_success_epilogue($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation {:inline 1} $LibraAccount_success_epilogue($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(txn_sequence_number);
    assume $IsValidU64(txn_gas_price);
    assume $IsValidU64(txn_max_gas_units);
    assume $IsValidU64(gas_units_remaining);
    call $LibraAccount_success_epilogue_$def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}



procedure {:inline 1} $LibraAccount_success_epilogue_$def_verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation {:inline 1} $LibraAccount_success_epilogue_$def_verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
  var sender: $Value;
  var sender_balance: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var transaction_fee_amount: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $t36: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 0, account);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 1, txn_sequence_number);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 2, txn_gas_price);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 3, txn_max_gas_units);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 38515, 4, gas_units_remaining);
    }

    call $tmp := $CopyOrMoveValue(account);
    $t32 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_gas_price);
    $t34 := $tmp;
    call $tmp := $CopyOrMoveValue(txn_max_gas_units);
    $t35 := $tmp;
    call $tmp := $CopyOrMoveValue(gas_units_remaining);
    $t36 := $tmp;
    call $tmp := $CopyOrMoveValue($t32);
    $t11 := $tmp;
    call $t12 := $Signer_address_of_$direct_inter($t11);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t12);
    sender := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 38777, 5, $tmp);
    }

    call $tmp := $Sub($t35, $t36);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 38914, $abort_code);
        goto Abort;
    }

    $t16 := $tmp;
    call $tmp := $MulU64($t34, $t16);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 38893, $abort_code);
        goto Abort;
    }

    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    transaction_fee_amount := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 38854, 10, $tmp);
    }

    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), sender);
    $t19 := $tmp;
    $tmp := $t19;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    goto L2;

  L0:
    call $t21 := $LibraAccount_balance_$direct_intra($tv0, sender);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t21);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39085, 7, $tmp);
    }

    goto L3;

  L2:
    $tmp := $Integer(0);
    $t22 := $tmp;
    call $tmp := $CopyOrMoveValue($t22);
    $t7 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39085, 7, $tmp);
    }

    goto L3;

  L3:
    call $tmp := $CopyOrMoveValue($t7);
    sender_balance := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39068, 6, $tmp);
    }

    call $tmp := $Ge(sender_balance, transaction_fee_amount);
    $t26 := $tmp;
    call $tmp := $CopyOrMoveValue($t26);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 39160, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    $tmp := $Integer(5);
    $t28 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 39160, i#$Integer($t28));
    }

    $abort_code := i#$Integer($t28);
    goto Abort;

  L4:
    call $LibraAccount_epilogue_$direct_intra($tv0, sender, transaction_fee_amount, $t33);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_success_epilogue_$verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value);



implementation $LibraAccount_success_epilogue_$verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value)
{
    assume is#$Address(account);
    assume $IsValidU64(txn_sequence_number);
    assume $IsValidU64(txn_gas_price);
    assume $IsValidU64(txn_max_gas_units);
    assume $IsValidU64(gas_units_remaining);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1159"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1160"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1161"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1162"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1163"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1164"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1165"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1166"} { contents#$Memory($TransactionFee_TransactionFee_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $TransactionFee_TransactionFee_is_well_formed(contents#$Memory($TransactionFee_TransactionFee_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1167"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1168"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1169"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1170"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1171"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1172"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_success_epilogue_$def_verify($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}



procedure {:inline 1} $LibraAccount_unstaple_lbr_$def(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_unstaple_lbr_$def(cap: $Value, amount_lbr: $Value)
{
  var coin1: $Value;
  var coin2: $Value;
  var lbr: $Value;
  var payee_address: $Value;
  var payer_address: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 9341, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 9341, 1, amount_lbr);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(amount_lbr);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;
    call $t8 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t10 := $tmp;
    call $t11 := $LibraAccount_withdraw_from($LBR_LBR_type_value(), $t7, $t8, $t30, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    lbr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9568, 4, $tmp);
    }

    call $t13, $t14 := $LBR_unpack(lbr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t14);
    coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9674, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t13);
    coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9667, 2, $tmp);
    }

    call $t15 := $LBR_reserve_address();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t15);
    payer_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9807, 6, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t29);
    $t16 := $tmp;
    call $tmp := $GetFieldFromValue($t16, $LibraAccount_WithdrawCapability_account_address);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    payee_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9859, 5, $tmp);
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t22 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t23 := $tmp;
    call $LibraAccount_deposit($Coin1_Coin1_type_value(), payer_address, payee_address, coin1, $t22, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t27 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t28 := $tmp;
    call $LibraAccount_deposit($Coin2_Coin2_type_value(), payer_address, payee_address, coin2, $t27, $t28);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure {:inline 1} $LibraAccount_unstaple_lbr_$direct_inter(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_unstaple_lbr_$direct_inter(cap: $Value, amount_lbr: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount_lbr);
    call $LibraAccount_unstaple_lbr_$def(cap, amount_lbr);
}



procedure {:inline 1} $LibraAccount_unstaple_lbr_$direct_intra(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_unstaple_lbr_$direct_intra(cap: $Value, amount_lbr: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount_lbr);
    call $LibraAccount_unstaple_lbr_$def(cap, amount_lbr);
}



procedure {:inline 1} $LibraAccount_unstaple_lbr(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_unstaple_lbr(cap: $Value, amount_lbr: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount_lbr);
    call $LibraAccount_unstaple_lbr_$def(cap, amount_lbr);
}



procedure {:inline 1} $LibraAccount_unstaple_lbr_$def_verify(cap: $Value, amount_lbr: $Value);



implementation {:inline 1} $LibraAccount_unstaple_lbr_$def_verify(cap: $Value, amount_lbr: $Value)
{
  var coin1: $Value;
  var coin2: $Value;
  var lbr: $Value;
  var payee_address: $Value;
  var payer_address: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Value;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 9341, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 9341, 1, amount_lbr);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t29 := $tmp;
    call $tmp := $CopyOrMoveValue(amount_lbr);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;
    call $t8 := $CoreAddresses_VM_RESERVED_ADDRESS_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t10 := $tmp;
    call $t11 := $LibraAccount_withdraw_from_$direct_intra($LBR_LBR_type_value(), $t7, $t8, $t30, $t10);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t11);
    lbr := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9568, 4, $tmp);
    }

    call $t13, $t14 := $LBR_unpack_$direct_inter(lbr);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t14);
    coin2 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9674, 3, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t13);
    coin1 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9667, 2, $tmp);
    }

    call $t15 := $LBR_reserve_address_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t15);
    payer_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9807, 6, $tmp);
    }

    call $tmp := $CopyOrMoveValue($t29);
    $t16 := $tmp;
    call $tmp := $GetFieldFromValue($t16, $LibraAccount_WithdrawCapability_account_address);
    $t17 := $tmp;
    call $tmp := $CopyOrMoveValue($t17);
    $t18 := $tmp;
    call $tmp := $CopyOrMoveValue($t18);
    payee_address := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 9859, 5, $tmp);
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t22 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t23 := $tmp;
    call $LibraAccount_deposit_$direct_intra($Coin1_Coin1_type_value(), payer_address, payee_address, coin1, $t22, $t23);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t27 := $tmp;
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t28 := $tmp;
    call $LibraAccount_deposit_$direct_intra($Coin2_Coin2_type_value(), payer_address, payee_address, coin2, $t27, $t28);
    if ($abort_flag)
    {
        goto Abort;
    }

    return;

  Abort:
    $abort_flag := true;
}



procedure $LibraAccount_unstaple_lbr_$verify(cap: $Value, amount_lbr: $Value);



implementation $LibraAccount_unstaple_lbr_$verify(cap: $Value, amount_lbr: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume $IsValidU64(amount_lbr);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1173"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1174"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1175"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1176"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1177"} { contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr] } $FixedPoint32_FixedPoint32_is_well_formed(contents#$Memory($FixedPoint32_FixedPoint32_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1178"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1179"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1180"} { contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Preburn_is_well_formed(contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1181"} { contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr] } $DesignatedDealer_Dealer_is_well_formed(contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1182"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1183"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1184"} { contents#$Memory($LBR_Reserve_$memory)[$EmptyTypeValueArray, $inv_addr] } $LBR_Reserve_is_well_formed(contents#$Memory($LBR_Reserve_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1185"} { contents#$Memory($LBR_ReserveComponent_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LBR_ReserveComponent_is_well_formed(contents#$Memory($LBR_ReserveComponent_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1186"} { contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Credential_is_well_formed(contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1187"} { contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr] } $DualAttestation_Limit_is_well_formed(contents#$Memory($DualAttestation_Limit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1188"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1189"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1190"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1191"} { contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_WithdrawCapability_is_well_formed(contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1192"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1193"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1194"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $LibraAccount_unstaple_lbr_$def_verify(cap, amount_lbr);
}



procedure {:inline 1} $LibraAccount_withdraw_capability_address_$def(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_withdraw_capability_address_$def(cap: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 34632, 0, cap);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_WithdrawCapability_account_address);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(16, 34717, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_withdraw_capability_address_$direct_inter(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_withdraw_capability_address_$direct_inter(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    call $ret0 := $LibraAccount_withdraw_capability_address_$def(cap);
}



procedure {:inline 1} $LibraAccount_withdraw_capability_address_$direct_intra(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_withdraw_capability_address_$direct_intra(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    call $ret0 := $LibraAccount_withdraw_capability_address_$def(cap);
}



procedure {:inline 1} $LibraAccount_withdraw_capability_address(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_withdraw_capability_address(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    call $ret0 := $LibraAccount_withdraw_capability_address_$def(cap);
}



procedure {:inline 1} $LibraAccount_withdraw_capability_address_$def_verify(cap: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_withdraw_capability_address_$def_verify(cap: $Value) returns ($ret0: $Value)
{
  var $t1: $Value;
  var $t2: $Value;
  var $t3: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 34632, 0, cap);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t3 := $tmp;
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_WithdrawCapability_account_address);
    $t2 := $tmp;
    $ret0 := $t2;
    if (true)
    {
        assume $DebugTrackLocal(16, 34717, 4, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_withdraw_capability_address_$verify(cap: $Value) returns ($ret0: $Value);



implementation $LibraAccount_withdraw_capability_address_$verify(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1195"} { contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_WithdrawCapability_is_well_formed(contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    call $ret0 := $LibraAccount_withdraw_capability_address_$def_verify(cap);
}



procedure {:inline 1} $LibraAccount_withdraw_from_$def($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_withdraw_from_$def($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value)
{
  var account_balance: $Mutation;
  var payer: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Mutation;
  var $t19: $Mutation;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Mutation;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 17540, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 17540, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 17540, 2, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 17540, 3, metadata);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t32 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue($t30);
    $t8 := $tmp;
    call $tmp := $GetFieldFromValue($t8, $LibraAccount_WithdrawCapability_account_address);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    payer := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 17769, 5, $tmp);
    }

    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payer);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 17806, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(19);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 17806, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L0:
    call $t16 := $BorrowGlobal($LibraAccount_Balance_$memory, payer, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 17904, $abort_code);
        goto Abort;
    }

    call account_balance := $CopyOrMoveRef($t16);
    if (true)
    {
        assume $DebugTrackLocal(16, 17886, 4, $Dereference(account_balance));
    }

    call $t18 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, payer, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 18087, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t18));
    call $t19 := $BorrowField($t18, $LibraAccount_LibraAccount_sent_events);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t18);
    call $t21 := $Libra_currency_code($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_SentPaymentEvent_pack(0, 0, 0, $t32, $t21, $t31, $t33);
    $t24 := $tmp;
    call $tmp := $ReadRef($t19);
    $t34 := $tmp;
    call $t34 := $Event_emit_event($LibraAccount_SentPaymentEvent_type_value(), $t34, $t24);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $WriteRef($t19, $t34);
    if (true)
    {
        assume $DebugTrackLocal(16, 18374, 4, $Dereference(account_balance));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t19);
    call $t18 := $WritebackToReference($t19, $t18);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t18));
    call $t27 := $CopyOrMoveRef(account_balance);
    call $tmp := $ReadRef($t27);
    $t35 := $tmp;
    call $t29, $t35 := $LibraAccount_withdraw_from_balance($tv0, payer, $t31, $t35, $t32);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t27 := $WriteRef($t27, $t35);
    if (true)
    {
        assume $DebugTrackLocal(16, 18398, 4, $Dereference(account_balance));
    }

    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, $t27);
    $ret0 := $t29;
    if (true)
    {
        assume $DebugTrackLocal(16, 18338, 36, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_withdraw_from_$direct_intra($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_withdraw_from_$direct_intra($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume is#$Address(payee);
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier1196"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    call $ret0 := $LibraAccount_withdraw_from_$def($tv0, cap, payee, amount, metadata);
}



procedure {:inline 1} $LibraAccount_withdraw_from($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_withdraw_from($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume is#$Address(payee);
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier1197"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    call $ret0 := $LibraAccount_withdraw_from_$def($tv0, cap, payee, amount, metadata);
}



procedure {:inline 1} $LibraAccount_withdraw_from_$def_verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value);



implementation {:inline 1} $LibraAccount_withdraw_from_$def_verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value)
{
  var account_balance: $Mutation;
  var payer: $Value;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Mutation;
  var $t19: $Mutation;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Mutation;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Value;
  var $t32: $Value;
  var $t33: $Value;
  var $t34: $Value;
  var $t35: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 17540, 0, cap);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 17540, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 17540, 2, amount);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 17540, 3, metadata);
    }

    call $tmp := $CopyOrMoveValue(cap);
    $t30 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t31 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t32 := $tmp;
    call $tmp := $CopyOrMoveValue(metadata);
    $t33 := $tmp;
    call $tmp := $CopyOrMoveValue($t30);
    $t8 := $tmp;
    call $tmp := $GetFieldFromValue($t8, $LibraAccount_WithdrawCapability_account_address);
    $t9 := $tmp;
    call $tmp := $CopyOrMoveValue($t9);
    $t10 := $tmp;
    call $tmp := $CopyOrMoveValue($t10);
    payer := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 17769, 5, $tmp);
    }

    $tmp := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payer);
    $t12 := $tmp;
    call $tmp := $CopyOrMoveValue($t12);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 17806, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    $tmp := $Integer(19);
    $t14 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 17806, i#$Integer($t14));
    }

    $abort_code := i#$Integer($t14);
    goto Abort;

  L0:
    call $t16 := $BorrowGlobal($LibraAccount_Balance_$memory, payer, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 17904, $abort_code);
        goto Abort;
    }

    call account_balance := $CopyOrMoveRef($t16);
    if (true)
    {
        assume $DebugTrackLocal(16, 17886, 4, $Dereference(account_balance));
    }

    call $t18 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, payer, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 18087, $abort_code);
        goto Abort;
    }

    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t18));
    call $t19 := $BorrowField($t18, $LibraAccount_LibraAccount_sent_events);
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t18);
    call $t21 := $Libra_currency_code_$direct_inter($tv0);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $LibraAccount_SentPaymentEvent_pack(0, 0, 0, $t32, $t21, $t31, $t33);
    $t24 := $tmp;
    call $tmp := $ReadRef($t19);
    $t34 := $tmp;
    call $t34 := $Event_emit_event($LibraAccount_SentPaymentEvent_type_value(), $t34, $t24);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t19 := $WriteRef($t19, $t34);
    if (true)
    {
        assume $DebugTrackLocal(16, 18374, 4, $Dereference(account_balance));
    }

    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t19);
    call $t18 := $WritebackToReference($t19, $t18);
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t18));
    call $t27 := $CopyOrMoveRef(account_balance);
    call $tmp := $ReadRef($t27);
    $t35 := $tmp;
    call $t29, $t35 := $LibraAccount_withdraw_from_balance_$direct_intra($tv0, payer, $t31, $t35, $t32);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t27 := $WriteRef($t27, $t35);
    if (true)
    {
        assume $DebugTrackLocal(16, 18398, 4, $Dereference(account_balance));
    }

    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, $t27);
    $ret0 := $t29;
    if (true)
    {
        assume $DebugTrackLocal(16, 18338, 36, $ret0);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}



procedure $LibraAccount_withdraw_from_$verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value);



implementation $LibraAccount_withdraw_from_$verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_is_well_formed(cap);
    assume is#$Address(payee);
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {:qid "quantifier1198"} { $select_vector(metadata, $$0) } $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata, $$0)));
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1199"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1200"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1201"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1202"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1203"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1204"} { contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_CurrencyInfo_is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1205"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1206"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1207"} { contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_LibraAccount_is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1208"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1209"} { contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $LibraAccount_Balance_is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1210"} { contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_WithdrawCapability_is_well_formed(contents#$Memory($LibraAccount_WithdrawCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1211"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1212"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1213"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $ret0 := $LibraAccount_withdraw_from_$def_verify($tv0, cap, payee, amount, metadata);
}



procedure {:inline 1} $LibraAccount_withdraw_from_balance_$def($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $LibraAccount_withdraw_from_balance_$def($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var can_withdraw: $Value;
  var coin: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Mutation;
  var $t32: $Value;
  var $t33: $Mutation;
  var $t34: $Mutation;
  var $t35: $Mutation;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Mutation;
  var $t42: $Value;
  var $t43: $Mutation;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Mutation;
  var $t50: $Value;
  var $t51: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 15201, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 15201, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 15201, 2, balance);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 15201, 3, amount);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t46 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t47 := $tmp;
    call $tmp := $CopyOrMoveValue(balance);
    $t48 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t50 := $tmp;
    call $t49 := $BorrowLoc(48, $t48);
    call $t13 := $AccountFreezing_account_is_frozen($t46);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t13);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 15408, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t16 := $CopyOrMoveRef($t49);
    call $t48 := $WritebackToValue($t16, 48, $t48);
    $tmp := $Integer(16);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 15408, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L0:
    $tmp := $Boolean(true);
    $t20 := $tmp;
    call $t21 := $LibraAccount_should_track_limits_for_account($t46, $t47, $t20);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t21;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $t24 := $VASP_parent_address($t46);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t25 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($LibraAccount_AccountOperationsCapability_$memory, $t25, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 15849, $abort_code);
        goto Abort;
    }

    $t26 := $tmp;
    call $tmp := $GetFieldFromValue($t26, $LibraAccount_AccountOperationsCapability_limits_cap);
    $t27 := $tmp;
    call $t28 := $AccountLimits_update_withdrawal_limits($tv0, $t50, $t24, $t27);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t28);
    can_withdraw := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 15688, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue(can_withdraw);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 15967, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $t31 := $CopyOrMoveRef($t49);
    call $t48 := $WritebackToValue($t31, 48, $t48);
    $tmp := $Integer(6);
    $t32 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 15967, i#$Integer($t32));
    }

    $abort_code := i#$Integer($t32);
    goto Abort;

  L4:
    call $t33 := $CopyOrMoveRef($t49);
    call $t34 := $BorrowField($t33, $LibraAccount_Balance_coin);
    call $t48 := $WritebackToValue($t33, 48, $t48);
    call coin := $CopyOrMoveRef($t34);
    if (true)
    {
        assume $DebugTrackLocal(16, 16040, 5, $Dereference(coin));
    }

    call $t35 := $CopyOrMoveRef(coin);
    call $tmp := $ReadRef($t35);
    $t36 := $tmp;
    call coin := $WritebackToReference($t35, coin);
    call $t37 := $Libra_value($tv0, $t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Ge($t37, $t50);
    $t39 := $tmp;
    call $tmp := $CopyOrMoveValue($t39);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 16155, 10, $tmp);
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    call $t41 := $CopyOrMoveRef(coin);
    call $t48 := $WritebackToValue($t41, 48, $t48);
    call $t33 := $WritebackToReference($t41, $t33);
    $tmp := $Integer(5);
    $t42 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 16155, i#$Integer($t42));
    }

    $abort_code := i#$Integer($t42);
    goto Abort;

  L6:
    call $t43 := $CopyOrMoveRef(coin);
    call $tmp := $ReadRef($t43);
    $t51 := $tmp;
    call $t45, $t51 := $Libra_withdraw($tv0, $t51, $t50);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t43 := $WriteRef($t43, $t51);
    if (true)
    {
        assume $DebugTrackLocal(16, 16240, 5, $Dereference(coin));
    }

    call $t48 := $WritebackToValue($t43, 48, $t48);
    call $t33 := $WritebackToReference($t43, $t33);
    $ret0 := $t45;
    if (true)
    {
        assume $DebugTrackLocal(16, 16224, 52, $ret0);
    }

    $ret1 := $t48;
    if (true)
    {
        assume $DebugTrackLocal(16, 16224, 53, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure {:inline 1} $LibraAccount_withdraw_from_balance_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $LibraAccount_withdraw_from_balance_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume is#$Address(payer);
    assume is#$Address(payee);
    assume $LibraAccount_Balance_is_well_formed(balance);
    assume $IsValidU64(amount);
    call $ret0, $ret1 := $LibraAccount_withdraw_from_balance_$def($tv0, payer, payee, balance, amount);
}



procedure {:inline 1} $LibraAccount_withdraw_from_balance($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $LibraAccount_withdraw_from_balance($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume is#$Address(payer);
    assume is#$Address(payee);
    assume $LibraAccount_Balance_is_well_formed(balance);
    assume $IsValidU64(amount);
    call $ret0, $ret1 := $LibraAccount_withdraw_from_balance_$def($tv0, payer, payee, balance, amount);
}



procedure {:inline 1} $LibraAccount_withdraw_from_balance_$def_verify($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);



implementation {:inline 1} $LibraAccount_withdraw_from_balance_$def_verify($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
  var can_withdraw: $Value;
  var coin: $Mutation;
  var $t6: $Value;
  var $t7: $Value;
  var $t8: $Value;
  var $t9: $Value;
  var $t10: $Value;
  var $t11: $Value;
  var $t12: $Value;
  var $t13: $Value;
  var $t14: $Value;
  var $t15: $Value;
  var $t16: $Mutation;
  var $t17: $Value;
  var $t18: $Value;
  var $t19: $Value;
  var $t20: $Value;
  var $t21: $Value;
  var $t22: $Value;
  var $t23: $Value;
  var $t24: $Value;
  var $t25: $Value;
  var $t26: $Value;
  var $t27: $Value;
  var $t28: $Value;
  var $t29: $Value;
  var $t30: $Value;
  var $t31: $Mutation;
  var $t32: $Value;
  var $t33: $Mutation;
  var $t34: $Mutation;
  var $t35: $Mutation;
  var $t36: $Value;
  var $t37: $Value;
  var $t38: $Value;
  var $t39: $Value;
  var $t40: $Value;
  var $t41: $Mutation;
  var $t42: $Value;
  var $t43: $Mutation;
  var $t44: $Value;
  var $t45: $Value;
  var $t46: $Value;
  var $t47: $Value;
  var $t48: $Value;
  var $t49: $Mutation;
  var $t50: $Value;
  var $t51: $Value;
  var $tmp: $Value;

    assume !$abort_flag;
    if (true)
    {
        assume $DebugTrackLocal(16, 15201, 0, payer);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 15201, 1, payee);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 15201, 2, balance);
    }

    if (true)
    {
        assume $DebugTrackLocal(16, 15201, 3, amount);
    }

    call $tmp := $CopyOrMoveValue(payer);
    $t46 := $tmp;
    call $tmp := $CopyOrMoveValue(payee);
    $t47 := $tmp;
    call $tmp := $CopyOrMoveValue(balance);
    $t48 := $tmp;
    call $tmp := $CopyOrMoveValue(amount);
    $t50 := $tmp;
    call $t49 := $BorrowLoc(48, $t48);
    call $t13 := $AccountFreezing_account_is_frozen_$direct_inter($t46);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Not($t13);
    $t14 := $tmp;
    call $tmp := $CopyOrMoveValue($t14);
    $t6 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 15408, 6, $tmp);
    }

    $tmp := $t6;
    if (b#$Boolean($tmp))
    {
        goto L0;
    }
    else
    {
        goto L1;
    }

  L1:
    call $t16 := $CopyOrMoveRef($t49);
    call $t48 := $WritebackToValue($t16, 48, $t48);
    $tmp := $Integer(16);
    $t17 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 15408, i#$Integer($t17));
    }

    $abort_code := i#$Integer($t17);
    goto Abort;

  L0:
    $tmp := $Boolean(true);
    $t20 := $tmp;
    call $t21 := $LibraAccount_should_track_limits_for_account_$direct_intra($t46, $t47, $t20);
    if ($abort_flag)
    {
        goto Abort;
    }

    $tmp := $t21;
    if (b#$Boolean($tmp))
    {
        goto L2;
    }
    else
    {
        goto L3;
    }

  L3:
    goto L4;

  L2:
    call $t24 := $VASP_parent_address_$direct_inter($t46);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t25 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_inter();
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $GetGlobal($LibraAccount_AccountOperationsCapability_$memory, $t25, $EmptyTypeValueArray);
    if ($abort_flag)
    {
        assume $DebugTrackAbort(16, 15849, $abort_code);
        goto Abort;
    }

    $t26 := $tmp;
    call $tmp := $GetFieldFromValue($t26, $LibraAccount_AccountOperationsCapability_limits_cap);
    $t27 := $tmp;
    call $t28 := $AccountLimits_update_withdrawal_limits_$direct_inter($tv0, $t50, $t24, $t27);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $CopyOrMoveValue($t28);
    can_withdraw := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 15688, 4, $tmp);
    }

    call $tmp := $CopyOrMoveValue(can_withdraw);
    $t8 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 15967, 8, $tmp);
    }

    $tmp := $t8;
    if (b#$Boolean($tmp))
    {
        goto L4;
    }
    else
    {
        goto L5;
    }

  L5:
    call $t31 := $CopyOrMoveRef($t49);
    call $t48 := $WritebackToValue($t31, 48, $t48);
    $tmp := $Integer(6);
    $t32 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 15967, i#$Integer($t32));
    }

    $abort_code := i#$Integer($t32);
    goto Abort;

  L4:
    call $t33 := $CopyOrMoveRef($t49);
    call $t34 := $BorrowField($t33, $LibraAccount_Balance_coin);
    call $t48 := $WritebackToValue($t33, 48, $t48);
    call coin := $CopyOrMoveRef($t34);
    if (true)
    {
        assume $DebugTrackLocal(16, 16040, 5, $Dereference(coin));
    }

    call $t35 := $CopyOrMoveRef(coin);
    call $tmp := $ReadRef($t35);
    $t36 := $tmp;
    call coin := $WritebackToReference($t35, coin);
    call $t37 := $Libra_value_$direct_inter($tv0, $t36);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $tmp := $Ge($t37, $t50);
    $t39 := $tmp;
    call $tmp := $CopyOrMoveValue($t39);
    $t10 := $tmp;
    if (true)
    {
        assume $DebugTrackLocal(16, 16155, 10, $tmp);
    }

    $tmp := $t10;
    if (b#$Boolean($tmp))
    {
        goto L6;
    }
    else
    {
        goto L7;
    }

  L7:
    call $t41 := $CopyOrMoveRef(coin);
    call $t48 := $WritebackToValue($t41, 48, $t48);
    call $t33 := $WritebackToReference($t41, $t33);
    $tmp := $Integer(5);
    $t42 := $tmp;
    if (true)
    {
        assume $DebugTrackAbort(16, 16155, i#$Integer($t42));
    }

    $abort_code := i#$Integer($t42);
    goto Abort;

  L6:
    call $t43 := $CopyOrMoveRef(coin);
    call $tmp := $ReadRef($t43);
    $t51 := $tmp;
    call $t45, $t51 := $Libra_withdraw_$direct_inter($tv0, $t51, $t50);
    if ($abort_flag)
    {
        goto Abort;
    }

    call $t43 := $WriteRef($t43, $t51);
    if (true)
    {
        assume $DebugTrackLocal(16, 16240, 5, $Dereference(coin));
    }

    call $t48 := $WritebackToValue($t43, 48, $t48);
    call $t33 := $WritebackToReference($t43, $t33);
    $ret0 := $t45;
    if (true)
    {
        assume $DebugTrackLocal(16, 16224, 52, $ret0);
    }

    $ret1 := $t48;
    if (true)
    {
        assume $DebugTrackLocal(16, 16224, 53, $ret1);
    }

    return;

  Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}



procedure $LibraAccount_withdraw_from_balance_$verify($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value);
  ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payer))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField(balance, $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
  ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))))) ==> $abort_flag;
  ensures $abort_flag ==> b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payer))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))))))) || b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField(balance, $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)), $AccountLimits_Window_limit_address)))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))))))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($SelectField($ret1, $LibraAccount_Balance_coin), $Libra_Libra_value), $Integer(i#$Integer(old($SelectField($SelectField(balance, $LibraAccount_Balance_coin), $Libra_Libra_value))) - i#$Integer(amount)))));
  ensures !$abort_flag ==> b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), amount)));



implementation $LibraAccount_withdraw_from_balance_$verify($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume is#$Address(payer);
    assume is#$Address(payee);
    assume $LibraAccount_Balance_is_well_formed(balance);
    assume $IsValidU64(amount);
    call $InitVerification();
    assume (forall $inv_addr: int :: {:qid "quantifier1214"} { contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1215"} { contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr] } $AccountFreezing_FreezingBit_is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1216"} { contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_LimitsDefinition_is_well_formed(contents#$Memory($AccountLimits_LimitsDefinition_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1217"} { contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $AccountLimits_Window_is_well_formed(contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {:qid "quantifier1218"} { contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr] } $Libra_Libra_is_well_formed(contents#$Memory($Libra_Libra_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1219"} { contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ChildVASP_is_well_formed(contents#$Memory($VASP_ChildVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1220"} { contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr] } $VASP_ParentVASP_is_well_formed(contents#$Memory($VASP_ParentVASP_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume (forall $inv_addr: int :: {:qid "quantifier1221"} { contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr] } $LibraAccount_AccountOperationsCapability_is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]));
    assume b#$Boolean($Boolean((forall child_addr: $Value :: {:qid "quantifier1222"} is#$Address(child_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_child_vasp($VASP_ChildVASP_$memory, child_addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, $SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, child_addr), $VASP_ChildVASP_parent_vasp_addr))))))));
    assume b#$Boolean($Boolean((forall parent_addr: $Value :: {:qid "quantifier1223"} is#$Address(parent_addr) ==> b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_parent_vasp($VASP_ParentVASP_$memory, parent_addr)) ==> b#$Boolean($Boolean(i#$Integer($SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent_addr), $VASP_ParentVASP_num_children)) <= i#$Integer($Integer(256)))))))));
    assume b#$Boolean($Boolean((forall child_addr1: $Value :: {:qid "quantifier1224"} is#$Address(child_addr1) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, child_addr1)) ==> b#$Boolean($VASP_spec_is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, child_addr1)))))));
    call $ret0, $ret1 := $LibraAccount_withdraw_from_balance_$def_verify($tv0, payer, payee, balance, amount);
}


















































